#!/usr/bin/env lua
--[[
-- This file is automatically generated.
-- Check the github repository for a readable version:
-- http://github.com/fsantanna/ceu
--
-- CÃ©u is distributed under the MIT License:
--

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--
--]]

FILES = {
    ceu_types_h =
        [====[
#ifndef _CEU_TYPES_H
#define _CEU_TYPES_H

#include <stdint.h>

#ifdef __LP64__
typedef unsigned long word;
#else
typedef unsigned int  word;
#endif
typedef unsigned int  uint;
typedef unsigned char byte;
#ifndef __cplusplus
typedef unsigned char bool;
#endif

typedef int64_t  s64;
typedef int32_t  s32;
typedef int16_t  s16;
typedef int8_t    s8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t   u8;

typedef float    f32;
typedef double   f64;

#endif
]====],
    template_h =
        [====[
#ifndef === DEFS_H ===
#define === DEFS_H ===

#include "ceu_types.h"

=== DEFINES ===     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef === TCEU_NLBL === tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef === TCEU_NCLS === tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS === CEU_NTRAILS ===

#include "ceu_os.h"

#ifdef CEU_NEWS_POOL
#include "ceu_pool.h"
#endif

#ifdef CEU_VECTOR
#include "ceu_vector.h"
#endif

=== NATIVE_PRE ===
=== ISRS ===        /* CEU_ISR_ */
=== EVENTS ===      /* CEU_IN_, CEU_OUT_ */
=== FUNCTIONS ===   /* CEU_FUN_ */
=== TUPLES ===

/* class/adts definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */
=== TOPS_H ===

#endif
]====],
    template_c =
        [====[
#line 1 "=== FILENAME ==="

=== OUT_H ===
#include "ceu_os.h"

#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#include "ceu_pool.h"
#endif

#ifdef CEU_VECTOR
#include "ceu_vector.h"
#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#endif

/* native code from the Main class */
=== NATIVE ===

/* goto labels */
enum {
=== LABELS_ENUM ===
};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][=== IFCS_NIFCS ===];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16       ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
    void*     ifcs_funs[CEU_NCLS][=== IFCS_NFUNS ===];
#endif
} _tceu_app;

/* TODO: remove from RAM */
#ifdef CEU_IFCS
static _tceu_app _CEU_APP = {
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    {
=== IFCS_CLSS ===
    },
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
    {
=== IFCS_FUNS ===
    }
};
#endif

=== TOPS_C ===

/**********************************************************************/

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    printf("SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    printf("SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS
=== PRES_C ===
#endif

#ifdef CEU_ORGS
=== CONSTRS_C ===
#endif

#ifdef CEU_THREADS
/* THREADS_C */
=== THREADS_C ===
#endif

#ifdef CEU_ISRS
/* ISRS_C */
=== ISRS_C ===
#endif

/* FUNCTIONS_C */
=== FUNCTIONS_C ===

#ifdef CEU_OS_APP
static void* ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, void* param) {
    switch (evt) {
        /* STUBS */
        === STUBS ===
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
        ceu_out_log(0, (long)"invalid call\n");
#endif
    }
    return NULL;
}
#endif

static void ceu_app_go (tceu_app* _ceu_app, tceu_evt* _ceu_evt, tceu_org* _ceu_org, tceu_trl* _ceu_trl,
                        tceu_stk* _ceu_stk)
{
    tceu_nlbl _ceu_lbl = _ceu_trl->lbl;

#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS_APP
#ifdef CEU_ORGS
    _ceu_app->lst.org = _ceu_org;
#endif
    _ceu_app->lst.trl = _ceu_trl;
    _ceu_app->lst.lbl = _ceu_lbl;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS_APP
printf("OK : lbl=%d : org=%p\n", _ceu_lbl, _ceu_org);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_ceu_lbl) {
        === CODE ===
    }
#ifdef CEU_DEBUG
    ceu_out_assert_msg(0, "no return");
#endif
}

#ifdef CEU_OS_APP
static __attribute__((noinline))  __attribute__((noclone))
#endif
void
ceu_app_init (tceu_app* app)
{
    app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS_APP)
    app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    app->pendingAsyncs = 1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    app->dont_emit_kill = 0;
#endif
#ifdef CEU_RET
    app->ret = 0;
#endif
#ifdef CEU_ORGS_NEWS_MALLOC
    app->tofree = NULL;
#endif
#ifdef CEU_WCLOCKS
    app->wclk_late = 0;
    app->wclk_min_set = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    app->wclk_late_ = 0;
    app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif

    === TOPS_INIT ===

#ifdef CEU_OS_APP
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#else
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
#endif

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
    CEU_APP_SIG = app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org_init(app, app->data, CEU_NTRAILS, Class_Main,
                     0, 0,
                     NULL, 0);

#ifdef CEU_LUA
    ceu_luaL_newstate(app->lua);
    ceu_out_assert(app->lua != NULL);
    ceu_luaL_openlibs(app->lua);
    ceu_lua_atpanic(app->lua, ceu_lua_atpanic_f);    /* TODO: CEU_OS */
#endif

    app->data->trls[0].evt = CEU_IN__INIT;
    app->data->trls[0].seqno = 0;
    ceu_sys_go(app, CEU_IN__INIT, NULL);
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS_APP
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                , char** luaifc
#endif
) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
#ifdef CEU_OS_LUAIFC
    *luaifc = (=== APP_LUAIFC ===);
#endif
}
#endif
]====],
    ceu_os_h =
        [====[
#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

    #define CEU_QUEUE_MAX 65536

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISRS
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include <unistd.h>     /* usleep */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app, int argc, char **argv);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISRS
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISRS
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISRS
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */
]====],
    ceu_os_c =
        [====[
#include "ceu_os.h"

#ifdef CEU_ISRS
    #ifndef ceu_out_isr_on
        #error "Missing definition for macro \"ceu_out_isr_on\"."
    #endif
    #ifndef ceu_out_isr_off
        #error "Missing definition for macro \"ceu_out_isr_off\"."
    #endif
    #ifndef ceu_out_isr_attach
        #error "Missing definition for macro \"ceu_out_isr_attach\"."
    #endif
    #ifndef ceu_out_isr_detach
        #error "Missing definition for macro \"ceu_out_isr_detach\"."
    #endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#endif

#if defined(CEU_DEBUG) || defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL)
void *realloc(void *ptr, size_t size);
#endif

#ifdef CEU_NEWS_POOL
#include "ceu_pool.h"
#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************
 * "APPS" running on the OS do not need any of the below.
 **********************************************************************/

#ifndef CEU_OS_APP

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL) || defined(CEU_VECTOR_MALLOC)
void* ceu_sys_realloc (void* ptr, size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (size == 0) {
        if (ptr != NULL) {
            _ceu_dyns_--;
        }
    } else {
        if (_ceu_dyns_ >= CEU_MAX_DYNS) {
            return NULL;
        }
        _ceu_dyns_++;           /* assumes no malloc fails */
    }
#endif
#endif
    return realloc(ptr, size);
}
#endif

#ifdef CEU_VECTOR
#include "ceu_vector.h"
byte* ceu_vector_geti_ex (tceu_vector* vector, int idx, char* file, int line) {
    byte* ret = ceu_vector_geti(vector, idx);
    ceu_out_assert_msg_ex(ret!=NULL, "access out of bounds", file, line);
    return ret;
}
#endif

int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF);

/**********************************************************************/

void ceu_sys_org_init (tceu_org* org, int n, int lbl,
                       int cls, int isDyn,
                       tceu_org* parent_org, tceu_ntrl parent_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));
    org->trls[0].lbl = lbl;

#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
    org->n  = n;
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    org->cls = cls;
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
    org->isAlive = 1;
#endif

#ifdef CEU_ORGS_NEWS
    org->isDyn = isDyn;
#endif

    org->parent_org = parent_org;
    org->parent_trl = parent_trl;
    org->nxt = NULL;
    if (parent_org != NULL) {
        tceu_trl* trl = &parent_org->trls[parent_trl];
        if (trl == NULL) {
            org->prv = NULL; /* main class */
        } else {
            /* re-link */
            if (trl->org == NULL) {
                trl->org = org;
            } else {
                tceu_org* last = trl->org->prv;
                last->nxt = org;
                org->prv = last;
            }
            trl->org->prv = org;
        }
    }

#ifdef CEU_ORGS_AWAIT
    org->ret = 0;   /* TODO: still required? */
#endif

#endif  /* CEU_ORGS */
}

#ifdef CEU_ORGS

static void ceu_sys_org_free (tceu_app* app, tceu_org* org)
{
    /* TODO: try to not depend on this and remove this field */
    if (org->isAlive) {
        org->isAlive = 0;
    } else {
        return;
    }

    /* re-link PRV <-> NXT */
    /* relink also static orgs for efficiency */
    tceu_trl* trl = &org->parent_org->trls[org->parent_trl];
    if (trl->org == org) {
        trl->org = org->nxt;        /* subst 1st org */
    } else {
        org->prv->nxt = org->nxt;
    }
    if (org->nxt == NULL) {
        if (trl->org != NULL) {
            trl->org->prv = org->prv;   /* subst lst org */
        }
    } else {
        org->nxt->prv = org->prv;
    }

#ifdef CEU_ORGS_NEWS
    /* free */
    if (org->isDyn) {
#if    defined(CEU_ORGS_NEWS_POOL) && !defined(CEU_ORGS_NEWS_MALLOC)
        ceu_pool_free(&org->pool->pool, (byte*)org);
#elif  defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        if (org->pool->pool.queue == NULL) {
            org->nxt = app->tofree;
            app->tofree = org;
        } else {
            ceu_pool_free(&org->pool->pool, (byte*)org);
        }
#elif !defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        org->nxt = app->tofree;
        app->tofree = org;
#endif
    }
#endif
}

/*
 * Checks if "me" is cleared due to a clear in "clr_org".
 * ;
 */
static int ceu_org_is_cleared (tceu_org* me, tceu_org* clr_org,
                               tceu_ntrl clr_t1, tceu_ntrl clr_t2)
{
    if (me == clr_org) {
        return (clr_t1==0 && clr_t2==me->n-1);
    }

    tceu_org* cur_org;
    for (cur_org=me; cur_org!=NULL; cur_org=cur_org->parent_org) {
        if (cur_org->parent_org == clr_org) {
            if (cur_org->parent_trl>=clr_t1 && cur_org->parent_trl<=clr_t2) {
                return 1;
            }
        }
    }
    return 0;
}

#endif  /* CEU_ORGS */

/**********************************************************************/

#ifdef CEU_STACK_CLEAR
void ceu_sys_stack_dump (tceu_stk* stk) {
    printf(">>> STACK DUMP:\n");
    for (; stk!=NULL; stk=stk->down) {
        printf("\t[%p] down=%p org=%p trls=[%d,%d]\n",
            stk, stk->down, stk->org, stk->trl1, stk->trl2);
    }
}

/*
 * Trails [t1,t2] of "org" are dyeing.
 * Traverse the stack to see if a pending call is enclosed by this range.
 * If so, the whole stack has to unwind and continue from what we pass in 
 * lbl_or_org.
 */
void ceu_sys_stack_clear (tceu_stk* stk, tceu_org* org,
                          tceu_ntrl t1, tceu_ntrl t2) {
    for (; stk->down!=NULL; stk=stk->down) {
        if (!stk->is_alive) {
            continue;
        }
#ifdef CEU_ORGS
        if (stk->org != org) {
            if (ceu_org_is_cleared(stk->org, org, t1, t2)) {
                stk->is_alive = 0;
            }
        }
        else
#endif
        {
            if (t1<=stk->trl1 && stk->trl2<=t2) {
                stk->is_alive = 0;
            }
        }
    }
}
#endif

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_cmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set > t) ) {
        app->wclk_min_set = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp_) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set_ > t) ) {
        app->wclk_min_set_ = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic_f (lua_State* lua) {
#ifdef CEU_DEBUG
    char msg[255] = "LUA_ATPANIC: ";
    strncat(msg, lua_tostring(lua,-1), 100);
    strncat(msg, "\n", 1);
    ceu_out_assert_msg(0, msg);
/*
*/
#else
    ceu_out_assert_msg(0, "bug found");
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_PSES
#ifdef CEU_OS_KERNEL
#error Not implemented!
#endif
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG) {
                trl->evt = CEU_IN__ORG_PSED;
            }
        } else {
            if (trl->evt == CEU_IN__ORG_PSED) {
                trl->evt = CEU_IN__ORG;
            }
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_OS_KERNEL
u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */
#endif

#ifdef CEU_DEBUG_TRAILS
static int spc = -1;
#define SPC(n) { int i; for(i=0; i<(spc+n)*4; i++) printf(" "); };

void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF);
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF) {
    spc++;
    SPC(0); printf(">>> GO-EX\n");
    SPC(0); printf("evt: %d\n", evt->id);
    #ifdef CEU_ORGS
    SPC(0); printf("org: %p\n", org);
    SPC(2); printf("[%p]=>[%p]\n", &org->trls[0],
                                   &org->trls[org->n]);
    #endif

    ceu_sys_go_ex_dbg(app,evt,stk,org,trl0,trlF);

    SPC(0); printf("<<< GO-EX\n");
    spc--;
}
#endif

#ifdef CEU_DEBUG_TRAILS
void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF)
#else
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF)
    /* TODO: now all arguments are required in all configurations */
#endif
{
    tceu_ntrl trlI;
    tceu_trl* trl;
    for (trlI=trl0, trl=&org->trls[trlI];
#ifdef CEU_STACK_CLEAR
         stk->is_alive &&
#endif
            trlI<trlF;
         trlI++, trl++)
    {
#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("trl: %p\n", trl);
/*SPC(2); printf("seqno: %d\n", trl->seqno);*/
SPC(2); printf("evt: %d\n", trl->evt);
SPC(2); printf("lbl: %d\n", trl->lbl);
#endif

        /* continue traversing current org */

        /* jump into linked orgs */
#ifdef CEU_ORGS
        if ( (trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
          || (trl->evt==CEU_IN__ORG_PSED && evt->id==CEU_IN__CLEAR)
#endif
           )
        {
            tceu_org* cur = trl->org;

            if (evt->id == CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ below */
            }

            /* traverse all children */
            if (cur != NULL) {
#ifdef CEU_STACK_CLEAR
                tceu_stk stk_ = { stk, org, cur->parent_trl, cur->parent_trl, 1 };
#endif
                while (cur != NULL) {
                    tceu_org* nxt = cur->nxt;   /* save before possible free/relink */
#ifdef CEU_STACK_CLEAR
                    ceu_sys_go_ex(app, evt, &stk_, cur, 0, cur->n);
                    if (!stk->is_alive) {
                        return; /* whole outer traversal aborted */
                    }
#if 0
if (!stk_.is_alive) {
printf("aborted\n");
    break; /* all children traversal aborted */
}
#endif
#else
                    ceu_sys_go_ex(app, evt, NULL, cur, 0, cur->n);
#endif
                    cur = nxt;
                }
            }
            continue;   /* next trail after handling children */
        }
#endif /* CEU_ORGS */

        /* EXECUTE THIS TRAIL */
#if 0
printf("%d==%d && %d!=%d && %d>=%d\n",
        trl->evt, evt->id,
        trl->seqno, app->seqno,
        evt->id, CEU_IN_lower
);
if (evt->param != NULL) {
    printf("trl->org_or_adt=%p // param=%p\n", trl->org_or_adt,
                 ((tceu_kill*)evt->param)->org_or_adt);
}
#endif

        if (
#ifdef CEU_CLEAR
            /* if IN__CLEAR and "finalize" clause */
            (evt->id==CEU_IN__CLEAR && trl->evt==CEU_IN__CLEAR)
        ||
#endif
#ifdef CEU_ORGS_AWAIT
            /* if */
            (evt->id==CEU_IN__ok_killed && trl->evt==CEU_IN__ok_killed &&
#ifdef CEU_ADTS_AWAIT
                trl->is_org &&
#endif
                (trl->org_or_adt == NULL || /* for option ptrs, init'd w/ NULL  */
                 ceu_org_is_cleared((tceu_org*)trl->org_or_adt,
                    (tceu_org*)((tceu_kill*)evt->param)->org_or_adt,
                    ((tceu_kill*)evt->param)->t1,
                    ((tceu_kill*)evt->param)->t2)))
        ||
#endif
#ifdef CEU_ADTS_AWAIT
            /* if */
            (evt->id==CEU_IN__ok_killed && trl->evt==CEU_IN__ok_killed &&
#ifdef CEU_ORGS_AWAIT
                !trl->is_org &&
#endif
                trl->org_or_adt == ((tceu_kill*)evt->param)->org_or_adt)
        ||
#endif
            /* if evt->id matches awaiting trail */
            (trl->evt==evt->id && trl->seqno!=app->seqno
#ifdef CEU_ORGS_OR_ADTS_AWAIT
                && (evt->id != CEU_IN__ok_killed)
                    /* TODO: simplify */
#endif
#ifdef CEU_INTS
#ifdef CEU_ORGS
                && (evt->id>=CEU_IN_lower || evt->org==trl->evto)
#endif
#endif
            )
           )
        {
            /*** CODE ***/
            trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            app->code(app, evt, org, trl, stk);
#ifdef CEU_STACK_CLEAR
            if (!stk->is_alive) {
                return;
            }
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_LUA)
            if (!app->isAlive) {
#ifdef CEU_OS_KERNEL
                CEU_GC = 1;
#endif
#ifdef CEU_LUA
                lua_close(app->lua);
#endif
            }
#endif
        }

        /* DON'T EXECUTE THIS TRAIL */
        else
        {
#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("<<< NO\n");
#endif
#ifdef CEU_CLEAR
            if (evt->id==CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            }
#endif
        }

        /* NEXT TRAIL */

        if (trl->evt<=CEU_IN_higher && trl->seqno!=app->seqno) {
            trl->seqno = app->seqno-1;   /* keeps the gap tight */
        }
    }

#ifdef CEU_ORGS
    /* clearing the whole org? */
    if (evt->id==CEU_IN__CLEAR && org!=app->data && trl0==0 && trlF==org->n) {
        /* yes, relink and put it in the free list */
        ceu_sys_org_free(app, org);
    }
#endif
}

void ceu_sys_go_stk (tceu_app* app, int evt, void* evtp, tceu_stk* stk) {
    app->seqno++;
#ifdef CEU_DEBUG_TRAILS
    printf("===> [%d] %d\n", evt, app->seqno);
#endif

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            app->wclk_min_cmp = app->wclk_min_set;      /* swap "cmp" to last "set" */
            app->wclk_min_set = CEU_WCLOCK_INACTIVE;    /* new "set" resets to inactive */
            if (app->wclk_min_cmp <= *((s32*)evtp)) {
                app->wclk_late = *((s32*)evtp) - app->wclk_min_cmp;
            }
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            app->wclk_min_cmp_ = app->wclk_min_set_;
            app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
            if (app->wclk_min_cmp_ <= *((s32*)evtp)) {
                app->wclk_late_ = *((s32*)evtp) - app->wclk_min_cmp_;
            }
            break;
#endif
#endif
    }

    {
        tceu_evt evt_;
                 evt_.id = evt;
                 evt_.param = &evtp;
        ceu_sys_go_ex(app, &evt_,
                      stk,
                      app->data, 0,
#ifdef CEU_ORGS
                      app->data->n
#else
                      CEU_NTRAILS
#endif
        );
    }

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
#ifdef ceu_out_wclock_set
        /* no new sets, signal inactive */
        if (app->wclk_min_set == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
#ifdef ceu_out_wclock_set
        if (app->wclk_min_set_ == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late_ = 0;
    }
#endif
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    while (app->tofree != NULL) {
        tceu_org* nxt = app->tofree->nxt;
        ceu_sys_realloc(app->tofree, 0);
        app->tofree = nxt;
    }
#endif
}

void ceu_sys_go (tceu_app* app, int evt, void* evtp)
{
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { NULL, NULL, 0, 0, 1 };
    ceu_sys_go_stk(app, evt, evtp, &stk_);
#else
    ceu_sys_go_stk(app, evt, evtp, NULL);
#endif
}

typedef struct {
    int    argc;
    char** argv;
} tceu_os_start;

int ceu_go_all (tceu_app* app, int argc, char **argv)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
    if (app->isAlive)
#endif
    {
        tceu_os_start arg = { argc, argv };
        ceu_sys_go(app, CEU_IN_OS_START, &arg);
    }
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, NULL);
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
#if 0
        CEU_THREADS_YIELD();    /* should work with single cores? */
#endif
        usleep(100);            /* should work anyway */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    ceu_out_assert_msg(_ceu_dyns_ == 0, "memory leak");
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

/**********************************************************************
 * Only the OS kernel needs any of the below.
 **********************************************************************/

#ifdef CEU_OS_KERNEL

/*
 * SYS_VECTOR:
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_out_assert,
    (void*) &ceu_out_log,
    (void*) &ceu_sys_realloc,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISRS
    (void*) &ceu_sys_isr,
#endif
    (void*) &ceu_sys_org_init,
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    ceu_out_isr_off();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        ceu_sys_assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    ceu_out_isr_on();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, int sz, byte* buf) {
    ceu_out_isr_off();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX) {
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */
    }

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;
        memcpy(qu->buf, buf, sz);
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    ceu_out_isr_on();
    return 1;
}

void ceu_sys_queue_rem (void) {
    ceu_out_isr_off();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    ceu_out_isr_on();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this indirection */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, int sz, void* param) {
    return ceu_sys_queue_put(app, evt, sz, param);
}

void* ceu_sys_call (tceu_app* app, tceu_nevt evt, void* param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt) {
            continue;
        }
        void* ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
        return ret;
    }
/* TODO: error? */
    return NULL;
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk) {
			cur = cur->nxt;
        }
        if (cur->nxt != NULL) {
            cur->nxt = lnk->nxt;
        }
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_realloc(lnk, 0);
}

static void __ceu_os_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        ceu_out_isr_off();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        ceu_out_isr_on();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive) {
                _ceu_sys_unlink(cur);
            }
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_realloc(app->data, 0);
            ceu_sys_realloc(app, 0);
        }

        app = nxt;
    }
}

#ifdef CEU_ISRS

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_os_init (void) {
#ifdef CEU_ISRS
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    ceu_out_isr_on();       /* enable global interrupts to start */
#endif
}

int ceu_os_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_os_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, &dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, &_dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, NULL);
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            ceu_out_isr_off();
            int tot = QUEUE_tot;
            ceu_out_isr_on();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->buf);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->buf);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_os_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;
#ifdef CEU_OS_LUAIFC
    char*      luaifc;
#endif

    ((tceu_export) addr)(&size, &init
#ifdef CEU_OS_LUAIFC
                        , &luaifc
#endif
                        );

    tceu_app* app = (tceu_app*) ceu_sys_realloc(NULL, sizeof(tceu_app));
    if (app == NULL) {
        return NULL;
    }

    app->data = (tceu_org*) ceu_sys_realloc(NULL, size);
    if (app->data == NULL) {
        return NULL;
    }

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
    app->init = (tceu_init) ((word)init);
    app->addr = addr;

#ifdef CEU_OS_LUAIFC
    app->luaifc = luaifc;
#endif

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

    app->init(app);

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_realloc(NULL, sizeof(tceu_lnk));
    if (lnk == NULL) {
        return 0;
    }

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISRS

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISRS */

#endif /* ifdef CEU_OS_KERNEL */

#endif /* ifndef CEU_OS_APP */
]====],
    ceu_pool_h =
        [====[
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif
]====],
    ceu_pool_c =
        [====[
/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>
#include "ceu_pool.h"

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif
]====],
    ceu_vector_h =
        [====[
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#include "ceu_os.h"

typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif
]====],
    ceu_vector_c =
        [====[
#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C

#include "ceu_vector.h"

void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif
]====],
    ceu_threads_h =
        [====[
#ifndef _CEU_THREADS_H
#define _CEU_THREADS_H

#if 0
Not using yield anymore
#include <sched.h>
#define _GNU_SOURCE
#endif

#include <pthread.h>

#define CEU_THREADS_T               pthread_t
#define CEU_THREADS_MUTEX_T         pthread_mutex_t
#define CEU_THREADS_SELF()          pthread_self()
#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)
#define CEU_THREADS_DETACH(t)       pthread_detach(t)
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m);
/*
#define CEU_THREADS_COND_T          pthread_cond_t
#define CEU_THREADS_YIELD()         assert(sched_yield()==0)
#define CEU_THREADS_YIELD()         assert(pthread_yield()==0)
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m); printf("L[%d]\n",__LINE__)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m); printf("U[%d]\n",__LINE__)
#define CEU_THREADS_COND_WAIT(c,m)  pthread_cond_wait(c,m)
#define CEU_THREADS_COND_SIGNAL(c)  pthread_cond_signal(c)
*/

#endif
]====],
}
OPTS_NPARAMS = {
    version   = 0,
    input     = nil,

    out_c     = 1,
    out_h     = 1,
    out_s     = 1,
    out_f     = 1,

    tmp_vars  = 0,
    join      = 0,
    c_calls   = 1,

    tuple_vector = 0,

    cpp       = 0,
    cpp_exe   = 1,
    cpp_args  = 1,

    safety    = 1,

    tp_word   = 1,

    os        = 0,
    os_luaifc = 0,

    timemachine = 0,
    reentrant = 0,

    verbose = 0,
}

OPTS = {
    input     = nil,

    out_c     = '_ceu_app.c',
    out_h     = '_ceu_app.h',
    out_s     = 'CEU_SIZE',
    out_f     = 'ceu_app_init',

    tmp_vars  = true,
    join      = true,
    c_calls   = nil,    -- [nil=accept]

    tuple_vector = false,

    cpp       = true,
    cpp_exe   = 'cpp',
    cpp_args  = false,

    safety    = 0,

    tp_word   = 4,

    os        = false,
    os_luaifc = false,

    timemachine = false,
    reentrant = false,

    verbose = false,
}

local params = {...}
local i = 1
while i <= #params
do
    local p = params[i]
    i = i + 1

    if p == '-' then
        OPTS.input = '-'

    elseif string.sub(p, 1, 2) == '--' then
        local no = false
        local opt = string.gsub(string.sub(p,3), '%-', '_')
        if string.find(opt, '^no_') then
            no = true
            opt = string.sub(opt, 4)
        end
        if OPTS_NPARAMS[opt]==0 or OPTS_NPARAMS[opt]==nil then
            OPTS[opt] = not no
        else
            local opt = string.gsub(string.sub(p,3), '%-', '_')
            OPTS[opt] = string.match(params[i], "%'?(.*)%'?")
            i = i + 1
        end

    else
        OPTS.input = p
    end
end

if OPTS.version then
    print 'ceu 0.10'
    os.exit(0)
end

if OPTS.safety then
    OPTS.safety = assert(tonumber(OPTS.safety), '`--safetyÂ´ must be a number')
end

if OPTS.os_luaifc then
    assert(OPTS.os, '`--os-luaifcÂ´ requires `--osÂ´')
end

if not OPTS.input then
    io.stderr:write([[

    ./ceu <filename>           # Ceu input file, or `-Â´ for stdin
    
        --out-c <filename>     # C output source file (_ceu_app.c)
        --out-h <filename>     # C output header file (_ceu_app.h)
        --out-s <NAME>         # TODO (CEU_SIZE)
        --out-f <NAME>         # TODO (ceu_app_init)
    
        --tmp-vars (--no-tmp-vars) # TODO
        --join (--no-join)     # join lines enclosed by /*{-{*/ and /*}-}*/ (join)
        --c-calls              # TODO

        --tuple-vector         # TODO

        --cpp (--no-cpp)       # preprocess the input with `cppÂ´ (no-cpp)
        --cpp-exe              # preprocessor executable (cpp)
        --cpp-args             # preprocess the input with `cppÂ´ passing arguments in between `"Â´ (no)

        --safety <LEVEL>       # safety checks (*0=none*, 1=event, 2=par)

        --tp-word <SIZE>       # sizeof a word in bytes (4)

        --version              # version of Ceu

        --os                   # TODO
        --os-luaifc            # TODO

        --timemachine          # TODO

        --reentrant            # TODO
]])
    os.exit(1)
end

-- C_CALLS
if OPTS.c_calls then
    local t = {}
    for v in string.gmatch(OPTS.c_calls, "([_%w]+)") do
        t[v] = true
    end
    OPTS.c_calls = t
end


-- INPUT
local inp
if OPTS.input == '-' then
    inp = io.stdin
else
    inp = assert(io.open(OPTS.input))
end
local source = inp:read'*a'

OPTS.source = source

-- PARSE
do
    
do
TP = {
    types = {}
}

function TP.id (tp)
    return tp.tt[1]
end
function TP.is_ext (tp, v1, v2)
    assert(v1, 'bug found')
    local _tp, at
    if v1=='@' or v2=='@' then
        at = TP.id(tp)=='@'
    end
    if v1=='_' or v2=='_' then
        _tp = string.sub(TP.id(tp),1,1) == '_'
    end
    return _tp or at
end

local function TT_copy (tt)
    local ret = {}
    for i=1, #tt do
        ret[i] = tt[i]
    end
    return ret
end

function TP.base (tp)
    return TP.new{tp.tt[1]}
end

function TP.pop (tp, v)
    if tp.tup then
        return tp, false
    end
    if v == nil then
        v = tp.tt[#tp.tt]
    end

    tp = TP.copy(tp)
    if tp.tt[#tp.tt] == v then
        tp.tt[#tp.tt] = nil
        if v == '[]' then
            tp.arr = nil
        end
        return tp, v
    else
        return tp, false
    end
end
function TP.push (tp, v)
    tp = TP.copy(tp)
    tp.tt[#tp.tt+1] = v
    return tp
end
function TP.check (tp, ...)
    if tp.tup then
        return false
    end

    local tt = tp.tt

    local E = { ... }
    local j = 0
    for i=0, #E-1 do
        local v = tt[#tt-j]
        local e = E[#E-i]
        local opt = false
        if string.sub(e,1,1) == '-' then
            e   = string.sub(e,2)
            opt = true
        end

        if v ~= e then
            if opt then
                j = j - 1
            else
                return false
            end
        end
        j = j + 1
    end
    return true
end

local __toc = { ['&&']='ptr', ['[]']='arr', ['&']='ref', ['?']='opt' }
function TP.opt2adt (tp)
    local tt = tp.tt
    assert(TP.check(tp,'?'), 'bug found')
    local ret = '_Option__'..tt[1]
    for i=2, #tt-1 do
        local p = tt[i]
        if type(p)=='table' then
            p = '[]'
        end
        ret = ret .. '__' .. __toc[p]
    end
    return ret
end

local __empty = {}
function TP.get (id)
    return TP.types[id] or __empty
end

local __tmod = {
    ['&&'] = { ['&&']=true,  ['[]']=true,  ['&']=true,  ['?']=true  },
    ['[]'] = { ['&&']=true,  ['[]']=false, ['&']=true,  ['?']=false },
    ['&']  = { ['&&']=false, ['[]']=false, ['&']=false, ['?']=true  },
    ['?']  = { ['&&']=false, ['[]']=true,  ['&']=false, ['?']=false },
}

function TP.new (me, dont_generate)
    if me.tag ~= 'TupleType' then
        -- Save actual type in "tt", because of
        -- array [N] which has to be in me[i] to be tracked.
        -- id, (*, [], &, ?)^0
        if not me.tt then
            me.tt = { unpack(me) }
        end

        -- me.arr = []|table
        -- me.tt[i] = '[]'
        for i=2, #me.tt do
            local v = me.tt[i]
            if v=='[]' or type(v)=='table' then
                me.tt[i] = '[]'
                me.arr = v
            end
        end

        -- validate type modifiers
        if AST and AST.par(me, 'Dcl_var') then
            local last = me.tt[2]
            if last then
                for i=3, #me.tt do
                    local cur = me.tt[i]
                    ASR(__tmod[last][cur], me,
                        'invalid type modifier : `'..last..cur..'Â´')
                    last = cur
                end
            end
        end

        -- TODO: refusing multiple '?' inside
        -- TODO: refusing multiple '[]' inside
        local arr = false
        for i=2, #me do
            local v = me[i]
            if v == '?' then
                --ASR(i==#me, me, 'not implemented : `?Â´ must be last modifier')
            elseif v=='[]' or type(v)=='table' then
                ASR(not arr, me, 'not implemented : multiple `[]Â´')
                    -- me[1] will contain the only []
                arr = true
            end
        end

        -- set from outside (see "types" above and Dcl_nat in env.lua)
        me.prim  = false     -- if primitive
        me.num   = false     -- if numeric
        me.len   = nil       -- sizeof type
        me.plain = false     -- if plain type (no pointers inside it)
        me.hold  = true      -- holds by default

-- TODO: remove?
        local tp_id = TP.id(me)
        if ENV and TP.is_ext(me,'_','@') and (not ENV.c[tp_id]) then
            ENV.c[tp_id] = { tag='type', id=tp_id, len=nil, mod=nil }
        end

    else
        AST.asr(me, 'TupleType')
        me.arr = false

        me.tup = {}
        for i, t in ipairs(me) do
            local hold, tp, _ = unpack(t)
            tp.hold = hold

            if TP.check(tp,'void','-&') then
                ASR(#me==1, me, 'type cannot be `voidÂ´', [[
    A `voidÂ´ only makes sense if it is the single argument.
]])
                me[1] = nil     -- empty tuple
                break
            end

            -- TODO: workaround: error when generating nested ADTs
            if ENV.adts[TP.id(tp)] then
                dont_generate = true
            end

            me.tup[#me.tup+1] = tp
        end

        if not (dont_generate or AST.par(me,'Dcl_fun')) then
            TP.types[TP.toc(me)] = me     -- dump typedefs
        end
    end
    return me
end

OPTS.tp_word = assert(tonumber(OPTS.tp_word),
    'missing `--tp-wordÂ´ parameter')

-- primitive / numeric / len
local types = {
    void  = { true, false, 0 },
    char  = { true, true, 1 },
    byte  = { true, true, 1 },
    bool  = { true, true, 1 },
    word  = { true, true, OPTS.tp_word },
    uint  = { true, true, OPTS.tp_word },
    int   = { true, true, OPTS.tp_word },
    u64   = { true, true, 8 },
    s64   = { true, true, 8 },
    u32   = { true, true, 4 },
    s32   = { true, true, 4 },
    u16   = { true, true, 2 },
    s16   = { true, true, 2 },
    u8    = { true, true, 1 },
    s8    = { true, true, 1 },
    float = { true, true, OPTS.tp_word },
    f32   = { true, true, 4 },
    f64   = { true, true, 8 },

    pointer   = { false, false, OPTS.tp_word },
    tceu_ncls = { false, false, true }, -- len set in "env.lua"
    tceu_nlbl = { false, false, true }, -- len set in "labels.lua"
}
for id, t in pairs(types) do
    TP.types[id] = TP.new{ id }
    TP.types[id].prim = t[1]
    TP.types[id].num  = t[2]
    TP.types[id].len  = t[3]
end

function TP.n2bytes (n)
    if n < 2^8 then
        return 1
    elseif n < 2^16 then
        return 2
    elseif n < 2^32 then
        return 4
    end
    error'out of bounds'
end

function TP.copy (tp)
    local ret = {}
    for k, v in pairs(tp) do
        if k == 'tt' then
            ret.tt = TT_copy(tp.tt)
        else
            ret[k] = v
        end
    end
    return ret
end

function TP.toc (tp, t)
    t = t or {}
    if t.vector_base and TP.check(tp,'[]','-&') then
        return TP.toc(TP.pop(TP.pop(tp,'&'),'[]'))..'*'
    end

    if tp.tup then
        local t = { 'tceu' }
        for _, v in ipairs(tp.tup) do
            t[#t+1] = TP.toc(v)
            if v.hold then
                t[#t] = t[#t] .. 'h'
            end
        end
        return string.gsub(table.concat(t,'__'),'%*','_')
    end

    local ret = ''
    for i=#tp.tt, 2, -1 do
        if tp.tt[i] == '?' then
            return 'CEU_'..TP.opt2adt(tp)..ret
        end

        local v
        tp, v = TP.pop(tp)
        if v == '[]' then
            return 'tceu_vector'..ret       -- [], return now
        elseif v=='&&' or v=='&' then
            ret = '*'..ret
        else
            error 'bug found'
        end
    end

    local id = TP.id(tp)

    ret = id..ret

    if ENV.clss[id] or ENV.adts[id] then
        ret = 'CEU_'..ret
    end

    ret = string.gsub(ret,'^_', '')
    return ret
end

function TP.tostr (tp)
    if tp.tup then
        local t = {}
        for _, v in ipairs(tp.tup) do
            t[#t+1] = TP.tostr(v)
        end
        return '('..table.concat(t,',')..')'
    end

    return table.concat(tp.tt)
end

function TP.isFloat (tp, pop)
    local tt = (pop and TP.pop(tp, pop)) or tp.tt
    local id = unpack(tt)
    return #tt==1 and (id=='float' or id=='f32' or id=='f64')
end

function TP.isNumeric (tp, pop)
    tp = (pop and TP.pop(tp, pop)) or tp
    local id = TP.id(tp)
    return TP.check(tp,id) and (TP.get(id).num or TP.is_ext(tp,'_'))
            or TP.is_ext(tp,'@')
end

function TP.t2tup (t)
    local tup = {}
    for _, v in ipairs(t) do
        tup[#tup+1] = v.tp
        assert(v.tp)
    end
    return tup
end

local function __err (tp1, tp2)
    return 'types mismatch (`'..TP.tostr(tp1)..'Â´ <= `'..TP.tostr(tp2)..'Â´)'
end
local function __norefs (tt)
    tt = TT_copy(tt)
    for i=#tt, 1, -1 do
        if tt[i] == '&' then
            table.remove(tt, i)
        end
    end
    return tt
end
function TP.contains (tp1, tp2, t)
    t = t or {}

    if tp1.tup or tp2.tup then
        if tp1.tup and tp2.tup then
            if #tp1.tup == #tp2.tup then
                for i=1, #tp1.tup do
                    local t1 = tp1.tup[i]
                    local t2 = tp2.tup[i]
                    local ok, msg = TP.contains(t1,t2,t)
                    if not ok then
                        return false, 'wrong argument #'..i..' : '..msg
                    end
                end
                return true
            end
        end
        return false, 'arity mismatch'
    end

    -- original types (for error msgs)
    local TP1, TP2 = tp1, tp2
    --local tp1,ok  = TP.pop(tp1, '?')
    local tp1  = TP.copy(tp1)
    local tp2  = TP.copy(tp2)

    local id1  = TP.id(tp1)
    local id2  = TP.id(tp2)
    local cls1 = ENV.clss[id1]
    local cls2 = ENV.clss[id2]

    if t.option == true then
        tp1 = TP.pop(TP1, '?')
        --tp2 = TP.pop(TP2, '?')
    end

    -- TODO: required for external calls
    --       remove it!
    if TP.check(TP1,'?') and TP.check(TP2,'?') then
        -- overwrides tp2 above
        tp2 = TP.pop(TP2, '?')
    end

    tp1 = { tt=__norefs(tp1.tt) }
    tp2 = { tt=__norefs(tp2.tt) }

    -- BIG SWITCH --

    -- compatible classes
    if cls1 and cls2 and
        (not ((TP.check(tp1,'[]') or TP.check(tp2,'[]'))))
            -- arrays/pools are handled below
    then
        local ok = (id1==id2) or
                   (cls1.is_ifc and ENV.ifc_vs_cls_or_ifc(cls1,cls2))
        if ok then
            -- pointers
            if TP.check(tp1,'&&') or TP.check(tp2,'&&') then
                if not (TP.check(tp1,'&&') and TP.check(tp2,'&&')) then
                    return false, __err(TP1, TP2)
                end
                -- compatible pointers, check arity, "char" renaming trick
                local tp1, tp2 = TP.copy(tp1), TP.copy(tp2)
                tp1.tt[1], tp2.tt[1] = 'char', 'char'
                return TP.contains(tp1, tp2,t)
            -- non-pointers
            elseif TP.check(TP1,id1,'&') then
                return true
            else
                return false, __err(TP1, TP2)
            end
        else
            return false, __err(TP1, TP2)
        end

    -- vec& = vec
    -- vec  = []..
    elseif (not TP.is_ext(tp1,'_','@')) and (not TP.is_ext(tp2,'_','@')) and
           --(not (tp1.pre=='pool' or tp2.pre=='pool')) and
           (not (ENV.clss[id1] and TP.check(tp1,id1,'[]','-&') or
                 ENV.clss[id2] and TP.check(tp2,id2,'[]','-&'))) and -- TODO: TP.pre()
        (
            TP.check(TP1,'[]','&') and TP.check(tp2,'[]')
        or
            TP.check(TP1,'[]','-&','-?') and TP.check(tp2,'[]','..')
        )
    then
        local is_constr = TP.check(tp2,'[]','..')

        -- to == fr
        local ok = is_constr or (TP1.arr=='[]') or
                   (TP2.arr~='[]' and TP1.arr.sval==TP2.arr.sval)
        if not ok then
            return false, __err(TP1,TP2)..' : dimension mismatch'
        end

        tp2 = TP.pop(tp2,'..')
        return TP.contains(TP.pop(tp1,'[]'), TP.pop(tp2,'[]'),
                    {option=true,numeric=is_constr})
                                    -- OK: var char[] str = [int,int,int]
                                    -- NO: var char[]& str = &vec_int
--, {numeric=false} )

    -- same type
    elseif TP.tostr(tp1) == TP.tostr(tp2) then
        if TP.check(tp1,'[]') or TP.check(tp2,'[]') then
            assert(TP.check(tp1,'[]'), 'bug found')
            if TP.check(TP1,'&') then
                if TP1.arr == '[]' then
                    -- var X[]& = ...
                    return true
                elseif type(TP1.arr)=='table' and type(TP2.arr)=='table' then
                    assert(type(TP1.arr)=='table', 'bug found')
                    -- pool X[10]  arr
                    -- pool X[10]& ref = arr;
                    if TP1.arr[1] == TP2.arr[1] then
                        return true
                    else
                        return false, __err(TP1, TP2)
                    end
                else
                    return false, __err(TP1, TP2)
                end
            else
                return false, __err(TP1, TP2)   -- refuse x[]=y[]
            end
        else
            return true
        end

    -- numerical type
    elseif (t.numeric~=false) and TP.isNumeric(tp1) and TP.isNumeric(tp2) then
        return true

    -- external non-pointers: let "gcc" handle it
    elseif TP.is_ext(tp1,'_') and TP.check(tp1,id1) or
           TP.is_ext(tp2,'_') and TP.check(tp2,id2)
    then
        if id1 == id2 then
            if TP.check(tp2,id1) and TP.check(tp1,id2) then
                return true
            else
                return false, __err(TP1, TP2)
            end
        else
            return true
        end

    -- "any" type (calls, Lua scripts)
    elseif TP.is_ext(tp1,'@') or TP.is_ext(tp2,'@') then
        return true

    -- any pointer can be used with "null"
    elseif TP.check(tp1,'&&') and TP.check(tp2,'null','&&') or
           TP.check(tp2,'&&') and TP.check(tp1,'null','&&')
    then
        return true

    -- single-pointer casts
    elseif TP.check(tp1,id1,'&&') and TP.check(tp2,id2,'&&') then
        -- TODO: allows any cast to char* and void*
        --       is it correct?
        --       (I think "void*" should fail)
        if id1 == 'char' then
            local tp2 = TP.copy(tp2)
            tp2.tt[1] = 'char'
            return TP.contains(tp1, tp2, {numeric=false})
        elseif id1 == 'void' then
            local tp2 = TP.copy(tp2)
            tp2.tt[1] = 'void'
            return TP.contains(tp1, tp2, {numeric=false})

        -- both are external types: let "gcc" handle it
        elseif TP.is_ext(tp1,'_') or TP.is_ext(tp2,'_') then
            return true

        else
            return false, __err(tp1, tp2)
        end

    -- unused value in EmitExt for requests with errors
    -- [] vector constructors
    elseif TP.check(tp2,'any') then
        return true

    -- error
    else
        return false, __err(TP1, TP2)
    end
end

function TP.max (tp1, tp2)
    if TP.contains(tp1, tp2) then
        return tp1
    elseif TP.contains(tp2, tp1) then
        return tp2
    else
        return nil
    end
end

end

    
do
m = require 'lpeg'
m.setmaxstack(1000)

local LINE = 1
local FILE = OPTS.input
local patt

LINES = {
    i2l = {},
}

local line = m.Cmt('\n',
    function (s,i)
        for i=#LINES.i2l, i do
            LINES.i2l[i] = { FILE, LINE }
        end
        LINE = LINE + 1
        return true
    end )

local S = (m.S'\t\r ' + m.P'\\'*(1-m.P'\n')^0*'\n')
local SS = S^0

-- #line N "file" :: directive to set line/filename
local dir_lins = m.Cmt( m.P'#' *SS* m.P'line'^-1
                          *SS* m.C(m.R'09'^1)             -- line
                          *SS* ( m.P'"' * m.C((1-m.P'"')^0) * m.P'"'
                              + m.Cc(false) )            -- file
                          * (S + (m.P(1)-'\n'))^0 * '\n' -- \n
                 ,
    function (s,i, line, file)
        LINE = line
        FILE = file
        return true
    end )

patt = (line + dir_lins + 1)^0

-- pre-append extra line to match #
OPTS.source = '\n#line 1 "'..OPTS.input..'"\n'..OPTS.source

if OPTS.cpp or OPTS.cpp_args then
    local args = OPTS.cpp_args or ''
    if OPTS.timemachine then
        args = args .. ' -DCEU_TIMEMACHINE'
    end
    local orig = (OPTS.input=='-' and 'tmp.ceu')
                    or OPTS.input
    local base, name = string.match(orig, '(.*/)(.*)')
    if not base then
        base = ''
        name = orig
    end

    -- fin, fout, ferr
    local fout = base..'_ceu_cpp_'..name
    local ferr = fout..'.err'
    local fin  = fout..'.in'
    local f = assert( io.open(fin,'w') )
    f:write(OPTS.source)
    f:close()

    -- execute cpp
    local ret = os.execute(OPTS.cpp_exe..' -C -dD '..args..' '..fin
                            ..' > '..fout..' 2>'..ferr)
            -- "-C":  keep comments (because of nesting)
            -- "-dD": repeat #define's (because of macros used as C functions)
    os.remove(fin)
    assert(ret == 0 or ret == true, assert(io.open(ferr)):read'*a')
    os.remove(ferr)

    -- pre-append extra line to match #
    -- remove blank lines of #define's (because of "-dD")
    OPTS.source = '\n'..assert(io.open(fout)):read'*a'
    --OPTS.source = string.gsub(OPTS.source, '(#define[^\n]*)(\n)(\n)', '%1%3')
    os.remove(fout)
    --print(OPTS.source)
end

patt:match(OPTS.source..'\n')

-------------------------------------------------------------------------------

function DBG (...)
    local t = {}
    for i=1, select('#',...) do
        t[#t+1] = tostring( select(i,...) )
    end
    if #t == 0 then
        t = { [1]=debug.traceback() }
    end
    io.stderr:write(table.concat(t,'\t')..'\n')
end

function MAX (v1, v2)
    return (v1 > v2) and v1 or v2
end

function WRN (cond, ln, code, msg)
    if cond then
        return cond
    end

    if not tonumber(code) then
        code, msg, extra = '0000', code, msg
    end
    ln = (AST.isNode(ln) and ln.ln) or ln
    msg = 'WRN ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg

    if RUNTESTS_file and tonumber(code)>1100 then
        RUNTESTS_file:write([[
==============
]]..msg..[[

--------------
]]..T[1]..[[
--------------
]]..debug.traceback()..[[

==============
]])
    end

    DBG('WRN ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg)
    return cond
end
function ASR (cond, ln, code, msg, extra)
    if cond then
        return cond
    end

    if not tonumber(code) then
        code, msg, extra = '0000', code, msg
    end
    ln = (AST.isNode(ln) and ln.ln) or ln
    msg = 'ERR ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg
    if extra and OPTS.verbose then
        msg = msg..'\n'..extra
    end

    if RUNTESTS_file and tonumber(code)>1100 then
        RUNTESTS_file:write([[
==============
]]..msg..[[

--------------
]]..T[1]..[[
--------------
]]..debug.traceback()..[[
==============
]])
    end

    if RUNTESTS then
        return assert(false, msg)
                -- TODO: error(msg) ???
    else
        DBG(msg)
        os.exit(1)
    end
end

end

    
do
local P, C, V, S, Cc, Ct = m.P, m.C, m.V, m.S, m.Cc, m.Ct

local X = V'__SPACES'

local ERR_msg
local ERR_i
local LST_i

local I2TK

local f = function (s, i, tk)
    if tk == '' then
        tk = '<BOF>'
        LST_i = 1           -- restart parsing
        ERR_i = 0           -- ERR_i < 1st i
        ERR_msg = '?'
        I2TK = { [1]='<BOF>' }
    elseif i > LST_i then
        LST_i = i
        I2TK[i] = tk
    end
    return true
end
local K = function (patt, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    ERR_msg = '?'
    return #P(1) * m.Cmt(patt*key, f) * X
end
local CK = function (patt, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    ERR_msg = '?'
    return C(m.Cmt(patt*key, f))*X
end
local EK = function (tk, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    return K(P(tk)*key) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected `'..tk.."Â´"
            end
            return false
        end) * P(false)
end

local KEY = function (str)
    return K(str,true)
end
local EKEY = function (str)
    return EK(str,true)
end
local CKEY = function (str)
    return CK(str,true)
end

local _V2NAME = {
    __Exp = 'expression',
    --__StmtS = 'statement',
    --__StmtB = 'statement',
    --__LstStmt = 'statement',
    --__LstStmtB = 'statement',
    Ext = 'event',
    Var = 'variable/event',
    __ID_adt  = 'identifier',
    __ID_nat  = 'identifier',
    __ID_var  = 'identifier',
    __ID_ext  = 'identifier',
    __ID_cls  = 'identifier',
    Type = 'type',
    __ID_field = 'identifier',
    _Dcl_var = 'declaration',
    _Dcl_int = 'declaration',
    _Dcl_pool = 'declaration',
    __Dcl_nat  = 'declaration',
    _Dcl_nat   = 'declaration',
    Dcl_adt_tag = 'declaration',
    _TupleType_1 = 'type list',
    _TupleType_2 = 'param list',
    __adt_expitem = 'parameter',
}
for i=1, 13 do
    _V2NAME['__'..i] = 'expression'
end
local EV = function (rule)
    return V(rule) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. _V2NAME[rule]
            end
            return false
        end) * P(false)
end

local EM = function (msg,full)
    return m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = (full and '' or 'expected ') .. msg
                return false
            end
            return true
        end)
end

TYPES = P'bool' + 'byte' + 'char' + 'f32' + 'f64'
      + 'float' + 'int'  + 's16'  + 's32' + 's64'
      + 's8'    + 'u16'  + 'u32'  + 'u64' + 'u8'
      + 'uint'  + 'void' + 'word'

KEYS = P'nothing' + 'escape' + 'return' + 'break' + 'continue'
     + 'var' + 'pool' + 'event' + 'input' + 'output'
     + 'input/output' + 'output/input'
     + 'function'
     + 'class' + 'interface'
     + 'data' + 'tag'
     + 'native' + 'native/pre'
     + 'call' + 'call/rec'
     + 'await' + 'emit' + 'until' + 'FOREVER' + 'request'
     + 'spawn' + 'kill'
     + 'new' + 'traverse'
     + 'do' + 'end' + 'pre'
     + 'if' + 'then' + 'else' + 'else/if'
     + 'loop' + 'in' + 'every'
     + 'finalize'
     + 'par' + 'par/and' + 'par/or' + 'with'
     + 'watching'
     + 'pause/if'
     + 'async' + 'async/thread'
     + 'async/isr' + 'atomic'
     + 'or' + P'and' + 'not'
     + 'sizeof'
     + 'null'
     + 'global' + 'this' + 'outer'
     + 'true' + 'false'
     + P'@' * (
         P'const' + 'hold' + 'nohold' + 'plain' + 'pure' + 'rec' + 'safe'
       )
     + TYPES

KEYS = KEYS * -m.R('09','__','az','AZ','\127\255')

local Alpha    = m.R'az' + '_' + m.R'AZ'
local Alphanum = Alpha + m.R'09'
local ALPHANUM = m.R'AZ' + '_' + m.R'09'
local alphanum = m.R'az' + '_' + m.R'09'

NUM = CK(m.R'09'^1) / tonumber

GG = { [1] = CK'' * V'_Stmts' * P(-1)-- + EM'expected EOF')

    , Nothing = KEY'nothing'
    , _Escape = KEY'escape' * EV'__Exp'
    , Return  = KEY'return' * EV'__Exp'^-1
    , Break     = KEY'break'
    , _Continue = KEY'continue'

-- Declarations

    -- variables, organisms
    , _Dcl_var  = (V'__Dcl_var_org' + V'__Dcl_var_plain_set' + V'_Dcl_var_plain')
    , __Dcl_var_org = CKEY'var'  * EV'Type' * Cc(true)  * EV'__ID_var' *
                        ( Cc(false) * EKEY'with' * V'Dcl_constr' * EKEY'end'
                        + K'=' * V'_Var_constr' * (
                            EKEY'with' * V'Dcl_constr' * EKEY'end' +
                            Cc(false)
                          ) )
    , __Dcl_var_plain_set = CKEY'var'  * EV'Type' * Cc(false) * V'__dcl_var_set' 
                                * (K','*V'__dcl_var_set')^0
    , _Dcl_var_plain = CKEY'var'  * EV'Type' * Cc(false) * V'__dcl_var' *
                            (K','*V'__dcl_var')^0

    , _Var_constr = V'__ID_cls' * (EK'.'-'..') * EV'__ID_var' * EK'(' * EV'ExpList' * EK')'

    -- auxiliary
    , Dcl_constr = V'Block'
    , __dcl_var_set = EV'__ID_var' * (V'__Sets' + Cc(false)*Cc(false)*Cc(false))
    , __dcl_var     = EV'__ID_var' * Cc(false)*Cc(false)*Cc(false)

    -- pools
    , _Dcl_pool = CKEY'pool' * EV'Type' * EV'__dcl_var_set' * (K','*EV'__dcl_var_set')^0

    -- internal events
    , _Dcl_int  = CKEY'event' * (V'_TupleType_1'+EV'Type') *
                    EV'__ID_var' * (K','*EV'__ID_var')^0

    -- internal functions / interrupts
    , Dcl_fun = CKEY'function' * (CKEY'@rec'+Cc(false))
                               * EV'_TupleType_2' * EK'=>' * EV'Type'
                               * V'__ID_var'
    , _Dcl_fun_do = V'Dcl_fun' * V'__Do'

    -- external functions
    , __Dcl_ext_call = (CKEY'input'+CKEY'output')
                     * Cc(false)     -- spawn array
                     * (CKEY'@rec'+Cc(false))
                     * V'_TupleType_2' * K'=>' * EV'Type'
                     * EV'__ID_ext' * (K','*EV'__ID_ext')^0

    -- external requests/events
    , _Dcl_ext0 = V'__Dcl_ext_io' + V'__Dcl_ext_call' + V'__Dcl_ext_evt'
    , _Dcl_ext1 = V'_Dcl_ext0' * V'__Do'

    -- external events
    , __Dcl_ext_evt  = (CKEY'input'+CKEY'output')
                     * Cc(false)     -- spawn array
                     * Cc(false)     -- recursive
                     * (V'_TupleType_1'+EV'Type') * Cc(false)
                     * EV'__ID_ext' * (K','*EV'__ID_ext')^0

    -- external requests
    , __Dcl_ext_io   = (CKEY'input/output'+CKEY'output/input')
                     * ('['*(V'__Exp'+Cc(true))*EK']'+Cc(false))
                     * Cc(false)     -- recursive
                     * V'_TupleType_2' * K'=>' * EV'Type'
                     * EV'__ID_ext' * (K','*EV'__ID_ext')^0

    -- classes / interfaces
    , Dcl_cls  = KEY'class'     * Cc(false)
               * EV'__ID_cls'
               * EKEY'with' * V'_BlockI' * V'__Do'
    , _Dcl_ifc = KEY'interface' * Cc(true)
               * EV'__ID_cls'
               * EKEY'with' * V'_BlockI' * EKEY'end'
    , _BlockI = ( (EV'_Dcl_var'+V'_Dcl_int'+V'_Dcl_pool'+V'Dcl_fun'+V'_Dcl_imp')
                  * (EK';'*K';'^0)
               )^0
    , _Dcl_imp = KEY'interface' * EV'__ID_cls' * (K',' * EV'__ID_cls')^0

    -- data types
    , Dcl_adt = KEY'data' * EV'__ID_adt' * EKEY'with'
               *    (V'__Dcl_adt_struct' + V'__Dcl_adt_union')
               * EKEY'end'
    , __Dcl_adt_struct = Cc'struct' * (V'_Dcl_var_plain' * (EK';'*K';'^0))^1
    , __Dcl_adt_union  = Cc'union'  * V'Dcl_adt_tag' * (EKEY'or' * EV'Dcl_adt_tag')^0
    , Dcl_adt_tag    = KEY'tag' * EV'__ID_tag' * EKEY'with'
                      *   (V'_Dcl_var_plain' * (EK';'*K';'^0))^0
                      * EKEY'end'
                      + KEY'tag' * EV'__ID_tag' * (EK';'*K';'^0)

    -- C integration
    , _Dcl_nat = KEY'native' * (CKEY'@pure'+CKEY'@const'+CKEY'@nohold'+CK'@plain'+Cc(false))
                   * EV'__Dcl_nat' * (K',' * EV'__Dcl_nat')^0
    , __Dcl_nat = Cc'type' * V'__ID_nat' * K'=' * NUM
                + Cc'func' * V'__ID_nat' * '()' * Cc(false)
                + Cc'unk'  * V'__ID_nat'        * Cc(false)

    , Host    = (KEY'native/pre'*Cc(true) + KEY'native'*Cc(false))
                * (#EKEY'do')*'do' * --S' \n\t'^0 *
                    ( C(V'_C') + C((P(1)-(S'\t\n\r '*'end'*P';'^0*'\n'))^0) )
                *X* EKEY'end'

    -- deterministic annotations
    , Dcl_det  = KEY'@safe' * EV'__ID' * (
                    EKEY'with' * EV'__ID' * (K',' * EV'__ID')^0
                 )^-1
    , __ID     = V'__ID_nat' + V'__ID_ext' + V'Var'


-- Assignments

    , _Set  = (V'__Exp' + V'VarList') * V'__Sets'
    , __Sets = (CK'='+CK':=') * (
                Cc'block'      * V'__SetBlock'
              + Cc'await'      * V'Await'
              + Cc'emit-ext'   * (V'EmitExt' + K'('*V'EmitExt'*EK')')
              + Cc'adt-constr' * V'Adt_constr_root'
              + Cc'lua'        * V'_LuaExp'
              + Cc'do-org'     * V'_DoOrg'
              + Cc'spawn'      * V'Spawn'
              + Cc'thread'     * V'_Thread'
              + Cc'exp'        * V'__Exp'
              + Cc'__trav_loop' * V'_TraverseLoop'  -- before Rec
              + Cc'__trav_rec'  * V'_TraverseRec'   -- after Loop
              + EM'expression'
              )
    , __SetBlock = V'Do' + V'If' + V'_Loop' + V'_Every' + V'ParEver'

    -- adt-constr
    , Adt_constr_root = (CKEY'new'+Cc(false)) * V'Adt_constr_one'
    , Adt_constr_one  = V'Adt' * EK'(' * EV'_Adt_explist' * EK')'
    , Adt             = V'__ID_adt' * ((K'.'-'..')*V'__ID_tag' + Cc(false))
    , __adt_expitem   = (V'Adt_constr_one' + V'__Exp')
    , _Adt_explist    = ( V'__adt_expitem'*(K','*EV'__adt_expitem')^0 )^-1

    -- vector-constr
    , Vector_tup = (K'['-('['*P'='^0*'[')) * EV'ExpList' * EK']'
    , Vector_constr = V'Vector_tup' *
                        (K'..'*( V'Vector_tup'+V'__Exp'))^0

-- Function calls

    , CallStmt = V'__Exp'

-- Event handling

    -- internal/external await
    , Await    = KEY'await' * V'__awaits'
                    * (KEY'until'*EV'__Exp' + Cc(false))
    , AwaitN   = KEY'await' * KEY'FOREVER'
    , __awaits = Cc(false) * (V'WCLOCKK'+V'WCLOCKE')  -- false,   wclock
               + (EV'Ext'+EV'__Exp') * Cc(false)      -- ext/int/org, false

    -- internal/external emit/call/request
    -- TODO: emit/await, move from "false"=>"_WCLOCK"
    , EmitExt  = (CKEY'call/rec'+CKEY'call'+CKEY'emit'+CKEY'request')
               * ( Cc(false) * (V'WCLOCKK'+V'WCLOCKE')
                 + EV'Ext' * V'__emit_ps' )
    , EmitInt  = CKEY'emit' * EV'__Exp' * V'__emit_ps'
    , __emit_ps = ( K'=>' * (V'__Exp' + K'(' * V'ExpList' * EK')')
                +   Cc(false) )

-- Organism instantiation

    -- do organism
    , _DoOrg = KEY'do' * EV'__ID_cls'
             * (V'_Spawn_constr' + Cc(false))
             * (EKEY'with'*V'Dcl_constr'* EKEY'end' + Cc(false))

    -- spawn / kill
    , _SpawnAnon = KEY'spawn' * EV'__Do'
    , Spawn = KEY'spawn' * EV'__ID_cls'
            * (V'_Spawn_constr' + Cc(false))
            * (KEY'in'*EV'__Exp' + Cc(false))
            * (EKEY'with'*V'Dcl_constr'* EKEY'end' + Cc(false))
    , _Spawn_constr = (K'.'-'..') * EV'__ID_var' * EK'(' * EV'ExpList' * EK')'

    , Kill  = KEY'kill' * EV'__Exp' * (EK'=>'*EV'__Exp' + Cc(false))

-- Flow control

    -- explicit block
    , Do    = V'__Do'
    , __Do  = KEY'do' * V'Block' * KEY'end'
    , Block = V'_Stmts'

    -- global (top level) execution
    , _DoPre = KEY'pre' * V'__Do'

    -- conditional
    , If = KEY'if' * EV'__Exp' * EKEY'then' *
            V'Block' *
           (KEY'else/if' * EV'__Exp' * EKEY'then' *
            V'Block')^0 *
           (KEY'else' *
            V'Block' + Cc(false)) *
           EKEY'end'-- - V'_Continue'

    -- loops
    , _Loop   = KEY'loop' * ('/'*EV'__Exp' + Cc(false)) *
                    (V'Var' * (EKEY'in'*EV'__Exp' + Cc(false))
                    + Cc(false)*Cc(false)) *
                V'__Do'
    , _Every  = KEY'every' * ( (EV'Var'+V'VarList') * EKEY'in'
                            + Cc(false) )
              * V'__awaits'
              * V'__Do'

    -- traverse
    , _TraverseLoop = KEY'traverse' * V'Var' * EKEY'in' * (
                        Cc'number' * (K'['*(V'__Exp'+Cc'[]')*EK']')
                      +
                        Cc'adt'    * EV'__Exp'
                    )
                    * (KEY'with'*V'_BlockI' + Cc(false))
                    * V'__Do'
    , _TraverseRec  = KEY'traverse' * ('/'*V'NUMBER'+Cc(false)) * EV'__Exp'
                    * (KEY'with'*V'Block'*EKEY'end' + Cc(false))

        --[[
        loop/N i in <e-num> do
            ...
        end
        loop (T*)i in <e-pool-org> do
            ...
        end
        loop i in <e-rec-data> do
            ...
        end
        loop (a,b,c) in <e-evt> do
            ...
        end
            , _Iter   = KEY'loop' * K'('*EV'Type'*EK')'
                      *     V'__ID_var' * KEY'in' * EV'__Exp'
                      * V'__Do'
        ]]

    -- finalization
    , Finalize = KEY'finalize' * (V'_Set'*EK';'*K';'^0 + Cc(false))
               * EKEY'with' * EV'Finally' * EKEY'end'
    , Finally  = V'Block'

    -- parallel compositions
    , ParOr     = KEY'par/or' * EKEY'do' *
                      V'Block' * (EKEY'with' * V'Block')^1 *
                  EKEY'end'
    , ParAnd  = KEY'par/and' * EKEY'do' *
                    V'Block' * (EKEY'with' * V'Block')^1 *
                EKEY'end'
    , ParEver = KEY'par' * EKEY'do' *
                    V'Block' * (EKEY'with' * V'Block')^1 *
                EKEY'end'
    , _Watching = KEY'watching' * ( (EV'Var'+V'VarList') * EKEY'in'
                                  + Cc(false) )
                * V'__awaits'
                * V'__Do'


    -- pause
    , _Pause   = KEY'pause/if' * EV'__Exp' * V'__Do'

    -- asynchronous execution
    , Async   = KEY'async' * (-P'/thread'-'/isr') * (V'VarList'+Cc(false)) * V'__Do'
    , _Thread = KEY'async/thread' * (V'VarList'+Cc(false)) * V'__Do'
    , _Isr    = KEY'async/isr'    * EK'[' * EV'ExpList' * EK']' * (V'VarList'+Cc(false)) * V'__Do'
    , Atomic  = KEY'atomic' * V'__Do'

    -- C integration
    , RawStmt = K'{' * C(V'__raw') * EK'}'
    , RawExp  = K'{' * C(V'__raw') * EK'}'
    , __raw   = ((1-S'{}') + '{'*V'__raw'*'}')^0

    -- Lua integration
    -- Stmt/Exp differ only by the "return" and are re-unified in "adj.lua"
    , _LuaStmt = V'__lua'
    , _LuaExp  = Cc'return ' * V'__lua'

    , __lua    = K'[' * m.Cg(P'='^0,'lua') * '[' *
                ( V'__luaext' + C((P(1)-V'__luaext'-V'__luacmp')^1) )^0
                 * (V'__luacl'/function()end) *X
    , __luaext = K'@' * V'__Exp'
    , __luacl  = ']' * C(P'='^0) * EK']'
    , __luacmp = m.Cmt(V'__luacl' * m.Cb'lua',
                    function (s,i,a,b) return a == b end)

-- Identifiers

    , Ext     = V'__ID_ext'
    , Var     = V'__ID_var'
    , Nat     = V'__ID_nat'

    , __ID_var   = (-KEYS * CK(m.R'az'*Alphanum^0) + CK('_'*-Alphanum))
    , __ID_ext   = -KEYS * CK(m.R'AZ'*ALPHANUM^0)
    , __ID_cls   = -KEYS * CK(m.R'AZ'*Alphanum^0)
    , __ID_adt   = -KEYS * CK(m.R'AZ'*Alphanum^0)
    , __ID_tag   = -KEYS * CK(m.R'AZ'*ALPHANUM^0)
    , __ID_nat   = CK(  P'_' *Alphanum^1)
    , __ID_field = CK(Alpha * (Alphanum)^0)
    , __ID_type  = CK(TYPES) + V'__ID_nat' + V'__ID_cls' + V'__ID_adt'

-- Types

    , Type = V'__ID_type'               -- id (* + [k] + & + ?)^0
           * ( (CK'&&'-P'&'^3) + (CK'&'-'&&') + CK'?'
             + K'['*(V'__Exp'+Cc('[]'))*K']'
             )^0

-- Lists

    , VarList = ( K'(' * EV'Var' * (EK',' * EV'Var')^0 * EK')' )
    , ExpList = ( V'__Exp'*(K','*EV'__Exp')^0 )^-1

    -- (int, void*)
    , _TupleTypeItem_1 = Cc(false) * EV'Type' * Cc(false)
    , _TupleType_1 = K'(' * EV'_TupleTypeItem_1' * (EK','*V'_TupleTypeItem_1')^0 * EK')'

    -- (int v, nohold void* ptr)
    , _TupleTypeItem_2 = (CKEY'@hold'+Cc(false)) * EV'Type' * (EV'__ID_var'+Cc(false))
    , _TupleType_2 = K'(' * EV'_TupleTypeItem_2' * (EK','*V'_TupleTypeItem_2')^0 * EK')'

-- Wall-clock values

    , WCLOCKK = #NUM *
                (NUM * K'h'   + Cc(0)) *
                (NUM * K'min' + Cc(0)) *
                (NUM * K's'   + Cc(0)) *
                (NUM * K'ms'  + Cc(0)) *
                (NUM * K'us'  + Cc(0)) *
                (NUM * EM'<h,min,s,ms,us>')^-1 * (CK'_' + Cc(false))
    , WCLOCKE = K'(' * V'__Exp' * EK')' * (
                    CK'h' + CK'min' + CK's' + CK'ms' + CK'us'
                  + EM'<h,min,s,ms,us>'
              ) * (CK'_' + Cc(false))

-- Expressions

    , __Exp  = V'__0'
    , __0    = V'__1' * K'..' * EM('invalid constructor syntax',true) * -1
             + V'__1'
    , __1    = V'__2'  * (CKEY'or'  * EV'__2')^0
    , __2    = V'__3'  * (CKEY'and' * EV'__3')^0
    , __3    = V'__4'  * ( ( (CK'!='-'!==')+CK'=='+CK'<='+CK'>='
                           + (CK'<'-'<<')+(CK'>'-'>>')
                           ) * EV'__4')^0
    , __4    = V'__5'  * ((CK'|'-'||') * EV'__5')^0
    , __5    = V'__6'  * (CK'^' * EV'__6')^0
    , __6    = V'__7'  * (CK'&' * EV'__7')^0
    , __7    = V'__8'  * ((CK'>>'+CK'<<') * EV'__8')^0
    , __8    = V'__9'  * ((CK'+'+CK'-') * EV'__9')^0
    , __9    = V'__10' * ((CK'*'+(CK'/'-'//'-'/*')+CK'%') * EV'__10')^0
    , __10   = ( Cc(false) * (CKEY'not'+CK'-'+CK'+'+CK'~'+CK'*'+
                              (CK'&&'-P'&'^3) + (CK'&'-'&&') +
                              CK'$$' + (CK'$'-'$$')
                           + Cc'cast'*(K'('*V'__Cast'*K')')*#V'__Exp' )
               )^0 * V'__11'
    , __11   = V'__12' *
                  (
                      K'(' * Cc'call' * EV'ExpList' * EK')' *
                          ( KEY'finalize' * EKEY'with' * V'Finally' * EKEY'end'
                            + Cc(false)) +
                      K'[' * Cc'idx'  * EV'__Exp'    * EK']' +
                      (CK':' + (CK'.'-'..')) * EV'__ID_field' +
                      CK'?' + (CK'!'-'!=')
                  )^0
    , __12   = V'__Prim'

    , __Prim = K'(' * EV'__Exp' * EK')'
             + V'SIZEOF'
             + V'Var'     + V'Nat'
             + V'NULL'    + V'NUMBER' + V'STRING'
             + V'Global'  + V'This'   + V'Outer'
             + V'RawExp'  + V'Vector_constr'
             + CKEY'call'     * EV'__Exp'
             + CKEY'call/rec' * EV'__Exp'

    , __Cast = V'Type' + (CKEY'@nohold'+CK'@plain'+CK'@pure')

    , SIZEOF = KEY'sizeof' * EK'(' * (V'Type' + V'__Exp') * EK')'
    , NULL   = CKEY'null'     -- TODO: the idea is to get rid of this
    , STRING = CK( CK'"' * (P(1)-'"'-'\n')^0 * EK'"' )

    , NUMBER = CK( #m.R'09' * (m.R'09'+S'xX'+m.R'AF'+m.R'af'+(P'.'-'..')
                                      +(S'Ee'*'-')+S'Ee')^1 )
             + CK( "'" * (P(1)-"'")^0 * "'" )
             + KEY'false' / function() return 0 end
             + KEY'true'  / function() return 1 end

    , Global  = KEY'global'
    , This    = KEY'this' * Cc(false)
    , Outer   = KEY'outer'

---------
                -- "Ct" as a special case to avoid "too many captures" (HACK_1)
    , _Stmts  = Ct (( V'__StmtS' * (EK';'*K';'^0) +
                      V'__StmtB' * (K';'^0)
                   )^0
                 * ( V'__LstStmt' * (EK';'*K';'^0) +
                     V'__LstStmtB' * (K';'^0)
                   )^-1
                 * (V'Host'+V'_Dcl_fun_do')^0 )

    , __LstStmt  = V'_Escape' + V'Return' + V'Break' + V'_Continue' + V'AwaitN'
    , __LstStmtB = V'ParEver'
    , __StmtS    = V'Nothing'
                 + V'_Dcl_var'  + V'_Dcl_pool' + V'_Dcl_int'
                 + V'Dcl_fun' + V'_Dcl_ext0'
                 + V'_Dcl_nat'  + V'Dcl_det'
                 + V'_Set'
                 + V'Await' + V'EmitExt' + V'EmitInt'
                 + V'Spawn' + V'Kill'
                 + V'_TraverseRec'
                 + V'_DoOrg'
                 + V'RawStmt'

             + V'CallStmt' -- last
             --+ EM'statement'-- (missing `_Â´?)'
             + EM'statement (usually a missing `varÂ´ or C prefix `_Â´)'

    , __StmtB = V'_Dcl_fun_do' + V'_Dcl_ext1'
              + V'_Dcl_ifc'  + V'Dcl_cls' + V'Dcl_adt'
              + V'Host'
              + V'Do'    + V'If'
              + V'_Loop' + V'_Every' + V'_TraverseLoop'
              + V'_SpawnAnon'
              + V'Finalize'
              + V'ParOr' + V'ParAnd' + V'_Watching'
              + V'_Pause'
              + V'Async' + V'_Thread' + V'_Isr' + V'Atomic'
              + V'_DoPre'
              + V'_LuaStmt'

    --, _C = '/******/' * (P(1)-'/******/')^0 * '/******/'
    , _C      = m.Cg(V'_CSEP','mark') *
                    (P(1)-V'_CEND')^0 *
                V'_CEND'
    , _CSEP = '/***' * (1-P'***/')^0 * '***/'
    , _CEND = m.Cmt(C(V'_CSEP') * m.Cb'mark',
                    function (s,i,a,b) return a == b end)

    , __SPACES = (('\n' * (V'__comm'+S'\t\n\r ')^0 *
                    '#' * (P(1)-'\n')^0)
                + ('//' * (P(1)-'\n')^0)
                + S'\t\n\r '
                + V'__comm'
                )^0

    , __comm    = '/' * m.Cg(P'*'^1,'comm') * (P(1)-V'__commcmp')^0 * 
                    V'__commcl'
                    / function () end
    , __commcl  = C(P'*'^1) * '/'
    , __commcmp = m.Cmt(V'__commcl' * m.Cb'comm',
                    function (s,i,a,b) return a == b end)

}

function err ()
    local x = (ERR_i<LST_i) and 'before' or 'after'
--DBG(LST_i, ERR_i, ERR_msg, _I2L[LST_i], I2TK[LST_i])
    local file, line = unpack(LINES.i2l[LST_i])
    return 'ERR : '..file..
              ' : line '..line..
              ' : '..x..' `'..(I2TK[LST_i] or '?').."Â´"..
              ' : '..ERR_msg
end

if RUNTESTS then
    assert(m.P(GG):match(OPTS.source), err())
else
    if not m.P(GG):match(OPTS.source) then
             -- TODO: match only in ast.lua?
        DBG(err())
        os.exit(1)
    end
end

end

    
do
AST = {
    root = nil,
}

local MT = {}

local STACK = {}

function AST.isNode (node)
    return (getmetatable(node) == MT) and node.tag
end

AST.tag2id = {
    EmitInt = 'emit',
    Spawn   = 'spawn',
    Kill    = 'kill',
    Await   = 'await',
    AwaitN  = 'await',
    Async   = 'async',
    Thread  = 'async/thread',
    ParOr   = 'par/or',
    ParAnd  = 'par/and',
    ParEver = 'par',
    Loop    = 'loop',
    Dcl_cls = 'class',
    Set     = 'assignment',
}

function AST.isParent (n1, n2)
    return n1 == n2
        or n2.__par and AST.isParent(n1, n2.__par)
end

local _N = 0
function AST.node (tag, ln, ...)
    local me
    if tag == '_Stmts' then
        -- "Ct" as a special case to avoid "too many captures" (HACK_1)
        tag = 'Stmts'
        me = setmetatable((...), MT)
    else
        me = setmetatable({ ... }, MT)
    end
    me.n = _N
    --me.xxx = debug.traceback()
    _N = _N + 1
    me.ln  = ln
    --me.ln[2] = me.n
    me.tag = tag
    return me
end

function AST.copy (node, ln)
    if not AST.isNode(node) then
        return node
    end

    local ret = setmetatable({}, MT)
    local N = _N
    _N = _N + 1

    for k, v in pairs(node) do
        if type(k) ~= 'number' then
            ret[k] = v
        else
            ret[k] = AST.copy(v, ln)
            if AST.isNode(v) then
                ret[k].ln = ln or ret[k].ln
            end
        end
    end
    ret.n = N

    return ret
end

function AST.get (me, tag, ...)
    local idx, tag2 = ...

    if not (AST.isNode(me) and (me.tag==tag or tag=='')) then
        return nil, tag, ((AST.isNode(me) and me.tag) or 'none')
    end

    if idx then
        return AST.get(me[idx], tag2, select(3,...))
    else
        return me
    end
end

function AST.asr (me, tag, ...)
    local ret, tag1, tag2 = AST.get(me, tag, ...)
    if not ret then
        DBG(debug.traceback())
        error('bug (expected: '..tag1..' | found: '..tag2..')')
    end
    return ret
end

function AST.pred_async (me)
    local tag = me.tag
    return tag=='Async' or tag=='Thread'
end
function AST.pred_par (me)
    local tag = me.tag
    return tag=='ParOr' or tag=='ParAnd' or tag=='ParEver'
end
function AST.pred_aborts (me)
    local tag = me.tag
    return tag=='ParOr' or tag=='SetBlock' or tag=='Loop'
end
function AST.pred_true (me) return true end

function AST.par (me, pred)
    if type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    if not me.__par then
        return nil
    elseif pred(me.__par) then
        return me.__par
    else
        return AST.par(me.__par, pred)
    end
end

function AST.child (me, pred)
    if type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    if pred(me) then
        return me
    end
    for i, sub in ipairs(me) do
        if AST.isNode(sub) then
            local child = AST.child(sub,pred)
            if child then
                return child
            end
        end
    end
end

function AST.iter (pred, inc)
    if pred == nil then
        pred = AST.pred_true
    elseif type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    local from = (inc and 1) or #STACK
    local to   = (inc and #STACK) or 1
    local step = (inc and 1) or -1
    local i = from
    return function ()
        for j=i, to, step do
            local stmt = STACK[j]
            if pred(stmt) then
                i = j+step
                return stmt
            end
        end
    end
end

function AST.dump (me, spc, lvl)
    if lvl and lvl==0 then
        return
    end
    spc = spc or 0
    local ks = ''
--[[
    for k, v in pairs(me) do
        if type(k)~='number' then
            v = string.gsub(string.sub(tostring(v),1,8),'\n','\\n')
            ks = ks.. k..'='..v..','
        end
    end
]]
    --local t=0; for _ in pairs(me.aw.t) do t=t+1 end
    --ks = 'n='..(me.aw.n or '?')..',t='..t..',ever='..(me.aw.forever_ and 1 or 0)
    --ks = table.concat(me.trails,'-')
--
if me.ana and me.ana.pre and me.ana.pos then
    local f = function(v)
                return type(v)=='table'
                            and (type(v[1])=='table' and v[1].id or v[1])
                    or tostring(v)
              end
    local t = {}
    for k in pairs(me.ana.pre) do t[#t+1]=f(k) end
    ks = '['..table.concat(t,',')..']'
    local t = {}
    for k in pairs(me.ana.pos) do t[#t+1]=f(k) end
    ks = ks..'['..table.concat(t,',')..']'
end
--[[
]]
--
    --ks = me.ns.trails..' / '..tostring(me.needs_clr)
    DBG(string.rep(' ',spc)..me.tag..
--[[
        '')
]]
        ' (ln='..me.ln[2]..' n='..me.n..
                           --' d='..(me.__depth or 0)..
                           --' p='..(me.__par and me.__par.n or '')..
                           ') '..ks)
--DBG'---'
--DBG(me.xxx)
--DBG'---'
    for i, sub in ipairs(me) do
        if AST.isNode(sub) then
            AST.dump(sub, spc+2, lvl and lvl-1)
        else
            DBG(string.rep(' ',spc+2) .. '['..tostring(sub)..']')
        end
    end
end

local function FF (F, str)
    local f = F[str]
    if type(f) == 'string' then
        return FF(F, f)
    end
    assert(f==nil or type(f)=='function')
    return f
end

local function visit_aux (me, F)
    local _me = me
    me.__par   = STACK[#STACK]
    me.__depth = (me.__par and me.__par.__depth+1) or 1

    local pre, mid, pos = FF(F,me.tag..'_pre'), FF(F,me.tag), FF(F,me.tag..'_pos')
    local bef, aft = FF(F,me.tag..'_bef'), FF(F,me.tag..'_aft')

    if F.Node_pre then
        me = F.Node_pre(me) or me
        if me ~= _me then
            --DBG('Node_pre', me.tag, me)
            return visit_aux(me, F)
        end
    end
    if pre then
        me = pre(me) or me
        if me ~= _me then
            --DBG('XXXX_pre', me.tag, me, _me.tag, _me)
            return visit_aux(me, F)
        end
    end

    STACK[#STACK+1] = me

    for i, sub in ipairs(me) do
        if bef then assert(bef(me, sub, i)==nil) end
        if AST.isNode(sub) then
            sub.__idx = i
            sub = visit_aux(sub, F)
            me[i] = sub
        end
        if aft then assert(aft(me, sub, i)==nil) end
    end

    if mid then
        assert(mid(me) == nil, me.tag)
    end
    if F.Node then
        assert(F.Node(me) == nil)
    end

    STACK[#STACK] = nil

    if pos then
        me = pos(me) or me
        if AST.isNode(me) then
            me.__par = STACK[#STACK]
            me.__depth = (me.__par and me.__par.__depth+1) or 0
        end
    end
    if F.Node_pos then
        me = F.Node_pos(me) or me
        if AST.isNode(me) then
            me.__par = STACK[#STACK]
            me.__depth = (me.__par and me.__par.__depth+1) or 0
        end
    end

    return me
end
AST.visit_aux = visit_aux

function AST.visit (F, node)
    assert(AST)
    --STACK = {}
    return visit_aux(node or AST.root, F)
end

local function i2l (p)
    return LINES.i2l[p]
end

for tag, patt in pairs(GG) do
    if string.sub(tag,1,2) ~= '__' then
        GG[tag] = m.Cc(tag) * (m.Cp()/i2l) * patt / AST.node
    end
end

local function f (ln, v1, op, v2, v3, ...)
    --DBG('2',ln[2],v1,op,v2,v3,...)
    local ret
    if not op then
        ret = v1
    elseif v1=='call' or v1=='call/rec' then
        -- Prim call
        ASR(op.tag=='Op2_call', ln, 'invalid call')
        op[1] = v1  -- change modifier
        ret = op
    elseif v1 then
        -- Op2_*
        if op == 'call' then
            ret = f(ln, AST.node('Op2_'..op,ln,op,v1,v2,v3), ...)
        elseif op == '?' then
            ret = f(ln, AST.node('Op1_'..op,ln,op,v1) ,v2, v3, ...)
        elseif op == '!' then
            ret = f(ln, AST.node('Op1_'..op,ln,op,v1) ,v2, v3, ...)
        else
            ret = f(ln, AST.node('Op2_'..op,ln,op,v1,v2), v3, ...)
        end
    else
        -- Op1_*
        if op == 'cast' then
            -- consume the type
            ret = AST.node('Op1_'..op, ln, v2, f(ln,v3,...))
        else
            ret = AST.node('Op1_'..op, ln, op, f(ln,v2,v3,...))
        end
    end
    return ret
end

for i=1, 12 do
    local tag = '__'..i
    GG[tag] = (m.Cp()/i2l) * GG[tag] / f
end

AST.root = m.P(GG):match(OPTS.source)
AST.visit({})

end

    
do
local node = AST.node
local TRAVERSE_ALREADY_GENERATED = false

-- TODO: remove
MAIN = nil

local DO_PRE

F = {
-- 1, Root --------------------------------------------------

    ['1_pre'] = function (me)
        local spc, stmts = unpack(me)

        DO_PRE = node('Stmts', me.ln)
        table.insert(stmts, 1, DO_PRE)

        local BLK_IFC = node('Block', me.ln, stmts)
        local RET = BLK_IFC

        -- for OS: <par/or do [blk_ifc_body] with await OS_STOP; escape 1; end>
        if OPTS.os then
            RET = node('ParOr', me.ln,
                        AST.asr(RET, 'Block'),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('Await', me.ln,
                                    node('Ext',me.ln,'OS_STOP'),
                                    false,
                                    false),
                                node('_Escape', me.ln,
                                    node('NUMBER',me.ln,1)))))
        end

        --[[
        -- Prepare request loops to run in "par/or" with the STMT above:
        -- par/or do
        --      <RET>
        -- with
        --      par do
        --          every REQ1 do ... end
        --      with
        --          every REQ2 do ... end
        --      end
        -- end
        --]]
        do
            local ORIG = RET
            RET = node('Stmts', me.ln,
                    node('ParEver', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                RET)),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('XXX',me.ln)))))
                                -- XXX = ParEver or Stmts
            ADJ_REQS = {
                me   = RET,
                orig = ORIG,
                reqs = AST.asr(RET,'Stmts', 1,'ParEver', 2,'Block', 1,'Stmts', 1,'XXX')
            }
                --[[
                -- Use "ADJ_REQS" to hold the "par/or", which can be
                -- substituted by the original "stmts" if there are no requests
                -- in the program (avoiding the unnecessary "par/or->par").
                -- See also ['Root'].
                --]]
        end

        -- enclose the program with the "Main" class
        MAIN = node('Dcl_cls', me.ln, false,
                    'Main',
                    node('BlockI', me.ln,
                        node('Stmts', me.ln)),
                    node('Block', me.ln,        -- same structure of
                        node('Stmts', me.ln,    -- other classes
                            RET)))
        MAIN.blk_ifc  = BLK_IFC
        MAIN.blk_body = BLK_IFC

        -- [1] => ['Root']
        AST.root = node('Root', me.ln, MAIN)
        return AST.root
    end,

    Root = function (me)
        if #ADJ_REQS.reqs == 0 then
            -- no requests, substitute the "par/or" by the original "stmts"
            ADJ_REQS.me[1] = ADJ_REQS.orig
        elseif #ADJ_REQS.reqs == 1 then
            ADJ_REQS.reqs.tag = 'Stmts'
        else
            ADJ_REQS.reqs.tag = 'ParEver'
        end
    end,

-- Dcl_cls/_ifc --------------------------------------------------

    -- global do end

    _DoPre_pos = function (me)
        local cls = AST.iter'Dcl_cls'()
        AST.asr(me,'', 1,'Block', 1,'Stmts')
        DO_PRE[#DO_PRE+1] = me[1][1]
        return AST.node('Nothing', me.ln)
    end,

    Dcl_cls_pre = function (me)
        local is_ifc, id, blk_ifc, blk_body = unpack(me)
-- TODO
me.blk_body = me.blk_body or blk_body

        -- enclose the main block with <ret = do ... end>
        blk_body = node('Block', me.ln,
                    node('Stmts', me.ln,
                        node('Dcl_var', me.ln, 'var',
                            node('Type', me.ln, 'int'),
                            '_ret'),
                        node('SetBlock', me.ln,
                            blk_body,
                            node('Var', me.ln,'_ret'),
                            true))) -- true=cls-block
        me[4] = blk_body
    end,

    _Dcl_ifc = 'Dcl_cls',
    Dcl_cls = function (me)
        local is_ifc, id, blk_ifc, blk_body = unpack(me)
        local blk = node('Block', me.ln,
                         node('Stmts',me.ln,blk_ifc,blk_body))
        me.blk_ifc  = me.blk_ifc  or blk
        me.blk_body = me.blk_body or blk_body
        me.tag = 'Dcl_cls'  -- Dcl_ifc => Dcl_cls
        me[3]  = blk        -- both blocks 'ifc' and 'body'
        me[4]  = nil        -- remove 'body'

-- TODO
        if is_ifc then
            return
        end

        -- remove SetBlock if no escapes
        if id~='Main' and (not me.has_escape) then
            local setblock = AST.asr(blk_body,'Block', 1,'Stmts', 2,'SetBlock')
            blk_body[1] = node('Stmts', me.ln, setblock[1])
        end

        -- insert class pool for orphan spawn
        local stmts = AST.asr(me.blk_body,'Block', 1,'Stmts')
        if me.__ast_has_malloc then
            table.insert(stmts, 1,
                node('Dcl_pool', me.ln, 'pool',
                    node('Type', me.ln, '_TOP_POOL', '[]'),
                    '_top_pool'))
        end
    end,

-- Escape --------------------------------------------------

    _Escape_pos = function (me)
        local exp = unpack(me)

        local cls = AST.par(me, 'Dcl_cls')
        local setblk = AST.par(me, 'SetBlock')
        cls.has_escape = (setblk[3] == true);
        ASR(setblk and setblk.__depth>cls.__depth,
            me, 'invalid `escapeÂ´')

        local _,to = unpack(setblk)
        local to = AST.copy(to)    -- escape from multiple places
            to.ln = me.ln

        --[[
        --  a = do
        --      var int a;
        --      escape 1;   -- "set" block (outer)
        --  end
        --]]
        to.__ast_blk = setblk

        --[[
        --      a = do ...; escape 1; end
        -- becomes
        --      do ...; a=1; escape; end
        --]]

        local set = node('Set', me.ln, '=', 'exp', exp, to, fr)
        set.__adj_escape = true
        return node('Stmts', me.ln,
                    set,
                    node('Escape', me.ln))
    end,

-- Watching --------------------------------------------------

    _Watching_pre = function (me)
        --[[
        --      watching <v> in <EVT> do
        --          ...
        --      end
        -- becomes
        --      par/or do
        --          <v> = await <EVT>;  // strong abortion
        --      with
        --          ...                 // no chance to execute on <EVT>
        --      end
        --
        -- TODO: because the order is inverted, if the same error occurs in
        -- both sides, the message will point to "..." which appears after in
        -- the code
        --]]
        local to, e, dt, blk = unpack(me)

        local awt = node('Await', me.ln, e, dt, false)
        local set
        if to then
            set = node('_Set', me.ln, to, '=', 'await', awt)
        else
            set = awt
        end

        local ret = node('ParOr', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                set)),
                        blk)
        ret.__adj_watching = (e or dt)
        return ret
    end,

-- Every --------------------------------------------------

    _Every_pre = function (me)
        local to, e, dt, body = unpack(me)

        --[[
        --      every a=EXT do ... end
        -- becomes
        --      loop do a=await EXT; ... end
        --]]

        local awt = node('Await', me.ln, e, dt, false)
        awt.isEvery = true  -- refuses other "awaits"

        local set
        if to then
            set = node('_Set', me.ln, to, '=', 'await', awt)
        else
            set = awt
        end

        local ret = node('_Loop', me.ln, false, to, AST.copy(e or dt), body)
        AST.asr(body[1], 'Stmts')
        table.insert(body[1], 1, set)
        ret.isEvery = true  -- refuses other "awaits"
                            -- auto declares "to"
        return ret
    end,

-- Loop --------------------------------------------------

    This_pre = function (me)
        local in_rec = unpack(me)
        if AST.par(me,'Dcl_constr') or in_rec then
            return  -- inside constructor or already recognized as in_rec
        end

        -- "this" inside "loop/adt" should refer to outer class
        local cls = AST.par(me, 'Dcl_cls')
        if cls.__adj_out then
            return node('Op2_.', me.ln, '.',
                    node('This', me.ln, true),
                    '_out')
        end
    end,

    Outer_pre = function (me)
        local in_rec = unpack(me)
        if in_rec then
            return  -- already recognized as in_rec
        end

        -- "outer" inside "traverse" should refer to outer class
        local cls = AST.par(me, 'Dcl_cls')
        if cls.__adj_out then
            return node('Var', me.ln, '_out')
        end
    end,

    -- TODO: Traverse could use this
    _SpawnAnon_pre = function (me)
        -- all statements after myself
        local par_stmts = AST.asr(me.__par, 'Stmts')
        local cnt_stmts = { unpack(par_stmts, me.__idx+1) }
        for i=me.__idx, #par_stmts do
            par_stmts[i] = nil
        end

        local awaitN = node('AwaitN', me.ln)
        awaitN.__adj_no_not_reachable_warning = true

        local orig = AST.asr(me[1],'Block', 1,'Stmts')
        orig.__adj_is_spawnanon = true
        orig.ln = me.ln
        me[1][1] = node('Stmts', me.ln,
                    me[1][1],
                    awaitN)

        me.tag = 'SpawnAnon'
        local ret = node('ParOr', me.ln,
                        me[1],
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                unpack(cnt_stmts))))
        ret.__adj_no_should_terminate_warning = true
        return ret
    end,

    _TraverseLoop_pre = function (me)
        --[[
        --  ret = traverse <n> in <root> with
        --      or
        --  ret = traverse <n> in <[N]> with
        --
        --      <interface>
        --  do
        --      <body>
        --          traverse <exp>;
        --  end;
        --      ... becomes ...
        --  class Body with
        --      pool Body[?]&   bodies;
        --      var  Body*      parent;       // TODO: should be "Body*?" (opt)
        --      var  Outer&     out;
        --
        --      pool <root_t>[]* <n>;
        --        or
        --      var  int        <n>;
        --      <interface>
        --  do
        --      watching *this.parent do
        --          <body>
        --              traverse <exp>;
        --      end
        --      escape 0;
        --  end
        --
        --  do
        --      var Scope s;
        --      pool Body[?] bodies;
        --      var Body*? _body_;
        --      _body_ = spawn Body in _bodies with
        --          this._bodies = bodies;
        --          this._scope  = &s;      // watch my enclosing scope
        --          this.<n>     = <n>;
        --      end;
        --      if _body_? then
        --          ret = await *_body_!;
        --      else
        --          ret = _ceu_app->ret;
        --              // HACK_8: result of immediate spawn termination
        --              // TODO: what if spawn did fail? (ret=garbage?)
        --      end
        --  end
        --]]

        local to, root_tag, root, ifc, body, ret = unpack(me)
        local out = AST.par(me, 'Dcl_cls')

        local dcl_to        -- dcl of "to" control variable
        local root_constr   -- initial "to" value
        local root_pool     -- [] or [N]
        local dcl_pool      -- pool of Bodies/stack-frames

        if root_tag == 'adt' then
            dcl_to = node('_Dcl_pool', me.ln, 'pool',
                        node('Type', me.ln, 'TODO-ADT-TYPE', '[]','&&'),
                                        -- unknown (depends on "root")
                        to[1])

            -- This => Outer
            --  traverse x in this.xs
            --      becomes
            --  do T with
            --      this.xs = outer.xs
            --  end;
            root_constr = AST.copy(root)  -- avoid conflict with TMP_ITER below
            local _n = root_constr
            if _n.tag == 'Op1_&&' then
                _n = _n[2]
            end
            -- TODO: incomplete
            if _n.tag=='Op2_.' and _n[2].tag=='This' then
                _n[2].tag = 'Outer'
            end

            -- HACK_5: figure out root type and dimension
            root = node('_TMP_ITER', me.ln, AST.copy(root))
            root_pool = '[]'
            dcl_pool = node('Dcl_pool', me.ln, 'pool',
                        node('Type', me.ln, 'Body_'..me.n, '[]'),
                        '_pool_'..me.n)
        else
            assert(root_tag == 'number', 'bug found')
            dcl_to = node('Dcl_var', me.ln, 'var',
                        node('Type', me.ln, 'int'),
                        to[1])
            root_constr = AST.node('NUMBER', me.ln, '0')
            root_pool = root
            dcl_pool = node('Dcl_pool', me.ln, 'pool',
                        node('Type', me.ln, 'Body_'..me.n, root),
                        '_pool_'..me.n)
            root = node('Nothing', me.ln)
        end

        -- unpacked below
        ifc = ifc or node('Stmts',me.ln)

        local tp = node('Type', me.ln, 'TODO-ADT-TYPE', '[]','&&')
        local cls = node('Dcl_cls', me.ln, false, 'Body_'..me.n,
                        node('BlockI', me.ln,
                            node('Stmts', me.ln,
                                node('Dcl_pool', me.ln, 'pool',
                                    node('Type', me.ln, 'Body_'..me.n, root_pool,'&'),
                                    '_bodies'),
                                node('Dcl_var', me.ln, 'var',
                                    node('Type', me.ln, 'Scope', '&&'),
                                        -- TODO: should be opt type
                                    '_parent'),
                                dcl_to,
                                node('Dcl_var', me.ln, 'var',
                                    node('Type', me.ln, out[2], '&'),
                                    '_out'),
                                unpack(ifc))),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('_Watching', me.ln,
                                    false,
                                    node('Op1_*', me.ln, '*',
                                        node('Var', me.ln, '_parent')),
                                    false,
                                    node('Block', me.ln,
                                        node('Stmts', me.ln,
                                            body))),
                                node('_Escape', me.ln,
                                    node('NUMBER', me.ln, '0')))))
        cls.__adj_out = AST.par(me, 'Block')
        cls.is_traverse = true

        local spawn = node('Spawn', me.ln, 'Body_'..me.n,
                            false,
                            node('Var', me.ln, '_pool_'..me.n),
                            node('Dcl_constr', me.ln,
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                '_bodies'),
                                            '=', 'exp',
                                            node('Op1_&', me.ln, '&',
                                                node('Var', me.ln, '_pool_'..me.n))),
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                '_parent'),
                                            '=', 'exp',
                                            node('Op1_&&', me.ln, '&&',
                                                node('Var', me.ln, '_s'))),
                                                --node('This', me.ln, true))),
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                to[1]),
                                            '=', 'exp',
                                            root_constr)))))
--[[
    -- now set manually before "_pre"
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                '_out'),
                                            '=', 'exp',
                                            node('Outer', me.ln, true))
]]
        spawn.__adj_is_traverse_root = true -- see code.lua
        local doorg = F.__traverse_spawn_await(me, 'Body_'..me.n, spawn, ret)

        local cls_scope = node('Nothing', me.ln)
        if not TRAVERSE_ALREADY_GENERATED then
            TRAVERSE_ALREADY_GENERATED = true
            cls_scope = node('Dcl_cls', me.ln, false,
                            'Scope',
                            node('BlockI', me.ln,
                                node('Stmts', me.ln)),
                            node('Block', me.ln,        -- same structure of
                                node('Stmts', me.ln,    -- other classes
                                    node('AwaitN', me.ln))))
        end

        return node('Stmts', me.ln, cls_scope, root, cls, dcl_pool, doorg)
    end,

    --[[
    --  ret = traverse <exp> with
    --      <constr>
    --  end;
    --      ... becomes ...
    --  ret = do
    --      var Scope s;
    --      var Body*? _body_;
    --      _body_ = spawn Body in _bodies with
    --          this._bodies = outer._bodies;
    --          this._scope  = &s;   // watch my enclosing scope
    --          this.<n>     = <n>;
    --          <constr>
    --      end;
    --      if _body_? then
    --          var int v = await *_body_!;
    --          escape v;
    --      else
    --          escape _ceu_app->ret;
    --              // result of immediate spawn termination
    --              // TODO: what if spawn did fail? (ret=garbage?)
    --      end
    --  end
    --]]
    __traverse_spawn_await = function (me, cls_id, spawn, ret)
        local SET_AWAIT = node('Await', me.ln,
                            node('Op1_*', me.ln, '*',
                                node('Op1_!', me.ln, '!',
                                    node('Var', me.ln, '_body_'..me.n))),
                            false,
                            false)
        local SET_DEAD = node('Nothing', me.ln)
        if ret then
            SET_AWAIT = node('Stmts', me.ln,
                            node('Dcl_var', me.ln, 'var',
                                node('Type', me.ln, 'int'),
                                '_ret_'..me.n),
                            node('_Set', me.ln,
                                node('Var', me.ln, '_ret_'..me.n),
                                '=', 'await',
                                SET_AWAIT),
                            node('_Escape', me.ln,
                                node('Var', me.ln, '_ret_'..me.n)))
            SET_DEAD  = node('_Escape', me.ln,
                            node('RawExp', me.ln, '_ceu_app->ret'))
                                -- HACK_10: (see ceu_os.c)
                                -- restores return value from global
                                -- (in case spawn terminates immediately)
        end

        local blk = node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Dcl_var', me.ln, 'var',
                                node('Type', me.ln, 'Scope'),
                                '_s'),
                            node('Dcl_var', me.ln, 'var',
                                node('Type', me.ln, cls_id, '&&','?'),
                                '_body_'..me.n),
                            node('_Set', me.ln,
                                node('Var', me.ln, '_body_'..me.n),
                                '=', 'spawn',
                                spawn),
                            node('If', me.ln,
                                node('Op1_?', me.ln, '?',
                                    node('Var', me.ln, '_body_'..me.n)),
                                --node('Nothing', me.ln),
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        SET_AWAIT)),
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        SET_DEAD)))))
        if ret then
            return node('SetBlock', me.ln, blk, ret)
        else
            return blk
        end
    end,

    _TraverseRec_pre = function (me)
        local n, exp, constr, ret = unpack(me)

        -- unpacked below
        constr = constr or node('Block', me.ln,
                            node('Stmts', me.ln))
        constr = AST.asr(constr,'Block', 1,'Stmts')

        -- take n-th traverse above
        n = (n==false and 0) or (AST.asr(n,'NUMBER')[1])
        local it = AST.iter(
                    function (me)
                        return me.tag=='Dcl_cls' and me.__adj_out
                    end)
        local cls
        for i=0, n do
            cls = it()
            if not cls then
                break
            end
        end
        ASR(cls, me, 'missing enclosing `traverseÂ´ block')

        local dcl = AST.asr(cls,'Dcl_cls', 3,'BlockI', 1,'Stmts')[3]
        assert(dcl.tag=='Dcl_pool' or dcl.tag=='Dcl_var')
        local _,_, to_id = unpack(dcl)

        local cls_id = cls[2]

        local spawn = node('Spawn', me.ln, cls_id,
                            false,
                            node('Var', me.ln, '_bodies'),
                            node('Dcl_constr', me.ln,
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                '_bodies'),
                                            '=', 'exp',
                                            node('Op1_&', me.ln, '&',
                                                node('Op2_.', me.ln, '.',
                                                    node('Outer', me.ln, true),
                                                    '_bodies'))),
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                '_parent'),
                                            '=', 'exp',
                                            node('Op1_&&', me.ln, '&&',
                                                node('Var', me.ln, '_s'))),
                                                --node('Outer', me.ln, true))),
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                to_id),
                                            '=', 'exp',
                                            exp),
--[[
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                '_out'),
                                            '=', 'exp',
                                            node('Op2_.', me.ln, '.',
                                                node('Outer', me.ln, true),
                                                '_out')),
]]
                                        unpack(constr)))))
        spawn.__adj_is_traverse_rec = true  -- see code.lua

        return F.__traverse_spawn_await(me, cls_id, spawn, ret)
    end,

    _Loop_pre = function (me)
        local max, to, iter, body = unpack(me)
        to = to or (max and node('Var', me.ln, '__ceu_i'..'_'..me.n))
        local loop = node('Loop', me.ln, max, iter, to, body)
        loop.isEvery      = me.isEvery
        loop.isAwaitUntil = me.isAwaitUntil

        return node('Block', me.ln,
                node('Stmts', me.ln,
                    node('Stmts', me.ln),   -- to insert all pre-declarations
                    loop))
    end,

-- Continue --------------------------------------------------

    _Continue_pos = function (me)
        local _if  = AST.par(me, 'If')
        local loop = AST.par(me, 'Loop')
        ASR(_if and loop, me, 'invalid `continueÂ´')

        local _,_,_,body = unpack(loop)
        local _,_,_else  = unpack(_if)

        loop.hasContinue = true
        _if.hasContinue = true
        ASR( _else.tag=='Nothing'          and   -- no else
            me.__depth  == _if.__depth+3   and   -- If->Block->Stmts->Continue
             _if.__depth == body.__depth+2 , -- Block->Stmts->If
            me, 'invalid `continueÂ´')
        return AST.node('Nothing', me.ln)
    end,

    Loop_pos = function (me)
        local _,_,_,body = unpack(me)
        if not me.hasContinue then
            return
        end
        -- start from last to first continue
        local stmts = unpack(body)
        local N = #stmts
        local has = true
        while has do
            has = false
            for i=N, 1, -1 do
                local n = stmts[i]
                if n.hasContinue then
                    has = true
                    N = i-1
                    local _else = AST.node('Stmts', n.ln)
                    n[3] = AST.node('Block', me.ln, _else)
                    for j=i+1, #stmts do
                        _else[#_else+1] = stmts[j]
                        stmts[j] = nil
                    end
                end
            end
        end
    end,

-- If --------------------------------------------------

    -- "_pre" because of "continue"
    If_pre = function (me)
        if #me==3 and me[3] then
            return      -- has no "else/if" and has "else" clause
        end
        local ret = me[#me] or node('Nothing', me.ln)
        for i=#me-1, 1, -2 do
            local c, b = me[i-1], me[i]
            ret = node('If', c.ln, c, b, ret)
        end
        return ret
    end,

-- Thread ---------------------------------------------------------------------

    _Thread_pre = function (me)
        me.tag = 'Thread'
        local raw = node('RawStmt', me.ln, nil)    -- see code.lua
              raw.thread = me
        return node('Stmts', me.ln,
                    node('Finalize', me.ln,
                        false,
                        node('Finally', me.ln,
                            node('Block', me.ln,
                                node('Stmts', me.ln,raw)))),
                    me,
                    node('Async', me.ln, node('VarList', me.ln),
                                      node('Block', me.ln, node('Stmts', me.ln))))
                    --[[ HACK_2:
                    -- Include <async do end> after it to enforce terminating
                    -- from the main program.
                    --]]
    end,

    -- ISR: include "ceu_out_isr(id)"
    _Isr_pre = function (me)
        me.tag = 'Isr'

        AST.asr(me.__par,'Stmts')
        local nxt = me.__par[me.__idx+1]
        ASR(AST.isNode(nxt) and nxt.tag=='AwaitN', me.ln,
            '`async/isrÂ´ must be followed by `await FOREVERÂ´')

        local args, vars, blk = unpack(me)

        local f = 'ISR_'..string.gsub(tostring(me),'[: ]','_')
        local id = ASR(args[1], me.ln, 'missing ISR identifier')
        id = id[1]
        ASR(type(id)=='string', me, 'invalid ISR identifier')
        me[1] = id
        table.insert(me,2,f)
        -- me = { id, f, vars, blk }

        table.insert(args, 1, node('RawExp',me.ln,f))
        -- args = { f, ... }

        --[[
        -- _ceu_out_isr_attach(isr, ...)
        --      finalize with
        --          _ceu_out_isr_detach(isr, ...)
        --      end
        --]]
        return
            node('Stmts', me.ln,
                me,
                node('Dcl_det', me.ln, '_ceu_out_isr_attach'),
                node('Dcl_det', me.ln, '_ceu_out_isr_detach'),
                node('CallStmt', me.ln,
                    node('Op2_call', me.ln, 'call',
                        node('Nat', me.ln, '_ceu_out_isr_attach'),
                        args)),
                node('Finalize', me.ln,
                    false,
                    node('Finally', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('CallStmt', me.ln,
                                    node('Op2_call', me.ln, 'call',
                                        node('Nat', me.ln, '_ceu_out_isr_detach'),
                                        AST.copy(args))))))))
    end,

-- Spawn ------------------------------------------------------------

    -- implicit pool in enclosing class if no "in pool"
    Spawn = function (me)
        local id, c1, pool, c2 = unpack(me)
        if not pool then
            AST.par(me,'Dcl_cls').__ast_has_malloc = true
            pool = node('Var', me.ln, '_top_pool')
        end
        if not c2 then
            c2 = AST.node('Dcl_constr', me.ln,
                    AST.node('Block', me.ln,
                        AST.node('Stmts', me.ln)))
        end
        if c1 then
            --  spawn T.constr(...);
            --      becomes
            --  spawn T with
            --      this.constr(...);
            --      ...
            --  end;
            local f, exps = unpack(c1)
            table.insert(c2[1][1], 1,
                node('CallStmt', me.ln,
                    node('Op2_call', me.ln, 'call',
                        node('Op2_.', me.ln, '.',
                            node('This', me.ln),
                            f),
                        exps)))
        end

        -- remove c1
        me[2] = pool
        me[3] = c2
        me[4] = false
    end,

-- DoOrg ------------------------------------------------------------

    _DoOrg_pre = function (me, to)
        --[[
        --  x = do T ... (handled on _Set_pre)
        --
        --  do T with ... end;
        --
        --      becomes
        --
        --  do
        --      var T t with ... end;
        --      x = await t;
        --  end
        --]]
        local id_cls, c1, c2 = unpack(me);

        local awt = node('Await', me.ln,
                        node('Var', me.ln, '_org_'..me.n),
                        false,
                        false)
        if to then
            awt = node('_Set', me.ln, to, '=', 'await', awt)
        end

        if c1 then
            -- adjusts to what Dcl_var expects
            table.insert(c1, 1, id_cls)
        end

        local ret = node('Do', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('_Dcl_var', me.ln, 'var',
                                    node('Type', me.ln, id_cls),
                                    true,
                                    '_org_'..me.n,
                                    c1,
                                    c2),
                                awt)))
        ret.__adj_is_do_org = true
        return ret
    end,

-- BlockI ------------------------------------------------------------

    _BlockI_pre = function (me)
        return node('BlockI', me.ln,
                node('Stmts', me.ln,
                    unpack(me)))
    end,

    -- expand collapsed declarations inside Stmts
    BlockI_pos = function (me)
        local stmts = AST.asr(me,'', 1,'Stmts')
        local new = {}
        for _, dcl in ipairs(stmts) do
            if dcl.tag == 'Stmts' then
                for _, v in ipairs(dcl) do
                    new[#new+1] = v
                end
            else
                new[#new+1] = dcl
            end
        end
--[[
        if #new > #me then
            for i,v in ipairs(new) do
                me[i] = v
            end
        end
]]
        -- changes the node reference
        me[1] = node('Stmts', me.ln, unpack(new))
    end,

-- Dcl_fun, Dcl_ext --------------------------------------------------------

    _Dcl_ext1_pre = '_Dcl_fun_do_pre',
    _Dcl_fun_do_pre = function (me)
        local dcl, blk = unpack(me)
        dcl[#dcl+1] = blk           -- include body on DCL0
        return dcl
    end,

    _Dcl_ext0_pre = function (me)
        local dir, spw, rec, ins, out, id_evt, blk = unpack(me)
        local ret_value;
        if out and out[1]~='void' then
            ret_value = node('ANY', me.ln, out)
        end

        -- Type => TupleType
        if ins.tag == 'Type' then
            local id, any = unpack(ins)
            if id=='void' and (not any) then
                ins = node('TupleType', ins.ln)
            else
                ins = node('TupleType', ins.ln,
                            node('TupleTypeItem', ins.ln, false, ins, false))
            end
            me[4] = ins
        end

        if me[#me].tag == 'Block' then
            -- refuses id1,i2 + blk
            ASR(me[#me]==blk, me, 'same body for multiple declarations')
            -- removes blk from the list of ids
            me[#me] = nil
        else
            -- blk is actually another id_evt, keep #me
            blk = nil
        end

        local ids = { unpack(me,6) }  -- skip dir,spw,rec,ins,out

        local ret = {}
        for _, id_evt in ipairs(ids) do
            if dir=='input/output' or dir=='output/input' then
                --[[
                --      output/input (T1,...)=>T2 LINE;
                -- becomes
                --      input  (tceu_req,T1,...) LINE_REQUEST;
                --      input  tceu_req          LINE_CANCEL;
                --      output (tceu_req,u8,T2)  LINE_RETURN;
                --]]
                local d1, d2 = string.match(dir, '([^/]*)/(.*)')
                assert(out)
                assert(rec == false)
                local tp_req = node('Type', me.ln, 'int')

                local ins_req = node('TupleType', me.ln,
                                    node('TupleTypeItem', me.ln,
                                        false,AST.copy(tp_req),false),
                                    unpack(ins))                -- T1,...
                local ins_cancel = node('TupleType', me.ln,
                                    node('TupleTypeItem', me.ln,
                                        false,AST.copy(tp_req),false))
                local ins_ret = node('TupleType', me.ln,
                                    node('TupleTypeItem', me.ln,
                                        false,AST.copy(tp_req),false),
                                    node('TupleTypeItem', me.ln,
                                        false,node('Type',me.ln,'u8'),false),
                                    node('TupleTypeItem', me.ln,
                                        false, out, false))

                -- remove void argument
                if #ins==1 and ins[1][2][1]=='void' then
                    ins_req[#ins_req] = nil -- remove void argument
                end
                if #out==1 and out[1]=='void' then
                    ins_ret[#ins_ret] = nil -- remove void argument
                end

                ret[#ret+1] = node('Dcl_ext', me.ln, d1, false,
                                   ins_req, false, id_evt..'_REQUEST')
                ret[#ret+1] = node('Dcl_ext', me.ln, d1, false,
                                   ins_cancel, false, id_evt..'_CANCEL')
                ret[#ret+1] = node('Dcl_ext', me.ln, d2, false,
                                   ins_ret, false, id_evt..'_RETURN')
            else
                if out then
                    ret[#ret+1] = node('Dcl_fun',me.ln,dir,rec,ins,out,id_evt, blk)
                end
                ret[#ret+1] = node('Dcl_ext',me.ln,dir,rec,ins,out,id_evt)
            end
        end

        if blk and (dir=='input/output' or dir=='output/input') then
            --[[
            -- input/output (int max)=>char* LINE [10] do ... end
            --
            --      becomes
            --
            -- class Line with
            --     var _reqid id;
            --     var int max;
            -- do
            --     finalize with
            --         emit _LINE_return => (this.id,XX,null);
            --     end
            --     par/or do
            --         ...
            --     with
            --         var int v = await _LINE_cancel
            --                     until v == this.id;
            --     end
            -- end
            --]]
            local id_cls = string.sub(id_evt,1,1)..string.lower(string.sub(id_evt,2,-1))
            local tp_req = node('Type', me.ln, 'int')
            local id_req = '_req_'..me.n

            local ifc = {
                node('Dcl_var', me.ln, 'var', tp_req, id_req)
            }
            for _, t in ipairs(ins) do
                local mod, tp, id = unpack(t)
                local tp_id = unpack(tp)
                ASR(tp_id=='void' or id, me, 'missing parameter identifier')
                --id = '_'..id..'_'..me.n
                if id then
                    ifc[#ifc+1] = node('Dcl_var', me.ln, 'var', tp, id)
                end
            end

            local cls =
                node('Dcl_cls', me.ln, false, id_cls,
                    node('BlockI', me.ln,
                        node('Stmts', me.ln,
                            unpack(ifc))),
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Finalize', me.ln,
                                false,
                                node('Finally', me.ln,
                                    node('Block', me.ln,
                                        node('Stmts', me.ln,
                                            node('EmitExt', me.ln, 'emit',
                                                node('Ext', me.ln, id_evt..'_RETURN'),
                                                node('ExpList', me.ln,
                                                    node('Var', me.ln, id_req),
                                                    node('NUMBER', me.ln, 2),
                                                            -- TODO: err=2?
                                                    ret_value)))))),
                            node('ParOr', me.ln,
                                node('Block', me.ln,
                                    node('Stmts', me.ln, blk)),
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        node('Dcl_var', me.ln, 'var', tp_req, 'id_req'),
                                        node('_Set', me.ln,
                                            node('Var', me.ln, 'id_req'),
                                            '=', 'await',
                                            node('Await', me.ln,
                                                node('Ext', me.ln, id_evt..'_CANCEL'),
                                                false,
                                                node('Op2_==', me.ln, '==',
                                                    node('Var', me.ln, 'id_req'),
                                                    node('Op2_.', me.ln, '.',
                                                        node('This',me.ln),
                                                        id_req))),
                                            false)))))))
            cls.__ast_req = {id_evt=id_evt, id_req=id_req}
            ret[#ret+1] = cls

            --[[
            -- Include the request loop in parallel with the top level
            -- stmts:
            --
            -- do
            --     pool Line[10] _Lines;
            --     var tp_req id_req_;
            --     var tpN, idN_;
            --     every (id_req,idN) = _LINE_request do
            --         var Line*? new = spawn Line in _Lines with
            --             this.id_req = id_req_;
            --             this.idN    = idN_;
            --         end
            --         if not new? then
            --             emit _LINE_return => (id_req,err,0);
            --         end
            --     end
            -- end
            ]]

            local dcls = {
                --node('Dcl_var', me.ln, 'var', tp_req, id_req)
            }
            local vars = node('VarList', me.ln, node('Var',me.ln,id_req))
            local sets = {
                node('_Set', me.ln,
                    node('Op2_.', me.ln, '.', node('This',me.ln), id_req),
                    '=', 'exp',
                    node('Var', me.ln, id_req))
            }
            for _, t in ipairs(ins) do
                local mod, tp, id = unpack(t)
                ASR(TP.check({tt=tp},'void') or id, me,
                    'missing parameter identifier')
                if id then
                    local _id = '_'..id..'_'..me.n
                    --dcls[#dcls+1] = node('Dcl_var', me.ln, 'var', tp, _id)
                    vars[#vars+1] = node('Var', me.ln, _id)
                    sets[#sets+1] = node('_Set', me.ln,
                                        node('Op2_.', me.ln, '.',
                                            node('This',me.ln),
                                            id),
                                        '=', 'exp',
                                        node('Var', me.ln, _id))
                end
            end

            local reqs = ADJ_REQS.reqs
            reqs[#reqs+1] =
                node('Do', me.ln,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Dcl_pool', me.ln, 'pool',
                                node('Type', me.ln, id_cls, (spw or '[]')),
                                '_'..id_cls..'s'),
                            node('Stmts', me.ln, unpack(dcls)),
                            node('_Every', me.ln, vars,
                                node('Ext', me.ln, id_evt..'_REQUEST'),
                                false,
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        node('Dcl_var', me.ln, 'var',
                                            node('Type', me.ln, 'void', '&&','?'),
                                            'ok_'),
                                        node('_Set', me.ln,
                                            node('Var', me.ln, 'ok_'),
                                            '=', 'spawn',
                                            node('Spawn', me.ln, id_cls,
                                                false,
                                                node('Var', me.ln, '_'..id_cls..'s'),
                                                node('Dcl_constr', me.ln, unpack(sets)))),
                                        node('If', me.ln,
                                            node('Op1_not', me.ln, 'not',
                                                node('Op1_?', me.ln, '?',
                                                    node('Var', me.ln, 'ok_'))),
                                            node('Block', me.ln,
                                                node('EmitExt', me.ln, 'emit',
                                                    node('Ext', me.ln, id_evt..'_RETURN'),
                                                    node('ExpList', me.ln,
                                                        node('Var', me.ln, id_req),
                                                        node('NUMBER', me.ln, 3),
                                                                -- TODO: err=3?
                                                        ret_value))),
                                            false)))))))
        end

        return node('Stmts', me.ln, unpack(ret))
    end,

    Return_pre = function (me)
        local cls = AST.par(me, 'Dcl_cls')
        if cls and cls.__ast_req then
            --[[
            --      return ret;
            -- becomes
            --      emit RETURN => (this.id, 0, ret);
            --]]
        return node('EmitExt', me.ln, 'emit',
                node('Ext', me.ln, cls.__ast_req.id_evt..'_RETURN'),
                node('ExpList', me.ln,
                    node('Var', me.ln, cls.__ast_req.id_req),
                    node('NUMBER', me.ln, 0), -- no error
                    me[1])  -- return expression
               )
        end
    end,

-- Dcl_nat, Dcl_ext, Dcl_int, Dcl_pool, Dcl_var ---------------------

    _Dcl_nat_pre = function (me)
        local mod = unpack(me)
        local ret = {}
        local t = { unpack(me,2) }  -- skip "mod"

        for i=1, #t, 3 do   -- pure/const/false, type/func/var, id, len
            ret[#ret+1] = node('Dcl_nat', me.ln, mod, t[i], t[i+1], t[i+2])
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

    _Dcl_int_pre = function (me)
        local pre, tp = unpack(me)

        -- Type => TupleType
        if tp.tag == 'Type' then
            tp = node('TupleType', tp.ln,
                        node('TupleTypeItem', tp.ln, false, tp, false))
            me[2] = tp
        end

        local ret = {}
        local t = { unpack(me,3) }  -- skip "pre","tp"
        for i=1, #t do
            ret[#ret+1] = node('Dcl_int', me.ln, pre, tp, t[i])
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

    _Dcl_pool_pre = function (me)
        local pre, tp = unpack(me)
        local ret = {}
        local t = { unpack(me,3) }  -- skip "pre","tp"

        -- id, op, tag, exp
        for i=1, #t, 4 do
            ret[#ret+1] = node('Dcl_pool', me.ln, pre, AST.copy(tp), t[i])
            if t[i+1] then
                ret[#ret+1] = node('_Set', me.ln,
                                node('Var', me.ln, t[i]),  -- var
                                t[i+1],                 -- op
                                t[i+2],                 -- tag
                                t[i+3] )                -- exp    (fr)
            end
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

    -- "_pre" because of SetBlock assignment
    _Dcl_var_plain_pre = '_Dcl_var_pre',
    _Dcl_var_pre = function (me)
        local pre, tp, hasConstr = unpack(me)
        local ret = {}
        local t = { unpack(me,4) }  -- skip pre,tp,hasConstr

        if hasConstr then
            local _, _, _, id, c1, c2 = unpack(me)
            me.tag = 'Dcl_var'
            if not c2 then
                c2 = node('Dcl_constr', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln)))
            end
            if c1 then
                --  var T t = T.constr(...);
                --      becomes
                --  var T t with
                --      this.constr(...);
                --      ...
                --  end;
                local tp2, f, exps = unpack(c1)
                ASR(tp[1] == tp2, me, 'invalid constructor')
                table.insert(c2[1][1], 1,
                    node('CallStmt', me.ln,
                        node('Op2_call', me.ln, 'call',
                            node('Op2_.', me.ln, '.',
                                node('This', me.ln),
                                f),
                            exps)))
            end

            -- remove c1, hasConstr
            me[5] = c2
            me[6] = false
            table.remove(me, 3)
            return
        end

        -- id, op, tag, exp
        for i=1, #t, 4 do
            ret[#ret+1] = node('Dcl_var', me.ln, pre, AST.copy(tp), t[i])
            if t[i+1] then
                ret[#ret+1] = node('_Set', me.ln,
                                node('Var', me.ln, t[i]),  -- var
                                t[i+1],                 -- op
                                t[i+2],                 -- tag
                                t[i+3] )                -- exp    (fr)
            end
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

-- Tuples ---------------------

    _TupleTypeItem_2 = '_TupleTypeItem_1',
    _TupleTypeItem_1 = function (me)
        me.tag = 'TupleTypeItem'
    end,
    _TupleType_2 = '_TupleType_1',
    _TupleType_1 = function (me)
        me.tag = 'TupleType'
    end,

    --  <v> = await <E> until <CND>
    --      -- becomes --
    --  loop do
    --      <v> = await <E>;
    --      if <CND> then
    --          break;
    --      end
    --  end
    __await_until = function (me, stmt)
        local _, _, cnd = unpack(me)
        if cnd then
            me[3] = nil
            local ret = node('_Loop', me.ln, false, false, false,
                            node('Stmts', me.ln,
                                stmt,
                                node('If', me.ln, cnd,
                                    node('Break', me.ln),
                                    node('Nothing', me.ln))))
            ret.isAwaitUntil = true  -- see tmps/fins
            return ret
        else
            return nil
        end
    end,

    __await_opts = function (me, stmt)
        local e, dt, cnd, ok = unpack(me)

        -- TODO: ugly hack
        if ok then return end
        me[4] = true

        -- HACK_6: figure out if OPT-1 or OPT-2 or OPT-3:
        --      await <EVT>
        --      await <ADT>
        --      await <ORG>
        local var = e or dt     -- TODO: hacky
        local tst = node('_TMP_AWAIT', me.ln, var)

        local AWT_KILL = node('Await', me.ln,
                             node('Ext', me.ln, '_ok_killed', false, AST.copy(var)),
                             false,
                             false,
                             true)
        local SET_DEAD = node('Nothing', me.ln)
        if stmt.tag == 'Set' then
            local to = AST.asr(stmt,'Set', 4,'VarList', 1,'')
            AWT_KILL = node('_Set', me.ln,
                            AST.copy(to),
                            '=', 'await',
                            AWT_KILL)
            SET_DEAD = node('Set', me.ln, '=', 'exp',
                        node('Op1_cast', me.ln,
                            node('Type', me.ln, 'int'),
                            node('Op2_.', me.ln, '.',
                                node('Op1_*', me.ln, '*',
                                    node('Op1_cast', me.ln,
                                        node('Type', me.ln, '_tceu_org', '&&'),
                                        node('Op1_&&', me.ln, '&&',
                                            AST.copy(var)))),
                                'ret')),
                        AST.copy(to))
        end

        return
            node('Stmts', me.ln,
                -- HACK_6: figure out if OPT-1 or OPT-2 or OPT-3
                tst,  -- "var" needs to be parsed before OPT-[123]

                -- OPT-1
                stmt,

                -- OPT-2
                node('If', me.ln,
                    node('Op2_.', me.ln, '.',
                        AST.copy(var),
                        'HACK_6-NIL'),
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Nothing', me.ln))),
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            AWT_KILL))),

                -- OPT-3
-- TODO: workaround bug do IF-then-else com await no then e ptr no else
-- *not* isAlive para inverter then/else
                node('Stmts', me.ln,
                    node('If', me.ln,
                        node('Op1_not', me.ln, 'not',
                            node('Op2_.', me.ln, '.',
                                node('Op1_*', me.ln, '*',
                                    -- this cast confuses acc.lua (see Op1_* there)
                                    -- TODO: HACK_3
                                    node('Op1_cast', me.ln,
                                        node('Type', me.ln, '_tceu_org', '&&'),
                                        node('Op1_&&', me.ln, '&&',
                                            AST.copy(var)))),
                                'isAlive')),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                SET_DEAD)),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                            AWT_KILL)))))
    end,

    Await_pre = function (me)
        local e, dt, cnd = unpack(me)

        -- wclock event, change "e" and insert "dt"
        if dt then
            me[1] = node('Ext', me.ln, '_WCLOCK')
        end

        --  await <E> until <CND>
        --      -- becomes --
        --  loop do
        --      await <E>;
        --      if <CND> then
        --          break;
        --      end
        --  end
        local ret = F.__await_until(me,me)
        if ret then
            return ret
        end

        return F.__await_opts(me, me)
    end,

    _Set_pre = function (me)
        local to, op, tag, fr = unpack(me)

        if tag == 'exp' then
            return node('Set', me.ln, op, tag, fr, to)

        elseif tag == 'await' then
            local ret   -- Set or Loop (await-until)

            --local ret
            --local awt = fr
            --local T = node('Stmts', me.ln)

            if to.tag ~= 'VarList' then
                to = node('VarList', me.ln, to)
            end
            ret = node('Set', me.ln, op, tag, fr, to)

            ret = F.__await_until(fr,ret) or ret
            ret = F.__await_opts(fr,ret)  or ret

            return ret

        elseif tag == 'block' then
            return node('SetBlock', me.ln, fr, to)

        elseif tag == 'thread' then
            return node('Set', me.ln, op, tag, fr, to)

        elseif tag == 'emit-ext' then
            AST.asr(fr, 'EmitExt')
            local op_emt, e, ps = unpack(fr)
            if op_emt == 'request' then
                return F.__REQUEST(me)

            else
                return node('Set', me.ln, op, tag, fr, to)
            end

        elseif tag=='spawn' then
            return node('Set', me.ln, op, tag, fr, to)

        elseif tag=='adt-constr' then
            return node('Set', me.ln, op, tag, fr, to)

        elseif tag == 'do-org' then
            return node('Stmts', me.ln,
                    -- HACK_9
                    node('_TMP_INIT', me.ln, to),
                    F._DoOrg_pre(fr, to))

        elseif tag == 'lua' then
            return node('Set', me.ln, op, tag, fr, to)

        elseif tag == '__trav_rec' then
            local ret = AST.asr(me,'_Set', 4,'_TraverseRec')
            assert(op == '=', 'bug found')
            ret[#ret+1] = to
            return node('Stmts', me.ln,
                    -- HACK_9
                    node('_TMP_INIT', me.ln, to),
                    ret)

        elseif tag == '__trav_loop' then
            local ret = AST.asr(me,'_Set', 4,'_TraverseLoop')
            assert(op == '=', 'bug found')
            ret[#ret+1] = to
            return node('Stmts', me.ln,
                    -- HACK_9
                    node('_TMP_INIT', me.ln, to),
                    ret)

        else
            error 'not implemented'
        end
    end,

-- Lua --------------------------------------------------------

    _LuaExp = function (me)
        --[[
        -- a = @a ; b = @b
        --
        -- __ceu_1, __ceu_2 = ...
        -- a = __ceu_1 ; b = __ceu_2
        --]]
        local params = {}
        local code = {}
        local names = {}
        for _, v in ipairs(me) do
            if type(v) == 'table' then
                params[#params+1] = v
                code[#code+1] = '_ceu_'..#params
                names[#names+1] = code[#code]
            else
                code[#code+1] = v;
            end
        end

        -- me.ret:    node to assign result ("_Set_pre")
        -- me.params: @v1, @v2
        -- me.lua:    code as string

        me.params = params
        if #params == 0 then
            me.lua = table.concat(code,' ')
        else
            me.lua = table.concat(names,', ')..' = ...\n'..
                     table.concat(code,' ')
        end

        me.tag = 'Lua'
    end,
    _LuaStmt = '_LuaExp',

-- EmitExt --------------------------------------------------------

    EmitInt_pre = 'EmitExt_pre',
    EmitExt_pre = function (me)
        local op, e, ps = unpack(me)

        -- wclock event, set "e"
        if e == false then
            me[2] = node('Ext', me.ln, '_WCLOCK')
        end

        -- adjust to ExpList
        if ps == false then
            -- emit A;
            -- emit A => ();
            ps = node('ExpList', me.ln)
        elseif ps.tag == 'ExpList' then
            -- ok
        else
            -- emit A => 1;
            -- emit A => (1);
            ps = node('ExpList', me.ln, ps)
        end
        me[3] = ps

        if op == 'request' then
            return F.__REQUEST(me)
        end
    end,

-- Finalize ------------------------------------------------------

    Finalize_pos = function (me)
        local sub = unpack(me)
        if sub then
            local _,set,fr,to = unpack(sub)
            ASR(set=='exp', me, 'invalid `finalizeÂ´')
        end
    end,

-- Pause ---------------------------------------------------------

    _Pause_pre = function (me)
        local evt, blk = unpack(me)
        local cur_id  = '_cur_'..blk.n
        local cur_dcl = node('Dcl_var', me.ln, 'var',
                            node('Type', me.ln, 'bool'),
                            cur_id)

        local PSE = node('Pause', me.ln, blk)
        PSE.dcl = cur_dcl

        local on  = node('PauseX', me.ln, 1)
            on.blk  = PSE
        local off = node('PauseX', me.ln, 0)
            off.blk = PSE

        local awt = node('Await', me.ln, evt, false)
        awt.isEvery = true

        return
            node('Block', me.ln,
                node('Stmts', me.ln,
                    cur_dcl,    -- Dcl_var(cur_id)
                    node('Set', me.ln, '=', 'exp',
                        node('NUMBER', me.ln, 0),
                        node('Var', me.ln, cur_id)),
                    node('ParOr', me.ln,
                        node('_Loop', me.ln, false, false, false,
                            node('Stmts', me.ln,
                                node('_Set', me.ln,
                                    node('Var', me.ln, cur_id),
                                    '=', 'await',
                                    awt),
                                node('If', me.ln,
                                    node('Var', me.ln, cur_id),
                                    on,
                                    off))),
                        PSE)))
    end,
--[=[
        var u8 psed? = 0;
        par/or do
            loop do
                psed? = await <evt>;
                if psed? then
                    PauseOff()
                else
                    PauseOn()
                end
            end
        with
            pause/if (cur) do
                <blk>
            end
        end
]=]

-- Op2_: ---------------------------------------------------

    ['Op2_:_pre'] = function (me)
        local _, ptr, fld = unpack(me)
        return node('Op2_.', me.ln, '.',
                node('Op1_*', me.ln, '*', ptr),
                fld)
    end,

-- REQUEST

    __REQUEST = function (me)
    --[[
    --      (err, v) = (request LINE=>10);
    -- becomes
    --      do
    --          var _reqid id = _ceu_sys_request();
    --          var int err = (emit _LINE_request => (id, 10));
    --          finalize with
    --              _ceu_sys_unrequest(id);
    --              emit _LINE_cancel => id;
    --          end
    --          if err == 0 then
    --              var _reqid id';
    --              (id', err, v) = await LINE_return
    --                              until id == id';
    --          end
    --      end
    --]]

    local to, op, _, emit
    if me.tag == 'EmitExt' then
        to   = nil
        emit = me
    else
        -- _Set
        to, op, _, emit = unpack(me)
    end

    local op_emt, e, ps = unpack(emit)
    local id_evt = e[1]
    local id_req  = '_reqid_'..me.n
    local id_req2 = '_reqid2_'..me.n

    local tp_req = node('Type', me.ln, 'int')

    -- insert "id" into "emit REQUEST => (id,...)"
    if not ps then
        ps = node('ExpList', me.ln)
    end
    if ps.tag == 'ExpList' then
        table.insert(ps, 1, node('Var',me.ln,id_req))
    else
        ps = node('ExpList', me.ln,
                node('Var', me.ln, id_req),
                ps)
    end

    local awt = node('Await', me.ln,
                    node('Ext', me.ln, id_evt..'_RETURN'),
                    false,
                    node('Op2_==', me.ln, '==',
                        node('Var', me.ln, id_req),
                        node('Var', me.ln, id_req2)))
    awt[1].__adj_is_request = true

    local err_dcl
    local err_var
    if to then
        -- v = await RETURN

        -- insert "id" into "v = await RETURN"
        if to.tag ~= 'VarList' then
            to = node('VarList', me.ln, to)
        end
        table.insert(to, 1, node('Var',me.ln,id_req2))
        to.__adj_is_request = true  -- has to check if payload is "?"

        awt = node('_Set', me.ln, to, op, 'await', awt)
        err_var = to[2]
    else
-- TODO: bug (removing session check)
        awt[3] = false
        err_dcl = node('Dcl_var', me.ln, 'var',
                    node('Type', me.ln, 'int'),
                    '_err_'..me.n)
        err_var = node('Var', me.ln, '_err_'..me.n)
    end

    return node('Block', me.ln,
            node('Stmts', me.ln,
                node('Dcl_var', me.ln, 'var', tp_req, id_req),
                err_dcl or node('Nothing',me.ln),
                node('Set', me.ln, '=', 'exp',
                    node('RawExp', me.ln, 'ceu_out_req()'),
                    node('Var', me.ln, id_req)),
                node('Finalize', me.ln,
                    false,
                    node('Finally', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('Nothing', me.ln), -- TODO: unrequest
                                node('EmitExt', me.ln, 'emit',
                                    node('Ext', me.ln, id_evt..'_CANCEL'),
                                    node('Var', me.ln, id_req)))))),
                node('Set', me.ln, '=', 'emit-ext',
                    node('EmitExt', me.ln, 'emit',
                        node('Ext', me.ln, id_evt..'_REQUEST'),
                        ps),
                    AST.copy(err_var)),
                node('If', me.ln,
                    node('Op2_==', me.ln, '==',
                        AST.copy(err_var),
                        node('NUMBER', me.ln, 0)),
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Dcl_var', me.ln, 'var', tp_req, id_req2),
                            awt)),
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Nothing', me.ln))))
                ))
end

}

AST.visit(F)

-- ADTs ----------------------------------------------------------------------
-- separate visit because of "?" types

-- ADTs created implicitly by "?" option type declarations
local ADTS = {}

G = {
    Stmts_pos = function (me)
        if me.__add then
            for i=#me.__add, 1, -1 do
                table.insert(me, 1, me.__add[i])
            end
            me.__add = nil
        end
    end,

    Type_pre = function (me)
        --
        -- Check if has '?' inside:
        --  - create implicit _Option_*
        --
        local with, without = {}, {}
        for _, v in ipairs(me) do
            with[#with+1] = v
            if v == '?' then
                local id_adt = TP.opt2adt({tt={unpack(with)}})
                if not ADTS[id_adt] then
                    local adt = node('Dcl_adt', me.ln, id_adt,
                                    'union',
                                    node('Dcl_adt_tag', me.ln, 'NIL'),
                                    node('Dcl_adt_tag', me.ln, 'SOME',
                                        node('Stmts', me.ln,
                                            node('Dcl_var', me.ln, 'var',
                                                node('Type', me.ln,  unpack(without)),
                                                'v'))))
                    adt.__adj_from_opt = me
                    ADTS[id_adt] = adt

                    -- add declarations on enclosing "Stmts"
                    local stmts = assert(AST.par(me,'Stmts'))
                    stmts.__add = stmts.__add or {}
                    stmts.__add[#stmts.__add+1] = adt
                end
            end
            without[#without+1] = v
        end
    end,
}

local CLSS = {}  -- holds all clss
local function id2ifc (id)
    for _, cls in ipairs(CLSS) do
        local _,id2 = unpack(cls)
        if id2 == id then
            return cls
        end
    end
    return nil
end

H = {
    -----------------------------------------------------------------------
    -- substitutes all Dcl_imp for the referred fields
    -----------------------------------------------------------------------
    Dcl_cls_pos = function (me)
        CLSS[#CLSS+1] = me
    end,
    Root = function (me)
        for _, cls in ipairs(CLSS) do
            if cls.tag=='Dcl_cls' and cls[2]~='Main' then   -- "Main" has no Dcl_imp's
                local dcls1 = AST.asr(cls.blk_ifc[1][1],'BlockI')[1]
                local i = 1
                while i <= #dcls1 do
                    local imp = dcls1[i]
                    if imp.tag == '_Dcl_imp' then
                        -- interface A,B,...
                        for _,dcl in ipairs(imp) do
                            local ifc = id2ifc(dcl)  -- interface must exist
                            ASR(ifc and ifc[1]==true,
                                imp, 'interface "'..dcl..'" is not declared')
                            local dcls2 = AST.asr(ifc.blk_ifc[1][1],'BlockI')[1]
                            for _, dcl2 in ipairs(dcls2) do
                                assert(dcl2.tag ~= 'Dcl_imp')   -- impossible because I'm going in order
                                if dcl2.tag == 'Dcl_adt' then
                                    -- skip ADT implicit declarations to avoid duplication
                                else
                                    local new = AST.copy(dcl2)
                                    dcls1[#dcls1+1] = new -- fields from interface should go to the end
                                    new.isImp = true      -- to avoid redeclaration warnings indeed
                                end
                            end
                        end
                        table.remove(dcls1, i) -- remove _Dcl_imp
                        i = i - 1                    -- repeat
                    else
                    end
                    i = i + 1
                end
            end
        end
    end,

    -----------------------------------------------------------------------

    Dcl_adt_pos = function (me)
        -- id, op, ...
        local _, op = unpack(me)

        if op == 'struct' then
            local n = #me

            -- variable declarations require a block
            me[3] = node('Block', me.ln,
                        node('Stmts', me.ln, select(3,unpack(me))))

            for i=4, n do
                me[i] = nil -- all already inside block
            end

        else
            assert(op == 'union')
            for i=3, #me do
                AST.asr(me[i], 'Dcl_adt_tag')
                local n = #me[i]
                -- variable declarations require a block
                if n == 1 then
                    -- void enum: include empty Stmts (Block requires them)
                    me[i][2] = node('Block', me.ln, node('Stmts',me.ln))
                else
                    -- non-void enum
                    me[i][2] = node('Block', me.ln, select(2,unpack(me[i])))
                end
                for j=3, n do
                    me[i][j] = nil  -- all already inside block
                end
            end
        end
    end,

    _Adt_explist_pos = function (me)
        me.tag = 'ExpList'
    end,
}
AST.visit(G)
AST.visit(H)

end

    
do
--[[
-- sval: static value
--]]

SVAL = {
    t2n = {
         us = 10^0,
         ms = 10^3,
          s = 10^6,
        min = 60*10^6,
          h = 60*60*10^6,
    },
}

F =
{
    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        if e1.sval and e2.sval then
            local v = loadstring('return '..e1.sval..op..e2.sval)
            me.sval = v and tonumber(v())
        end
    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me)
        local op, e1 = unpack(me)
        if e1.sval then
            local v = loadstring(op..e1.sval)
            me.sval = v and tonumber(v())
        end
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',
    ['Op1_+']   = 'Op1_any',
    ['Op1_not'] = 'Op1_any',

    WCLOCKK = function (me)
        local h,min,s,ms,us, tm = unpack(me)
        me.us = us*SVAL.t2n.us + ms*SVAL.t2n.ms   + s*SVAL.t2n.s
                               + min*SVAL.t2n.min + h*SVAL.t2n.h
        me.tm = tm
        ASR(me.us>0 and me.us<=2000000000, me, 'constant is out of range')
    end,
    WCLOCKE = function (me)
        local exp, unit, tm = unpack(me)
        me.us = nil
        me.tm = tm
    end,

    NUMBER = function (me)
        me.sval = tonumber(me[1])
    end,
    NULL = function (me)
        me.sval = '((void *)0)'
    end,
}

AST.visit(F)

end

    
do
ENV = {
    clss     = {},  -- { [1]=cls, ... [cls]=0 }
    clss_ifc = {},
    clss_cls = {},

    adts = {},      -- { [1]=adt, ... [adt]=0 }

    calls = {},     -- { _printf=true, _myf=true, ... }
    isrs  = {},     -- { }

    -- f=fields, e=events
    ifcs  = {
        flds = {}, -- {[1]='A',[2]='B',A=0,B=1,...}
        evts = {}, -- ...
        funs = {}, -- ...
        trls = {}, -- ...
    },

    exts = {
        --[1]=ext1,         [ext1.id]=ext1.
        --[N-1]={_ASYNC},   [id]={},
        --[N]={_WCLOCK},    [id]={},
    },

    -- TODO: move to TP
    -- "len" is used to sort fields on generated "structs"
    -- TODO: try to remove ENV.c, a lot is shared w/ Type (e.g. hold)
    c = {
        void = 0,

        word     = OPTS.tp_word,
        pointer  = OPTS.tp_word,

        bool     = 1,
        byte     = 1,
        char     = 1,
        int      = OPTS.tp_word,
        uint     = OPTS.tp_word,
        u8=1, u16=2, u32=4, u64=8,
        s8=1, s16=2, s32=4, s64=8,

        float    = OPTS.tp_word,
        f32=4, f64=8,

        tceu_ncls = true,    -- env.lua
        tceu_nlbl = true,    -- labels.lua
    },
    dets  = {},

    max_evt = 0,    -- max # of internal events (exts+1 start from it)
}

for k, v in pairs(ENV.c) do
    if v == true then
        ENV.c[k] = { tag='type', id=k, len=nil }
    else
        ENV.c[k] = { tag='type', id=k, len=v }
    end
end

function CLS ()
    return AST.iter'Dcl_cls'()
end
function ADT ()
    return AST.iter'Dcl_adt'()
end

function var2ifc (var)
    local tp
    if var.pre=='var' or var.pre=='pool' then
        tp = TP.toc(var.tp)
    elseif var.pre == 'event' then
        tp = TP.toc(var.evt.ins)
    elseif var.pre == 'function' then
        tp = TP.toc(var.fun.ins)..'$'..TP.toc(var.fun.out)
    else
        error 'not implemented'
    end
    tp = var.pre..'__'..tp
    return table.concat({
        var.id,
        tp,
        tostring(var.pre),
    }, '$')
end

function ENV.ifc_vs_cls_or_ifc (ifc, cls)
    assert(ifc.is_ifc)
    -- check if they have been checked
    if ifc.matches[cls] ~= nil then
        return ifc.matches[cls]
    end

    -- check if they match
    for _, v1 in ipairs(ifc.blk_ifc.vars) do
        v2 = cls.blk_ifc.vars[v1.id]
        if v2 then
            v2.ifc_id = v2.ifc_id or var2ifc(v2)
        end
        if (not v2) or (v1.ifc_id~=v2.ifc_id) then
            ifc.matches[cls] = false
            return false
        end
    end

    -- yes, they match
    ifc.matches[cls] = true
    if not cls.is_ifc then
        cls.matches[ifc] = true
    end
    return true
end

-- unique numbers for vars and events
local _N = 0
local _E = 1    -- 0=NONE

function ENV.top (tp, me, pre)
    local tp_id = TP.id(tp)
    local adt = ENV.adts[tp_id]
    local cls = ENV.clss[tp_id]

    local plain = TP.check(tp, tp_id, '-[]')
    if not plain then
        return nil
    end

    if cls then
        return cls
    elseif adt then
        if adt.is_rec or (me and AST.isParent(adt,me)) then
            if pre == 'pool' then
                return adt
            else
                return nil
            end
        else
            -- var D id;
            return adt
        end
    else
        return nil
    end
end

local function check (me, pre, tp)
    if tp.tag == 'TupleType' then
        for _, item in ipairs(tp) do
            check(me, pre, AST.asr(item,'', 2,'Type'))
        end
        return
    end

    local tp_id = TP.id(tp)

    local top = ASR(ENV.c[tp_id] or ENV.clss[tp_id] or ENV.adts[tp_id],
                    me, 'undeclared type `'..(tp_id or '?')..'Â´')

    tp_ = TP.pop(tp,'?')

    if pre=='pool' and top.tag=='Dcl_adt' then
        ASR(top.is_rec, me, 'invalid pool : non-recursive data')
    end

    if TP.check(tp_,tp_id, '-[]') then
        if AST.isParent(top,me) then
            if top.tag== 'Dcl_adt' then
                -- ok, List with tag CONS with List tail end
            elseif me.tag=='Dcl_fun' and me[4]==tp then
                -- ok, constructor, "tp" is the return type
            else
                ASR(false, me,
                    'undeclared type `'..(tp_id or '?')..'Â´')
            end
        end
        if top.is_ifc then
            ASR(pre == 'pool', me,
                'cannot instantiate an interface')
        end
    end

    local void_ok = (tp_id=='void' and
                    (pre=='event' or pre=='function' or pre=='input' or
                     pre=='output' or
                     tp_.tt[2]=='&&'))

    ASR(TP.get(tp_id).len~=0 or TP.check(tp_,'&&') or TP.check(tp_,'&') or void_ok,
        me, 'cannot instantiate type "'..tp_id..'"')
    --ASR((not arr) or arr>0, me, 'invalid array dimension')
end

function ENV.v_or_ref (tp, cls_or_adt)
    local tp_id = TP.id(tp)
    local ok = TP.check(tp,tp_id,'-[]','-&','-?')
    if cls_or_adt == 'cls' then
        return ok and ENV.clss[tp_id]
    elseif cls_or_adt == 'adt' then
        return ok and ENV.adts[tp_id]
    else
        return ok and (ENV.clss[tp_id] or ENV.adts[tp_id])
    end
end

function newvar (me, blk, pre, tp, id, isImp, isEvery)
    local ME = CLS() or ADT()  -- (me can be a "data" declaration)
    for stmt in AST.iter() do
        if stmt.tag=='Dcl_cls' or stmt.tag=='Dcl_adt' or stmt.tag=='Dcl_fun'
        or stmt.tag=='Async'   or stmt.tag=='Thread'  or stmt.tag=='Isr'
        then
            break   -- search boundaries
        elseif stmt.tag == 'Block' then
            for _, var in ipairs(stmt.vars) do
                --ASR(var.id~=id or var.blk~=blk, me,
                    --'variable/event "'..var.id..
                    --'" is already declared at --line '..var.ln)
                if var.id == id then
                    local fun = (pre=='function') and (
                                    (stmt==ME.blk_ifc and blk==ME.blk_ifc) -- dcl/body
                                or
                                    (stmt==ME.blk_body and blk==ME.blk_body) -- dcl/body
                                )
                    if fun or id=='_ok' or isImp then
                        -- no problem with hide
                    elseif isEvery then
                        ASR(false, me,
                            'implicit declaration of "'..id..'" hides the one at line '
                                ..var.ln[2])
                    else
                        WRN(false, me,
                            'declaration of "'..id..'" hides the one at line '
                                ..var.ln[2])
                    end
                    --if (blk==ME.blk_ifc or blk==ME.blk_body) then
                        --ASR(false, me, 'cannot hide at top-level block' )
                end
            end
        end
    end

    check(me, pre, tp)
    local top = ENV.top(tp, me, pre)

    -- Class definitions take priority over interface definitions:
    --      * consts
    --      * rec => norec methods
    if blk.vars[id] and (blk==ME.blk_ifc) then
        return true, blk.vars[id]
    end

    local var = {
        ln    = me.ln,
        id    = id,
        blk   = blk,
        tp    = tp,
-- TODO: remove, use ENV.top()
        cls   = (top and top.tag=='Dcl_cls' and top) or (id=='_top_pool'),
        adt   = (top and top.tag=='Dcl_adt' and top),
        pre   = pre,
        inTop = (blk==ME.blk_ifc) or (blk==ME.blk_body) or AST.par(me,'Dcl_adt'),
                -- (never "tmp")
        --isTmp = false,
        --arr   = arr,
        n     = _N,
        dcl   = me,
    }

    local tp, is_ref = TP.pop(tp, '&')   -- only *,& after []
    local is_arr = TP.check(tp, '[]')

    if pre=='var' then
        if is_arr and TP.is_ext(tp,'_','@') then
            var.lval = false
        else
            var.lval = var
        end
    elseif pre=='pool' and (ENV.adts[TP.id(tp)] or is_ref) then
        var.lval = var
    else
        var.lval = false
    end

    _N = _N + 1
    blk.vars[#blk.vars+1] = var
    blk.vars[id] = var -- TODO: last/first/error?
    -- TODO: warning in C (hides)

    return false, var
end

function newint (me, blk, pre, tp, id, isImp)
    local T = TP.new{'void'}

    local has, var = newvar(me, blk, pre, T, id, isImp)
    if has then
        return true, var
    end
    local evt = {
        id  = id,
        idx = _E,
        ins = tp,
        pre = pre,
    }
    var.evt = evt
    _E = _E + 1
    return false, var
end

function newfun (me, blk, pre, rec, ins, out, id, isImp)
    rec = not not rec
    local old = blk.vars[id]
    if old then
        ASR(TP.toc(ins)==TP.toc(old.fun.ins) and
            TP.toc(out)==TP.toc(old.fun.out) and
            rec == old.fun.mod.rec,
            me, 'function declaration does not match the one at "'..
                old.ln[1]..':'..old.ln[2]..'"')
        -- Accept rec mismatch if old is not (old is the concrete impl):
        -- interface with rec f;
        -- class     with     f;
        -- When calling from an interface, call/rec is still required,
        -- but from class it is not.
    end

    check(me, pre, ins)
    check(me, pre, out)

    local has, var = newvar(me, blk, pre,
                        TP.new{'___typeof__(CEU_'..CLS().id..'_'..id..')'},
                        -- TODO: TP.toc eats one '_'
                        id, isImp)
    if has then
        return true, var
    end
    local fun = {
        id  = id,
        ins = ins,
        out = out,
        pre = pre,
        mod = { rec=rec },
        isExt = string.upper(id)==id,
    }
    var.fun = fun
    return false, var
end

local function __vars_check (vars, id)
    if vars.__cache then
        return vars.__cache[id]
    else
        vars.__cache = {}
        for _,var in ipairs(vars) do
            local id = unpack(var)
            vars.__cache[id] = true
        end
        return __vars_check(vars,id)
    end
end

function ENV.getvar (id, blk)
    local blk = blk or AST.iter('Block')()
    while blk do
        if blk.tag=='Dcl_cls' or blk.tag=='Dcl_adt' then
            return nil      -- class/adt boundary
        elseif blk.tag=='Async' or blk.tag=='Thread' or blk.tag=='Isr' then
            local vars = unpack(blk)    -- VarList
            if blk.tag == 'Isr' then
                vars = blk[3]
            end
            if not (vars and __vars_check(vars,id)) then
                return nil  -- async boundary: stop unless declared with `&Â´
            end
        elseif blk.tag == 'Block' then
            for i=#blk.vars, 1, -1 do   -- n..1 (hidden vars)
                local var = blk.vars[i]
                if var.id == id then
                    return var
                end
            end
        end
        blk = blk.__par
    end
    return nil
end

-- identifiers for ID_c / ID_ext (allow to be defined after annotations)
-- variables for Var
function det2id (v)
    if type(v) == 'string' then
        return v
    else
        return v.var
    end
end

local STACK_N_E = { }

F = {
    Node = function (me)
        me.fst = me.fst or me
        me.lst = me.lst or me
    end,

    Type_pos      = TP.new,
    TupleType_pos = TP.new,

    Root_pre = function (me)
        -- TODO: NONE=0
        -- TODO: if PROPS.* then ... end

        local t = {
        -- runtime
            { '_ORG',       nil          },
            { '_ORG_PSED',  nil          },
            { '_CLEAR',     nil          },
            { '_ok_killed', {'int'}      },
        -- input / runtime
            { '_INIT',      nil,     'seqno' }, -- _INIT = HIGHER EXTERNAL
            { '_ASYNC',     nil,     'seqno' },
            { '_THREAD',    nil,     'seqno' },
            { '_WCLOCK',    {'s32'}, 'seqno' },
        }

        if OPTS.timemachine then
            t[#t+1] = { '_WCLOCK_', {'s32'}, 'seqno' }
        end

        -- input / user
        if OPTS.os then
            t[#t+1] = { 'OS_START',     {'void'}, 'seqno' }
            t[#t+1] = { 'OS_STOP',      {'void'}, 'seqno' }
            t[#t+1] = { 'OS_DT',        {'int'},  'seqno' }
            t[#t+1] = { 'OS_INTERRUPT', {'int'},  'seqno' }
        end

        for _, v in ipairs(t) do
            local id, tt, seqno = unpack(v)
            local tp = tt and TP.new(tt)
            local evt = {
                ln  = me.ln,
                id  = id,
                pre = 'input',
                ins = tp and AST.node('TupleType', me.ln,
                                AST.node('TupleTypeItem', me.ln, false, tp, false)),
                mod = { rec=false },
                seqno = seqno,
                os  = true,     -- do not generate #define with OPTS.os==true
            }
            if tp then
                TP.new(evt.ins)
            end
            ENV.exts[#ENV.exts+1] = evt
            ENV.exts[id] = evt
        end
        ENV.exts._WCLOCK.op = 'emit'
    end,

    Root = function (me)
        TP.types.tceu_ncls.len = 2 --TP.n2bytes(#ENV.clss_cls*2)
                                    -- *2 (signed => unsigned)
        ASR(ENV.max_evt+#ENV.exts < 255, me, 'too many events')
                                    -- 0 = NONE

        -- matches all ifc vs cls/ifc
        for _, ifc in ipairs(ENV.clss_ifc) do
            for _, cls in ipairs(ENV.clss) do
                local matches = ENV.ifc_vs_cls_or_ifc(ifc, cls)
                -- TODO: HACK_4: delayed declaration until use
                if matches then
                    ifc.__env_last_match = cls
                        -- interface must be declared only after last class
                end
            end
        end
        local glb = ENV.clss.Global
        if glb then
            ASR(glb.is_ifc and glb.matches[ENV.clss.Main], me,
                'interface "Global" must be implemented by class "Main"')
        end
    end,

    Block_pre = function (me)
        me.vars = {}

        -- include arguments into function block
        local fun = AST.iter()()
        local _, _, inp, out = unpack(fun)
        if fun.tag == 'Dcl_fun' then
            for i, v in ipairs(inp) do
                local _, tp, id = unpack(v)
                if tp ~= 'void' then
                    local has,var = newvar(fun, me, 'var', tp, id, false)
                    assert(not has)
                    var.isTmp  = true -- TODO: var should be a node
                    var.is_arg = true
                    var.funIdx = i
                end
            end
        end
    end,

    Dcl_cls_pos = function (me)
        _N, _E = unpack(STACK_N_E[#STACK_N_E])
        STACK_N_E[#STACK_N_E] = nil
    end,
    Dcl_cls_pre = function (me)
        local ifc, id, blk = unpack(me)
        me.c       = {}      -- holds all "native _f()"
        me.is_ifc  = ifc
        me.id      = id
        me.tp      = TP.new{id}
        me.matches = {}

        -- restart variables/events counting
        STACK_N_E[#STACK_N_E+1] = { _N, _E }

        ASR(not (ENV.clss[id] or ENV.adts[id]), me,
            'top-level identifier "'..id..'" already taken')
        ENV.clss[id] = me
        ENV.clss[#ENV.clss+1] = me

        if me.is_ifc then
            me.n = #ENV.clss_ifc   -- TODO: n=>?
            ENV.clss_ifc[id] = me
            ENV.clss_ifc[#ENV.clss_ifc+1] = me
        else
            me.n = #ENV.clss_cls   -- TODO: remove Main?   -- TODO: n=>?
            ENV.clss_cls[id] = me
            ENV.clss_cls[#ENV.clss_cls+1] = me
        end
    end,
    Dcl_cls = function (me)
        ENV.max_evt = MAX(ENV.max_evt, _E)

        -- all identifiers in all interfaces get a unique (sequential) N
        if me.is_ifc then
            for _, var in pairs(me.blk_ifc.vars) do
                var.ifc_id = var.ifc_id or var2ifc(var)
                if not ENV.ifcs[var.ifc_id] then
                    if var.pre=='var' or var.pre=='pool' then
                        ENV.ifcs.flds[var.ifc_id] = #ENV.ifcs.flds
                        ENV.ifcs.flds[#ENV.ifcs.flds+1] = var.ifc_id
                    elseif var.pre == 'event' then
                        ENV.ifcs.evts[var.ifc_id] = #ENV.ifcs.evts
                        ENV.ifcs.evts[#ENV.ifcs.evts+1] = var.ifc_id
                    elseif var.pre == 'function' then
                        ENV.ifcs.funs[var.ifc_id] = #ENV.ifcs.funs
                        ENV.ifcs.funs[#ENV.ifcs.funs+1] = var.ifc_id
                    end
                end
            end
        end
    end,

    Dcl_adt_pre = function (me)
        local id, op = unpack(me)

        ASR(not (ENV.adts[id] or ENV.clss[id]), me,
            'top-level identifier "'..id..'" already taken')
        ENV.adts[id] = me
        ENV.adts[#ENV.adts+1] = me
    end,
    Dcl_adt = function (me)
        local id_adt, op = unpack(me)
        me.id = id_adt

        if op == 'struct' then
            -- convert vars=>tuple (to check constructors)
            me.tup = AST.node('TupleType', me.ln)

            -- Dcl_adt[3]->Block[1]->Stmts[*]->Stmts
            local STMTS = AST.asr(me,'', 3,'Block', 1,'Stmts')
            for _, stmts in ipairs(STMTS) do
                AST.asr(stmts, 'Stmts')
                for _, dclvar in ipairs(stmts) do
                    AST.asr(dclvar, 'Dcl_var')
                    local _, var_tp, var_id = unpack(dclvar)
                    if TP.check(var_tp,'[]','-&') then
                        ASR(TP.is_ext(var_tp,'_','@'), dclvar,
                            '`dataÂ´ fields do not support vectors yet')
                    end
                    local item = AST.node('TupleTypeItem', me.ln,
                                    false,var_tp,false)
                    me.tup[#me.tup+1] = item
                    item.var_id = var_id
                end
            end

            TP.new(me.tup)

        else
            assert(op == 'union')
            me.tags = {} -- map tag=>{blk,tup}
            for i=3, #me do
                AST.asr(me[i], 'Dcl_adt_tag')
                local id_tag, blk = unpack(me[i])
                local tup = AST.node('TupleType',me.ln)
                ASR(not me.tags[id_tag], me[i],
                    'duplicated tag : "'..id_tag..'"')

                me.tags[id_tag] = { blk=blk, tup=tup }
                me.tags[#me.tags+1] = id_tag

                if blk then -- skip void enums
                    for _, stmts in ipairs(blk) do
                        AST.asr(stmts, 'Stmts')
                        local dclvar = unpack(stmts)
                        if dclvar then
                            local _, var_tp, var_id = unpack(dclvar)
                            local item = AST.node('TupleTypeItem', me.ln,
                                            false,var_tp,false)
                            if TP.check(var_tp,'[]','-&') then
                                ASR(TP.is_ext(var_tp,'_','@'), dclvar,
                                    '`dataÂ´ fields do not support vectors yet')
                            end

                            --  data Y with ... end
                            --  data X with
                            --      tag T with
                            --          var X* x;   // is_rec=true
                            --      end
                            --  or
                            --      tag U with
                            --          var Y* y;   // is_rec=true
                            --      end
                            --  end
                            local id_sub = TP.id(var_tp)
                            local outer = ENV.adts[id_sub]
                            if (id_sub == id_adt) or
                               (outer and outer.is_rec)
                            then
                                if id_sub ~= id_adt then
                                    -- outer tag
                                    me.subs = me.subs or {}
                                    me.subs[id_sub] = true
                                end
                                me.is_rec = true
                                item.is_rec = true
                            end
                            tup[#tup+1] = item
                            item.var_id = var_id
                        end
                    end
                end

                TP.new(tup, true)
            end
        end
    end,

    Dcl_det = function (me)                 -- TODO: verify in ENV.c
        local id1 = det2id(me[1])
        local t1 = ENV.dets[id1] or {}
        if #me == 1 then
            t1 = true   -- safe against everything
        end
        ENV.dets[id1] = t1
        for i=2, #me do
            local id2 = det2id(me[i])

            if t1 ~= true then
                t1[id2] = true
            end

            local t2 = ENV.dets[id2] or {}
            if t2 ~= true then
                ENV.dets[id2] = t2
                t2[id1] = true
            end
        end
    end,

    Global = function (me)
        ASR(ENV.clss.Global and ENV.clss.Global.is_ifc, me,
            'interface "Global" is not defined')
        me.tp   = TP.new{'Global','&&'}
        me.lval = false
        me.blk  = AST.root
    end,

    Outer = function (me)
        local cls = CLS()
            --ASR(cls ~= MAIN, me, 'invalid access')
        ASR(cls, me, 'undeclared class')
        me.tp   = cls.tp
        me.lval = false
        me.blk  = cls.blk_ifc
    end,

    This = function (me)
        -- if inside constructor, change scope to the class being created
        local constr = AST.iter'Dcl_constr'()
        local cls = constr and constr.cls or CLS()
        ASR(cls, me, 'undeclared class')
        me.tp   = cls.tp
        me.lval = false
        me.blk  = cls.blk_ifc
    end,

    Dcl_ext = function (me)
        local dir, rec, ins, out, id = unpack(me)
        local ext = ENV.exts[id]
        if ext then
            local eq = (ext.pre==dir and ext.mod.rec==rec and
                        ext.out==(out or 'int') and TP.contains(ext.ins,ins))
            WRN(eq, me, 'event "'..id..'" is already declared')
            return
        end

        for I, item in ipairs(ins) do
            local _,tp,_ = unpack(item)

            -- "base" is a basic type: _t, int, etc
            local base = TP.base(tp)
            ASR(TP.types[base.tt[1]] or TP.is_ext(base,'_'), me,
                'invalid event type')

            if #tp.tt > 1 then
                -- last mod is "&&"
                local tp,v = TP.pop(tp)
                ASR(v=='&&', me, 'invalid event type')

                -- other mods are "&&" or single "[]"
                for i=2, #tp.tt do
                    if tp.tt[i] == '[]' then
                        ASR(i==#tp.tt, me, 'invalid event type')
                        ASR(I==#ins, me,
                            'invalid event type : vector only as the last argument')
                    else
                        ASR(v=='&&', me, 'invalid event type')
                    end
                end
            end
        end

        me.evt = {
            ln  = me.ln,
            id  = id,
            pre = dir,
            ins = ins,
            out = out or 'int',
            mod = { rec=rec },
            op  = (out and 'call' or 'emit'),
            seqno = true,
        }
        ENV.exts[#ENV.exts+1] = me.evt
        ENV.exts[id] = me.evt
    end,

    __dcl_var = function (me)
        local pre, tp, id, constr, isTmp = unpack(me)

        if id == '_' then
            id = id..me.n   -- avoids clash with other '_'
        end

        local has
        has, me.var = newvar(me, AST.par(me,'Block'), pre, tp, id, me.isImp, me.isEvery)
        assert(not has or (me.var.read_only==nil))

        me.var.read_only = me.read_only

        if constr then
            ASR(me.var.cls, me, 'invalid type')
            constr.blk = me.var.blk
        end

        if isTmp then
            me.var.isTmp = true
        end
    end,

    -- declare variable before the constructor
    Dcl_var_aft = function (me, sub, i)
        if i == 3 then
            F.__dcl_var(me)
        end
    end,

    Dcl_var = function (me)
        local _, tp, id, constr, _ = unpack(me)

        if me.var.cls then
            if not constr then
                me[4] = AST.node('Dcl_constr', me.ln,
                            AST.node('Block', me.ln,
                                AST.node('Stmts', me.ln)))
                F.Dcl_constr_pre(AST.asr(me,'', 4,'Dcl_constr'))
                F.Block_pre(AST.asr(me,'', 4,'Dcl_constr', 1,'Block'))
            end
            if TP.check(me.var.tp,'[]') then
                ASR(me.var.tp.arr.sval, me,
                    'invalid static expression')
            end
        end

        if me.var.cls and TP.check(me.var.tp,'[]') then
            -- var T[10] ts;  // needs _i_ to iterate for the constructor
            _, me.var.constructor_iterator =
                newvar(me, AST.par(me,'Block'), 'var', TP.new{'int'}, '_i_'..id, false)
        end
    end,

    __Dcl_pool_pre = function (me)
        local pre, tp, id, constr = unpack(me)

        if ENV.adts[tp[1]] then
            -- ADT has the type of the pool values
            me[2] = AST.copy(tp)
            me[2][3] = false
        else
            -- CLS has no type
            me[2] = TP.new{'void'}

            local tp_ = TP.new(tp)
            local tp_id = TP.id(tp_)
            local top = not (TP.check(tp_,'&&') or TP.check(tp_,'&'))
            ASR(tp_id=='_TOP_POOL' or top,
                me, 'undeclared type `'..(tp_id or '?')..'Â´')
        end
    end,

    Dcl_pool = function (me)
        local pre, tp, id, constr = unpack(me)
        ASR(TP.check(tp,'[]','-&&','-&'), me, 'missing `poolÂ´ dimension')
        F.__dcl_var(me)
    end,

    Dcl_int = function (me)
        local pre, tp, id = unpack(me)
        if id == '_' then
            id = id..me.n   -- avoids clash with other '_'
        end
        assert(tp.tup, 'bug found')
        for _, t in ipairs(tp.tup) do
            ASR(TP.isNumeric(t), me, 'invalid event type')
        end
        local _
        _, me.var = newint(me, AST.iter'Block'(), pre, tp, id, me.isImp)
    end,

    Dcl_fun_aft = function (me, sub, i)
        if i ~= 5 then
            return  -- evaulate just before "blk" so that "return" can be checked
        end
        local pre, rec, ins, out, id, blk = unpack(me)
        local cls = CLS()

        -- implementation cannot be inside interface, so,
        -- if it appears on blk_body, make it be in blk_ifc
        local up = AST.par(me, 'Block')
        if blk and cls.blk_body==up and cls.blk_ifc.vars[id] then
            up = cls.blk_ifc
        end

        local _
        _, me.var = newfun(me, up, pre, rec, ins, out, id, me.isImp)

        -- "void" as parameter only if single
        for i, v in ipairs(ins) do
            local _, tp, _ = unpack(v)
            if #ins > 1 then
                ASR(not TP.check(tp,'void'), me,
                    'wrong argument #'..i..' : cannot be `voidÂ´ argument')
            end
            ASR(not TP.check(tp,'[]'), me,
                'wrong argument #'..i..' : vectors are not supported')
        end

        -- full definitions must contain parameter ids
        if blk then
            for _, v in ipairs(ins) do
                local _, tp, id = unpack(v)
                ASR(tp=='void' or id, me, 'missing parameter identifier')
            end
        end
    end,

    Return = function (me)
        local exp = unpack(me)

        local dcl = AST.par(me, 'Dcl_fun')
        if not dcl then
            return  -- checked in props.lua
        end

        if (not exp) and TP.check(dcl.var.fun.out,'void') then
            return
        else
            local ok, msg = TP.contains(dcl.var.fun.out, exp.tp)
            ASR(ok, me, 'invalid return value : '..(msg or ''))

            -- cannot return local reference from function
            local var = exp.fst.var
            if var and AST.isParent(dcl, var.blk) then
                local is_ref = TP.check(exp.tp,'&','-?')
                            or TP.check(exp.tp,'&&','-?')
                local is_top = (var.blk == dcl.var.blk)
                local is_org = ENV.clss[TP.id(exp.tp)]
                ASR((not is_ref) or is_top or is_org, me,
                   'invalid return value : local reference')
            end
        end
    end,

    Ext = function (me)
        local id = unpack(me)
        me.evt = ASR(ENV.exts[id], me,
                    'event "'..id..'" is not declared')
    end,

    Var_pre = function (me)
        local id = unpack(me)
        local blk = me.__ast_blk and assert(AST.par(me.__ast_blk,'Block'))
                        or AST.iter('Block')()
        local var = me.var or ENV.getvar(id, blk)

        -- OUT access in recurse loops
        --  var int x;
        --  loop v in <adt> do
        --      x = 1;
        --  end
        --      ... becomes ...
        --      this.out.x
        if not var then
            local cls = CLS()
            local out = cls.__adj_out
            if out then
                var = ENV.getvar(id, out)
                if var then
                    local ret = AST.node('Op2_.', me.ln, '.',
                                    AST.node('Var', me.ln, '_out'),
                                    id)
                    ret.blk_out = out   -- HACK_7
                    return ret
                end
            end
        end

    end,

    Var = function (me)
        local id = unpack(me)
        local blk = me.__ast_blk and assert(AST.par(me.__ast_blk,'Block'))
                        or AST.iter('Block')()
        local var = me.var or ENV.getvar(id, blk)

        ASR(var, me, 'variable/event "'..id..'" is not declared')
        me.var  = var
        me.tp   = var.tp
        me.lval = var.lval
    end,

    VarList = function (me)
        me.tp   = me
        me.lval = me
        me.tp.tup = TP.t2tup(me)

        if me.__adj_is_request and #me==3 then
            ASR(TP.check(me[3].tp,'?'), me,
                'payload "'..me[3].var.id..'" must be an option type',
 [[
    Given that requests might fail, the receiving payload must be an option 
type.
]])
        end
    end,
    ExpList = function (me)
        me.tp   = me
        me.lval = false
        me.tp.tup = TP.t2tup(me)
    end,

    Dcl_nat = function (me)
        local mod, tag, id, len = unpack(me)
        if tag=='type' or mod=='@plain' then
            local tp = TP.new{id}
            tp.len   = len
            tp.plain = (mod=='@plain')
            TP.types[id] = tp
        end
        -- TODO: remove
        ENV.c[id] = { tag=tag, id=id, len=len, mod=mod }
    end,

    Dcl_pure = function (me)
        ENV.pures[me[1]] = true
    end,

    _TMP_ITER = function (me)
        -- HACK_5: figure out iter type
        local pool = unpack(me)
        pool = pool.lst
        ASR(pool.var and TP.check(pool.tp,TP.id(pool.tp),'[]','-&&','-&'),
            me, 'invalid pool')

        local blki = AST.asr(me.__par,'Stmts', 3,'Dcl_cls',
                                    3,'Block', 1,'Stmts', 1,'BlockI')

        local tp = AST.asr(blki,'', 1,'Stmts', 3,'Dcl_pool', 2,'Type')

        -- tp id
        tp[1] = TP.id(pool.tp)

        local arr = '[]'
        if pool.tp.arr and pool.tp.arr~='[]' then
            -- +1 for NIL/BASE case
            arr = AST.node('Op2_+', me.ln, '+',
                    AST.copy(pool.tp.arr), -- array
                    AST.node('NUMBER', me.ln, '1'))
            arr.sval = pool.tp.arr.sval+1
        end

        AST.asr(blki,'', 1,'Stmts', 1,'Dcl_pool', 2,'Type')
                [2] = (arr=='[]' and '[]') or AST.copy(arr)
        AST.asr(me.__par,'Stmts', 4,'Dcl_pool', 2,'Type')
                [2] = (arr=='[]' and '[]') or AST.copy(arr)

        me.tag = 'Nothing'
    end,

    _TMP_AWAIT = function (me)
        -- HACK_6 [await]: detects if OPT-1 (evt) or OPT-2 (adt) or OPT-3 (org)
        local stmts = AST.asr(me.__par, 'Stmts')

        local tp    = me[1].tp  -- type of Var
        local tp_id = tp and TP.id(tp)

        if tp and ENV.clss[tp_id] then
            ASR(ENV.v_or_ref(tp,'cls'), me, 'organism must not be a pointer')
            stmts[2] = AST.node('Nothing', me.ln)       -- remove OPT-1
            stmts[3] = AST.node('Nothing', me.ln)       -- remove OPT-2
            me.__env_watching = true    -- see props.lua
            local awt = AST.asr(stmts,'', 4,'Stmts', 1,'If', 3,'Block', 1,'Stmts')[1]
            if awt.tag ~= 'Await' then
                awt = AST.asr(awt,'Set', 3,'Await')
            end
            awt.__env_org = me[1]   -- see fin.lua
        elseif tp and ENV.adts[tp_id] then
            --ASR(tp.ptr==1, me, 'data must be a pointer')
            local dot = AST.asr(stmts,'', 3,'If', 1,'Op2_.')
            assert(dot[3] == 'HACK_6-NIL')
            dot[3] = ENV.adts[tp_id].tags[1]
            stmts[2] = AST.node('Nothing', me.ln)       -- remove OPT-1
            stmts[4] = AST.node('Nothing', me.ln)       -- remove OPT-3
            me.__env_watching = tp_id   -- see props.lua
            dot.__env_watching = true   -- see adt.lua
        else
            stmts[3] = AST.node('Nothing', me.ln)       -- remove OPT-2
            stmts[4] = AST.node('Nothing', me.ln)       -- remove OPT-3
        end

        --AST.asr(stmts,'', 1,'_TMP_AWAIT')
        --stmts[1] = AST.node('Nothing', me.ln)   -- remove myself
        me.tag = 'Nothing'
        --me[1] = nil
    end,

    Await = function (me)
        local e = unpack(me)
        local ins
        if e.tag == 'Ext' then
            if e.evt.id == '_ok_killed' then
                me.awt_tp = 'org/adt'
            else
                me.awt_tp = 'evt'
            end
            ins = e.evt.ins
        else
            me.awt_tp = 'evt'
            ASR(e.var and e.var.pre=='event', me,
                'event "'..(e.var and e.var.id or '?')..'" is not declared')
            ins = e.var.evt.ins
        end
        if ins.tup then
            me.tp = TP.new{'_'..TP.toc(ins),'&&'} -- convert to pointer
        else
            me.tp = ins
        end
    end,

    EmitInt = function (me)
        local _, int, ps = unpack(me)
        local var = int.var
        ASR(var and var.pre=='event', me,
            'event "'..(var and var.id or '?')..'" is not declared')
        local ok, msg = TP.contains(var.evt.ins, ps)
        ASR(ok, me, msg)
    end,

    EmitExt = function (me)
        local op, e, ps = unpack(me)

        ASR(e.evt.op == op, me, 'invalid `'..op..'Â´')
        local ok, msg = TP.contains(e.evt.ins, ps)
        ASR(ok, me, msg)

        if op == 'call' then
            me.tp = e.evt.out       -- return value
        else
            me.tp = TP.new{'int'} -- [0,1] enqueued? (or 'int' return val)
        end
    end,

    --------------------------------------------------------------------------

    Set = function (me)
        local _, set, fr, to = unpack(me)
        to = to or AST.iter'SetBlock'()[1]

        local lua_str = false
        local fr_tp = fr.tp

        local to_tp_id, to_is_opt
        if set~='await' and (not to.tp.tup) then
            to_tp_id  = TP.id(to.tp)
            to_is_opt = TP.check(to.tp,'?')
        end

        if set == 'await' then
            local e = unpack(fr)
            fr_tp = (e.var or e).evt.ins

        elseif set == 'emit-ext' then
            -- ok

        elseif set == 'thread' then
            fr_tp = TP.new{'int'}       -- 0/1

        elseif set == 'spawn' then
            -- var T*? = spawn T;
            ASR(to_is_opt, me, 'must assign to option pointer')

            -- a = spawn T
            fr.blk = to.lst.var.blk   -- to = me.__par[3]
            -- refuses (x.ptr = spawn T;)
            ASR( AST.isParent(CLS(),to.lst.var.blk), me,
                    'invalid attribution (no scope)' )

        elseif set == 'lua' then
            lua_str = TP.check(to.tp,'char','[]','-&')
            if not lua_str then
                ASR(to and to.lval, me, 'invalid attribution')
            end

            ASR(TP.isNumeric(to.tp,'&') or TP.check(to.tp,'bool','-&') or
                TP.check(to.tp, to_tp_id, '&&', '-&') or
                lua_str,
                me, 'invalid attribution')
            fr.tp = to.tp -- return type is not known at compile time

        elseif set == 'adt-constr' then
            if to.lst.var and to.lst.var.pre == 'pool' then
                return  -- TODO: not enough
            end
-- TODO: should be only this below
            return  -- checked in adt.lua

        else
            assert(set == 'exp', 'bug found')

            -- transform into 'adt-ref' or 'adt-mut'
            local adt = ENV.adts[to_tp_id]
            if adt and adt.is_rec then
                if to_is_opt then
                    error'not tested: originaly, it would remain "exp"'
                end
                if TP.check(fr.tp,'&&','-&') or fr.tag=='Op1_&' then
                    -- <...> = & <...>
                    -- <...> = && <...>
                    me[2] = 'adt-ref'
                else
                    me[2] = 'adt-mut'
                end
                return
            end

            if fr.tag == 'Vector_constr' then
                -- TODO: TP.pre() (only pool?)
                local is_vec = TP.check(to.tp,'[]','-&') and
                               (not TP.is_ext(to.tp,'_','@'))
                local is_cls = ENV.clss[TP.id(to.tp)] and
                               TP.check(TP.pop(to.tp,'&'),TP.id(to.tp),'[]')
                ASR(is_vec and (not is_cls), me, 'invalid attribution : destination is not a vector')

                local to_unit = TP.pop(TP.pop(to.tp,'&'),'[]')
                local to_unit_noopt, isopt = TP.pop(to_unit,'?')
                AST.asr(fr, 'Vector_constr')
                for i, e in ipairs(fr) do
                    if e.tag == 'Vector_tup' then
                        if #e > 0 then
                            e = AST.asr(e,'', 1,'ExpList')
                            for j, ee in ipairs(e) do
                                local ok, msg = TP.contains(to_unit_noopt,
                                                            isopt and TP.pop(ee.tp,'?') or ee.tp)
                                ASR(ok, me, 'wrong argument #'..j..' : '..(msg or ''))
                            end
                        end
                    else -- vector
                        local is_str = TP.check(e.tp,'char','&&','-&')
                        local is_vec = TP.check(e.tp,'[]','-&') and
                                       (not TP.is_ext(e.tp,'_','@'))
                        local msg1 = (#fr>0 and 'wrong argument #'..i..' : ') or ''
                        ASR(is_str or is_vec, me, msg1..'source is not a vector')

                        local fr_unit = is_str and TP.new{'char'} or
                                        TP.pop(TP.pop(e.tp,'&'),'[]')
                        local ok, msg2 = TP.contains(to_unit_noopt,
                                                     isopt and TP.pop(fr_unit,'?') or fr_unit)
                        ASR(ok, me, msg1..(msg2 or ''))
                    end
                end
            end
        end

        if set ~= 'lua' then
            local to_tp_noopt, to_isopt = TP.pop(to.tp, '?')
            if to_isopt then
                local _, to_isoptref = TP.pop(to_tp_noopt, '&')
                local ok, msg = TP.contains(to.tp, TP.pop(fr_tp,'?'), {option=true})
                ASR(ok, me, msg)
                if to_isoptref then
                    -- var int&? v = <...>;
                    -- v = 10;  -- refuse
                    ASR(fr.tag=='Op1_&', me,
                        'invalid attribution : missing `!Â´ (in the left) or `&Â´ (in the right)')
                end
            else
                local ok, msg = TP.contains(to.tp, fr_tp, {option=true})
                ASR(ok, me, msg)
            end
        end

        if fr.tag == 'Op1_&' then
            ASR(TP.check(to.tp,'&','-?'), me,
                'invalid attribution : l-value cannot hold an alias', [[
    An alias is a variable declared with the type modifier `&Â´ (e.g.,
    "var int& a").
]])

        elseif (not lua_str) then
            ASR(to and to.lval, me,
                'invalid attribution : not assignable')
            ASR(me.read_only or (not to.lval.read_only), me,
                'read-only variable')
        end

        ASR(not CLS().is_ifc, me, 'invalid attribution')
    end,

    Free = function (me)
        local exp = unpack(me)
        local tp_id = TP.id(exp.tp)
        ASR(TT.check(exp.tp,id,'&&','-&'), me,
            'invalid `freeÂ´')
        me.cls = ASR(ENV.clss[tp_id], me,
                        'class "'..id..'" is not declared')
    end,

    -- _pre: gives error before "set" inside it
    Spawn_pre = function (me)
        local id, _, _ = unpack(me)
        me.cls = ENV.clss[id]
        ASR(me.cls, me, 'undeclared type `'..id..'Â´')
        ASR(not me.cls.is_ifc, me, 'cannot instantiate an interface')
        me.tp = TP.new{id,'&&'}  -- class id
    end,
    Spawn = function (me)
        local _, pool, constr = unpack(me)
        ASR(pool and pool.lst and pool.lst.var and pool.lst.var.pre=='pool',
            me, 'invalid pool')
    end,

    Dcl_constr_pre = function (me)
        local spw = AST.iter'Spawn'()
        local dcl = AST.iter'Dcl_var'()

        -- type check for this.* inside constructor
        if spw then
            me.cls = ENV.clss[ spw[1] ]   -- checked on Spawn
        elseif dcl then
            me.cls = ENV.clss[ TP.id(dcl[2]) ]   -- checked on Dcl_var
        end
        --assert(me.cls)
    end,

    CallStmt = function (me)
        local call = unpack(me)
        ASR(call.tag == 'Op2_call', me, 'invalid statement')
    end,

    Loop_aft = function (me, sub, i)
        if i ~= 2 then
            return      -- declarations after "iter"
        end

        local max, iter, to, _ = unpack(me)
        local is_num = (iter and (not me.isEvery) and TP.isNumeric(iter.tp))
                        or (to and (not iter))

        if max or is_num then
            local id = (is_num and to[1]) or '_i_'..me.n
            me.i_dcl = AST.node('Dcl_var', me.ln, 'var',
                        AST.node('Type', me.ln, 'int'),
                        id)
            me.i_dcl.read_only = true
            me.i_var = (is_num and to) or AST.node('Var',me.ln,id)
            AST.visit(F, me.i_dcl)
            me.i_dcl.var.__env_is_loop_var = true   -- (see ref.lua)
            local stmts = me.__par[1]
            stmts[#stmts+1] = me.i_dcl
            if not is_num then
                AST.visit(F, me.i_var)
                stmts[#stmts+1] = me.i_var
            end
        end

        local cls = iter and iter.tp and ENV.clss[TP.id(iter.tp)]

        if is_num then
            me.iter_tp = 'number'
            -- done above

        elseif me.isEvery then
            me[3] = false   -- "to" is set on the "await"
            me.iter_tp = 'event'
            if to then
                local evt = (iter.var or iter).evt
                local tup = (evt and evt.ins.tup) or { iter.tp }
                to = (to.tag=='VarList' and to) or { to }
                ASR(#tup==#to, me, 'arity mismatch')
                for i, tp in ipairs(tup) do
                    local dcl = AST.node('Dcl_var', me.ln, 'var', AST.copy(tp), to[i][1])
                    dcl.isEvery = true  -- implicit declaration: cannot hide other variables
                    AST.visit(F, dcl)
                    dcl.var.__env_is_loop_var = true   -- (see ref.lua)
                    local stmts = AST.asr(me.__par[1],'Stmts')
                    stmts[#stmts+1] = dcl
                end
            end

        elseif cls then
            me.iter_tp = 'org'
            if to then
                local dcl = AST.node('Dcl_var', me.ln, 'var',
                                AST.node('Type', me.ln, cls.id, '&&'),
                                to[1])
                dcl.read_only = true
                AST.visit(F, dcl)
                dcl.var.__env_is_loop_var = true   -- (see ref.lua)
                local stmts = me.__par[1]
                stmts[#stmts+1] = dcl
            end

            ASR(iter.lst and iter.lst.var and iter.lst.var.pre=='pool',
                me, 'invalid pool')

        elseif iter and TP.check(iter.tp,'&&') then
            me.iter_tp = 'data'
            if to then
                local dcl = AST.node('Dcl_var', me.ln, 'var',
                                AST.copy(iter.tp),
                                to[1])
                dcl.read_only = true
                AST.visit(F, dcl)
                dcl.var.__env_is_loop_var = true   -- (see ref.lua)
                local stmts = me.__par[1]
                stmts[#stmts+1] = dcl
            end
        end
    end,

    --------------------------------------------------------------------------

    Adt_constr_root = function (me)
        local _, one = unpack(me)
        me.lval = false
        me.tp = one.tp
    end,
    Adt_constr_one = function (me)
        local adt, params = unpack(me)
        local id_adt, id_tag = unpack(adt)
        me.tp = TP.new{id_adt}

        local tup
        local tadt = ASR(ENV.adts[id_adt], me,
                        'data "'..id_adt..'" is not declared')

        if id_tag then
            local ttag = ASR(tadt.tags[id_tag], me,
                            'tag "'..id_tag..'" is not declared')

            -- Refuse recursive constructors that are not new data:
            --  data D with
            --      <...>
            --  or
            --      tag REC with
            --          var D rec;
            --      end
            --  end
            --  <...> = new D.REC(ptr)      -- NO!
            --  <...> = new D.REC(D.xxx)    -- OK!
            for i, p in ipairs(params) do
                if ttag.tup[i] and ttag.tup[i].is_rec then
                    ASR(p.tag == 'Adt_constr_one', me,
                        'invalid constructor : recursive field "'..id_tag..'" must be new data')
                    --p.tp.tt[#p.tp.tt+1] = '&&'
                    --params[i].tp = TP.new(TP.push(p.tp,'&&'))
                end
            end
            tup = ttag.tup
        else
            ASR(not tadt.tags, me, 'union data constructor requires a tag')
            tup = tadt.tup
        end

        local ok, msg = TP.contains(tup, params.tp)
        ASR(ok, me, msg)
    end,

    Isr = function (me)
        local id = unpack(me)
        ENV.isrs[id] = true
    end,

    Op2_call = function (me)
        local _, f, params, _ = unpack(me)
        me.tp  = f.var and f.var.fun and f.var.fun.out or TP.new{'@'}
        local id
        if f.tag == 'Nat' then
            id = f[1]
            me.c = ENV.c[id]
        elseif f.tag == 'Op2_.' then
            id = f.id
            if f.org then   -- t._f()
                me.c = assert(ENV.clss[TP.id(f.org.tp)]).c[f.id]
            else            -- _x._f()
                me.c = f.c
            end
        else
            id = (f.var and f.var.id) or '$anon'
            me.c = { tag='func', id=id, mod=nil }
        end

        ASR((not OPTS.c_calls) or OPTS.c_calls[id], me,
                'native calls are disabled')

        local ins = f.var and f.var.fun and f.var.fun.ins
        if ins then
            local ok, msg = TP.contains(ins, params)
            ASR(ok, me, msg)
        else
            for i, v in ipairs(params) do
                ASR(not TP.check(v.tp,'?'), me,
                    'wrong argument #'..i..' : cannot pass option values to native calls')
                ASR(v.tag~='Op1_&', me,
                    'wrong argument #'..i..' : cannot pass aliases to native calls')
                ASR(not TP.check(v.tp,'[]','-&','-..'), me,
                    'wrong argument #'..i..' : cannot pass plain vectors to native calls')
            end
        end

        if not me.c then
            me.c = { tag='func', id=id, mod=nil }
            ENV.c[id] = me.c
        end
        --ASR(me.c and me.c.tag=='func', me,
            --'native function "'..id..'" is not declared')

        ENV.calls[id] = true
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
        local tp_id = TP.id(arr.tp)

        if TP.check(arr.tp,'&&','-&') then
            ASR(TP.is_ext(arr.tp,'_','@'), me,
                'cannot index pointers to internal types', [[
    Indexing pointers is unsafe because of buffer overflows.
    You can either use a vector or an external type (e.g., `_char`).
]])
        end

        if not TP.is_ext(arr.tp,'_','@') then
            ASR(TP.check(arr.tp, '[]', '-&'), me,
            'cannot index a non array')
        end

        ASR(TP.isNumeric(idx.tp), me, 'invalid array index')

        -- remove [] or *
        local tp = TP.pop(arr.tp,'&')
        if TP.check(tp,'[]') then
            tp = TP.pop(tp, '[]')
        else
            tp = TP.pop(tp, '&&')
        end

        if ENV.v_or_ref(tp,'cls') then
            me.lval = false
        else
            me.lval = arr
        end
        me.tp = TP.new(tp)

        me.fst = arr.fst
        me.lst = arr.lst
    end,

    Op2_int_int = function (me)
        local op, e1, e2 = unpack(me)
        me.tp  = TP.new{'int'}
        ASR(TP.isNumeric(e1.tp,'&') and TP.isNumeric(e2.tp,'&'), me,
                'invalid operands to binary "'..op..'"')
    end,
    ['Op2_-']  = 'Op2_int_int',
    ['Op2_+']  = 'Op2_int_int',
    ['Op2_%']  = 'Op2_int_int',
    ['Op2_*']  = 'Op2_int_int',
    ['Op2_/']  = 'Op2_int_int',
    ['Op2_|']  = 'Op2_int_int',
    ['Op2_&']  = 'Op2_int_int',
    ['Op2_<<'] = 'Op2_int_int',
    ['Op2_>>'] = 'Op2_int_int',
    ['Op2_^']  = 'Op2_int_int',

    Op1_int = function (me)
        local op, e1 = unpack(me)
        me.tp = TP.new{'int'}
        ASR(TP.isNumeric(e1.tp), me,
                'invalid operand to unary "'..op..'"')
    end,
    ['Op1_~'] = 'Op1_int',
    ['Op1_-'] = 'Op1_int',
    ['Op1_+'] = 'Op1_int',

    ['Op1_?'] = function (me)
        local op, e1 = unpack(me)
        me.tp = TP.new{'bool'}
        ASR(TP.check(e1.tp,'?'), me, 'not an option type')
    end,
    ['Op1_!'] = function (me)
        local op, e1 = unpack(me)
        me.lval = e1.lval and e1

        local tp,ok = TP.pop(e1.tp, '?')
        ASR(ok, me, 'not an option type')
        me.tp = TP.new(tp)

        me.fst = e1.fst
        me.lst = e1.lst
    end,

    ['Op1_$'] = function (me)
        local op, e1 = unpack(me)
        ASR(TP.check(e1.tp,'[]','-&'), me,
            'invalid operand to unary "'..op..'" : vector expected')
        ASR(not (e1.var and e1.var.pre=='pool'), me,
            'invalid operand to unary "'..op..'" : vector expected')
        me.tp = TP.new{'int'}
        me.lval = op=='$' and e1
        me.fst = e1.fst
        me.lst = e1.lst
    end,
    ['Op1_$$'] = 'Op1_$',

    Op2_same = function (me)
        local op, e1, e2 = unpack(me)
        me.tp = TP.new{'int'}
        ASR(TP.max(e1.tp,e2.tp), me,
            'invalid operands to binary "'..op..'"')

        -- TODO: recurse-type
        -- TODO: remove these comments if nothing breaks after testing rocks/stl/on
        --if not (TP.check(e1.tp,'?') and e1.tp.ptr>0) then
            ASR(not ENV.adts[TP.tostr(e1.tp)], me, 'invalid operation for data')
        --end
        --if not (TP.check(e2.tp,'?') and e2.tp.ptr>0) then
            ASR(not ENV.adts[TP.tostr(e2.tp)], me, 'invalid operation for data')
        --end
    end,
    ['Op2_=='] = 'Op2_same',
    ['Op2_!='] = 'Op2_same',
    ['Op2_>='] = 'Op2_same',
    ['Op2_<='] = 'Op2_same',
    ['Op2_>']  = 'Op2_same',
    ['Op2_<']  = 'Op2_same',

    Op2_any = function (me)
        me.tp = TP.new{'int'}
        ASR(not ENV.adts[TP.tostr(me.tp)], me, 'invalid operation for data')
    end,
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',
    ['Op1_not'] = 'Op2_any',

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        me.lval = e1.lval and e1
        local tp_id = TP.id(e1.tp)

        local ok = false

        -- remove *
        local tp = TP.pop(e1.tp,'&')
        tp,ok = TP.pop(tp, '&&')

--[[
        -- pool L[]* l;
        -- pool L[]  l;     // also valid
        local is_adt_pool = ENV.adts[tp_id] and e1.var and e1.var.pre=='pool'
        if is_adt_pool then
            tp = TP.pop(tp, '[]')
            ok = true
        end
]]

        if not ok then
            --[[
                native do
                    typedef struct t {
                        int* x;
                    } t;
                end
                native @plain _t, _int_ptr;
                var _t       t = <...>
                var _int_ptr v = <...>
                await 1s;
                *t.x = <...>    // OK: "t" is plain, but accept nested pointers
                                // (more or less unsafe)
                *v   = <...>    // NO: "int_ptr" is said to be plain
                                // (unsafe)
            ]]
            local plain = (e1.tp.plain or TP.get(tp_id).plain)
                            and (e1.tag~='Op2_.')
            ASR(TP.is_ext(e1.tp,'_','@') and (not plain), me,
                'invalid operand to unary "*"')
        end

        me.tp  = TP.new(tp)
        me.fst = e1.fst
        me.lst = e1.lst
    end,

    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)

        -- ExpList in adt-constr
        ASR(me.__par.tag=='Set' or me.__par.tag=='ExpList' or me.__par.tag=='Return', me,
            'invalid use of operator "&" : not a binding assignment : (use "&&" for "address of")')

        -- refuses first assignment from constants and dereferences:
        -- var int& i = 1;      // constant
        -- var int& i = *p;     // dereference
        -- var D& d = D(...);   // adt-constr
        -- var int&? v;
        -- var int& i = &v;     // option
        -- ok:
        -- var _int[]& ref = vec;   // TP.check(e1.tp,'[]')
        ASR(TP.check(e1.tp,'&') or (e1.lval and (not TP.check(e1.tp,'?'))) or
            e1.tag=='Op1_&&' or e1.tag=='Op2_call' or TP.check(e1.tp,'[]') or
                (e1.lst and (e1.lst.tag=='Outer' or e1.lst.tag=='This' or
                             e1.lst.var and (e1.lst.var.cls or e1.lst.var.adt))),
                                               -- orgs/adts are not lval
            me, 'invalid operand to unary "&" : cannot be aliased')

        ASR(e1.tag ~= 'Op1_*', me,
            'invalid operand to unary "&" : cannot be aliased')

        if TP.check(e1.tp,'&') then
            me.tp = TP.copy(e1.tp)
        else
            me.tp = TP.push(e1.tp,'&')
        end
        me.lval = false
        me.fst = e1.fst
        me.lst = e1.lst
    end,

    ['Op1_&&'] = function (me)
        local op, e1 = unpack(me)

        ASR(not TP.check(e1.tp,'?'), me,
            'invalid operand to unary "&&"'..
            ' : option type')

        -- invalid: address of vector elements: &vec[i]
        if e1.tag == 'Op2_idx' then
            local _, arr, _ = unpack(e1)
            local cls = ENV.clss[TP.id(arr.tp)]
            if TP.check(arr.tp,'[]','-&') and (not (cls or TP.is_ext(arr.tp,'_','@'))) then
                -- accept if passing to a native call
                -- TODO: not checking if the function is really native
                -- TODO: not checking if in format (<cast>)&e
                if not AST.par(me,'ExpList') then
                    ASR(false, me, 'invalid operand to unary "&&"'..
                                   ' : vector elements are not addressable')
                end
            end
        end

        local e1_tp_id = TP.id(e1.tp)
        ASR(e1.lval or TP.check(e1.tp,'[]','-&') or
            ENV.clss[e1_tp_id] or ENV.adts[e1_tp_id], me,
            'invalid operand to unary "&&"')
        me.lval = false
        me.tp = TP.new(TP.push(TP.pop(e1.tp,'&'),'&&'))
        me.fst = e1.fst
        me.lst = e1.lst
        me.lst.amp = true
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)

        ASR(not TP.check(e1.tp,'?'), me,
            'invalid `.Â´ operation : cannot be an option type')

        local cls = ENV.v_or_ref(e1.tp, 'cls')
        local adt = ENV.v_or_ref(e1.tp, 'adt')
        local BLK, VAR
        me.id = id
        if cls then
            me.org = e1
            me.org.cls = cls

            if e1.tag == 'This' then
                -- accept private "body" vars
                BLK = cls.blk_body
                VAR = BLK.vars[id]
                    --[[
                    -- class T with
                    -- do
                    --     var int a;
                    --     this.a = 1;
                    -- end
                    --]]
            end
            if not VAR then
                local x = e1.tag=='Field' and e1[3].tag=='Var' and e1[3][1]=='$_out'
                BLK = me.blk_out or
                        (x and cls.blk_body) or
                            cls.blk_ifc
                      -- HACK_7
                VAR = ASR(ENV.getvar(id,BLK), me,
                        'variable/event "'..id..'" is not declared')
            end

            -- Op2_. => Field
            me.tag = 'Field'
            me.var  = VAR
            me.tp   = VAR.tp
            me.lval = VAR.lval
            VAR.isTmp = false

        elseif adt then
            local ID, op, blk = unpack(adt)

            if op == 'struct' then
                local var = ASR(blk.vars[id], me,
                            'field "'..id..'" is not declared')
                me.tp = var.tp
                me.lval = var
                --BLK, VAR = blk, var
                -- TODO
            else
                assert(op == 'union')
                local e1_tp = e1.tp
                if TP.check(e1.tp,TP.id(e1.tp),'[]','-&') then
                    e1_tp = TP.new{TP.id(e1.tp)}
                end

                local blk = ASR(adt.tags[id] and adt.tags[id].blk, me,
                                'tag "'..id..'" is not declared')

                ASR(TP.contains(e1_tp,TP.new{ID}), me,
                    'invalid access ('..TP.tostr(e1_tp)..' vs '..ID..')')

                -- [union.TAG]
                local tag = (me.__par.tag ~= 'Op2_.')
                if tag then
                    me.tp = TP.new{'bool'}
                    me.__env_tag = 'test'

                -- [union.TAG].field
                else
                    me.__env_tag = 'assert'
                    me.union_tag_blk = blk
                    --me.tp = blk
                    me.tp = TP.new{'void'}
                end
            end

                -- [union.TAG.field]
        elseif e1.union_tag_blk then
            local var = ASR(e1.union_tag_blk.vars[id], me,
                        'field "'..id..'" is not declared')
            me.__env_tag = 'field'
            me.tp = var.tp
            me.lval = var
            --BLK, VAR = e1.union_tag_blk, var
            -- TODO

        else
            assert(not e1.tp.tup)
            ASR(TP.is_ext(e1.tp,'_','@'), me, 'not a struct')
            -- rect.x = 1 (_SDL_Rect)
            me.tp = TP.new{'@'}
            local tp = TP.get(TP.id(e1.tp))
            if tp.plain and (not TP.check(e1.tp,'&&')) then
                me.tp = TP.new(TP.pop(me.tp,'&&'))
                me.tp.plain = true
            end
            me.lval = me--e1.lval
        end

        if VAR then
            local node = AST.node('Var', me.ln, '$'..id)
            node.var = VAR
            node.tp  = VAR.tp
            node.fst = node
            node.lst = node
            node.__ast_blk = BLK[1]
            me[3] = node
        end

        -- TODO: remove/simplify this if
        if me.tag == 'Field' then
            local op, e1, var = unpack(me)
            me.fst = e1.fst
            me.lst = var    -- org.var => var
        else
            local op, e1, id = unpack(me)
            me.fst = e1.fst
            me.lst = e1.lst
        end
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        me.lval = exp.lval

        if tp.tag == 'Type' then
            me.tp = tp
            if TP.check(tp,'&&','-&') then
                me.lval = exp      -- *((u32*)0x100)=v
            end
        else -- @annotation
            me.tp = exp.tp
            me[tp] = true
        end

        me.fst = exp.fst
        me.lst = exp.lst
        me.isConst = exp.isConst
    end,

    Vector_constr = function (me)
        me.lval = false
        -- append "..": constructor modifier
        for _, item in ipairs(me) do
            if item.tag == 'Vector_tup' then
                local v = AST.asr(item,'', 1,'ExpList')[1]
                if v then
                    me.tp = TP.push(TP.push(v.tp,'[]'),'..')
                    break
                end
            else
                if TP.check(item.tp,'char','&&') then
                    me.tp = TP.new{'char','[]','..'}
                else
                    me.tp = TP.push(TP.pop(item.tp,'&'),'..')
                end
                break
            end
        end
        if not me.tp then
            me.tp = TP.new{'any','[]'}
        end
        me.tp.arr = '[]'
        --ASR(false, me, 'invalid vector type')
    end,

    Nat = function (me)
        local id = unpack(me)
        local c = ENV.c[id] or {}
        me.id   = id
        me.tp   = TP.new{'@'}
        me.lval = me
        me.c    = c
    end,
    RawExp = function (me)
        me.tp   = TP.new{'@'}
        me.lval = me
    end,

    WCLOCKK = function (me)
        me.tp   = TP.new{'int'}
        me.lval = false
    end,
    WCLOCKE = 'WCLOCKK',

    SIZEOF = function (me)
        me.tp   = TP.new{'int'}
        me.lval = false
        me.isConst = true
    end,

    STRING = function (me)
        me.tp   = TP.new{'char','&&'}
        me.lval = false
        me.isConst = true
    end,
    NUMBER = function (me)
        local v = unpack(me)
        ASR(string.sub(v,1,1)=="'" or tonumber(v), me, 'malformed number')
        if string.find(v,'%.') or string.find(v,'e') or string.find(v,'E') then
            me.tp = TP.new{'float'}
        else
            me.tp = TP.new{'int'}
        end
        me.lval = false
        me.isConst = true
    end,
    NULL = function (me)
        me.tp   = TP.new{'null','&&'}
        me.lval = false
        me.isConst = true
    end,
    ANY = function (me)
        me.tp   = TP.new{'any'}
        me.lval = false
        me.isConst = true
    end,
}

AST.visit(F)

end

    
do
ADT = {}

-- attributions/constructors need access to the pool
-- the pool is the first "e1" that matches adt type:
-- l = new List.CONS(...)
-- ^-- first
-- l:CONS.tail = new List.CONS(...)
-- ^      ^-- matches, but not first
-- ^-- first
local function __find_pool (lst)
    local adt = ENV.adts[TP.id(lst.tp)]
    if lst.var then
        if adt and lst.var.pre=='pool' and TP.check(lst.tp,'[]','-&&','-&') then
            if lst.__par.tag == 'Field' then
                return lst.__par
            else
                return lst
            end
        else
            return nil
        end
    else
        assert(lst.__par, 'bug found')
        return ADT.find_pool(lst.__par)
    end
end
function ADT.find_pool (node)
    return __find_pool(node.lst)
end

F = {
    Dcl_adt = function (me)
        local id, op = unpack(me)

        -- For recursive ADTs, ensure valid base case:
        --  - it is the first in the enum
        --  - it has no parameters
        if op == 'union' then
            local base = me.tags[me.tags[1]].tup
            for _, tag in ipairs(me.tags) do
                local tup = me.tags[tag].tup
                AST.asr(tup, 'TupleType')
                for _, item in ipairs(tup) do
                    AST.asr(item, 'TupleTypeItem')
                end
            end
            if me.is_rec then
                ASR(#base == 0, base,
                    'invalid recursive base case : no parameters allowed')
            end
        end
    end,

    Adt_constr_root = function (me)
        local dyn, one  = unpack(me)
        local adt, _    = unpack(one)
        local id_adt, _ = unpack(adt)
        if ENV.adts[id_adt].is_rec then
            ASR(dyn, me,
                'invalid constructor : recursive data must use `newÂ´')
        end
    end,

    Set = function (me)
        local _, set, fr, to = unpack(me)
    
        if not (set=='adt-constr' or set=='adt-mut' or set=='adt-ref') then
            return      -- handled in env.lua
        end

        local adt = ASR(ENV.adts[TP.id(to.tp)], me,
                        'invalid attribution : destination is not a "data" type')
        if not adt.is_rec then
            assert(set == 'adt-constr')
            return  -- ignore non-adt or non-recursive-adt
        end

        if set == 'adt-ref' then
            local to_is_pool = ADT.find_pool(to)
            if to_is_pool then
                me[2] = 'adt-ref-pool'
            else
                me[2] = 'adt-ref-var'
            end

            ASR(TP.check(to.tp,'&') or TP.check(to.tp,'&&','-&'), me,
                'invalid attribution : destination is not a reference')

            -- TODO: incomplete
            if to.lst.__par.tag == 'Op2_.' then
                if to.lst.__par[2] == to.lst then
                    -- l.CONS.tail = <...>
                    ASR(false, me,
                        'invalid attribution : destination must be the root')
                end
            end

            -- T [] && &  =>  T
            local to_tp = TP.pop(TP.pop(TP.pop(to.tp,'&'),'&&'),'[]')
            local fr_tp = TP.pop(TP.pop(TP.pop(fr.tp,'&'),'&&'),'[]')
            local ok, msg = TP.contains(to_tp, fr_tp)
            ASR(ok, me, 'invalid attribution : reference : '..(msg or ''))

        elseif set == 'adt-constr' then
            ASR(ADT.find_pool(to), me, 'invalid attribution : not a pool')

-- TODO: no constructor to non-pool pointers
            if to.lst.var.pre == 'pool' then
                -- [OK]
                -- var pool[] L l;
                -- l = new (...)
                return
            elseif to.fst ~= to then
                -- [OK]
                -- var L* l = <...>;
                -- l:X.x = new (...)
                local ok, msg = TP.contains(to.tp,fr.tp)
                ASR(ok, me, msg)
                return
            else
                -- [NO]
                -- var L&& l = <...>;
                -- l = new (...)
error'bug found'
-- not reachable anymore, remove ASR
                ASR(false, me, 'invalid attribution : must assign to recursive field')
            end

        elseif set == 'adt-mut' then
             ASR(to.fst.var==fr.fst.var, me,
                'invalid attribution : mutation : cannot mix data sources')
            ASR(to.lst.var.pre == 'pool', me,
                'invalid attribution : mutation : cannot mutate from pointers')

            -- pool List[]&& l;
            -- [NO]: l = ...
            if TP.check(to.tp,'&&','-&') then
                if to.__par.tag ~= 'Op2_.' then     -- TODO: incomplete
                    ASR(false, me,
                        'invalid attribution : mutation : destination cannot be a pointer')
                end
            end

            -- [OK]: ptr  = l2.*
            -- [OK]: l1.* = l1.*
            -- [NO]: l1.* = l2.*
            ASR((TP.check(to.tp,'&&','-&') and to.lst.var==to.var) or
                 to.fst.var==fr.fst.var, me,
                'bug found') -- shouldn't be reachable, otherwise change to msg
                --'cannot mix recursive data sources')

            --  [OK]: "to" is prefix of "fr" (changing parent to a child)
            --      l = l.CONS.tail     // OK
            --      l.CONS.tail = l     // NO
            local to = AST.par({__par=to.fst},
                        function (me)
                            return TP.check(me.tp,'[]','-&&','-&')
                        end)
            local fr = AST.par({__par=fr.fst},
                        function (me)
                            return TP.check(me.tp,'[]','-&&','-&')
                        end)

            assert(to.var and fr.var, 'bug found')
            local ok = (to.var == fr.var)
            if to.__par.tag == 'Op1_*' then
                -- l:* = l:*
                assert(fr.__par.tag=='Op1_*', 'bug found')
                to = to.__par
                fr = fr.__par
            elseif fr.__par.tag == 'Op1_*' then
                -- l = l:*
                fr = fr.__par
            end

            -- see below
            local is_root = true

            -- skip while if already "not ok"
            while ok do
                if fr.__par.tag ~= 'Op2_.' then
                    -- l.CONS.tail = l
                    ok = false      -- end of fr
                    break
                elseif to.__par.tag ~= 'Op2_.' then
                    -- l = l:CONS.tail
                    ok = true       -- end of to
                    break
                else
                    -- at least on field in to:
                    -- l.* = ...
                    is_root = false
                end
                to = AST.asr(to.__par,'Op2_.')
                fr = AST.asr(fr.__par,'Op2_.')
                if to[3] ~= fr[3] then
                    -- l:TAG1.* = l:TAG2.*
                    ok = true       -- different tags
                    break
                else
                    to = AST.asr(to.__par,'Op2_.')
                    fr = AST.asr(fr.__par,'Op2_.')
                    if to[3] ~= fr[3] then
                        -- l:TAG.x = l:TAG.y
                        ok = true   -- different fields
                        break
                    end
                end
            end
            ASR(ok, me, 'cannot assign parent to child')

            -- pool List[]&& l;
            -- [NO]: *l = ...
            if TP.check(to.lst.var.tp,'&&','-&') then
                ASR((not is_root), me,
                    'invalid attribution : mutation : cannot mutate root of a reference')
            end

        else
            error'bug found'
        end
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)

        local adt = ENV.v_or_ref(e1.tp, 'adt')
        if adt then
            local ID, op, _ = unpack(adt)

            if op == 'union' then
                -- [union.TAG]
                local tag = (me.__par.tag ~= 'Op2_.')
                if tag then
                    if id==adt.tags[1] and (not me.__env_watching) then
                        for paror in AST.iter('ParOr') do
                            local var = paror.__adj_watching and
                                        paror.__adj_watching.lst and
                                        paror.__adj_watching.lst.var
                            if var and var==e1.lst.var then
                                local dot = e1.lst.__par.__par
                                if dot.tag=='Op2_.' and dot[3]==id then
                                    ASR(false, me,
                                        'ineffective use of tag "'..id..
                                        '" due to enclosing `watchingÂ´ ('..
                                        paror.ln[1]..' : '..paror.ln[2]..')')
                                end
                            end
                        end
                    end
                end
            end
        end
    end,
}

AST.visit(F)

end

    
do
local VARS_UNINIT = {}

function NODE2BLK (n)
    return n.fst and n.fst.blk or
           n.fst and n.fst.var and n.fst.var.blk or
           MAIN.blk_ifc
end

local function find_set_thread (v1)
    for set in AST.iter'Set' do
        if set[2] == 'thread' then
            return set
        end
    end
end

local SET_TARGET = {}

-- Avoids problems with multiple intialization assignments in nested ifs:
--      if <...> then
--          if <...> then
--              x = 1;      // count only 1 for outer
--          else
--              x = 2;      // count only 1 for outer
--          end
--      else
--          x = 3;
--      end
local IF_INITS = {}

F = {
    Dcl_pool = 'Dcl_var',
    Dcl_var = function (me)
        if me.var.id=='_ret'
        or me.var.id=='_out'
        or string.match(me.var.id, '^_+%d*$')   -- var t _;
        or me.var.__env_is_loop_var             -- loop i ... end
        or me.isEvery
        or (TP.check(me.var.tp,'[]') and        -- var int[] vec;
            (not TP.check(me.var.tp,'[]','&')))
        then
            -- no need for initialization
        elseif me.var.cls then -- var T t;
            -- no need for initialization
            F.__compound(me)
        else
            -- prioritize non-interface declarations
            local blk = AST.par(me,'BlockI')
            if blk then
                blk.__had = blk.__had or {}
                if blk.__had[me.var.id] then
                    if not me.isImp then
                        for old in pairs(VARS_UNINIT) do
                            if old.id == me.var.id then
                                VARS_UNINIT[old] = nil  -- remove existing isImp
                            end
                        end
                        VARS_UNINIT[me.var] = me
                    end
                else
                    VARS_UNINIT[me.var] = me
                end
                blk.__had[me.var.id] = true
            else
                VARS_UNINIT[me.var] = me
            end
        end

--[=[
        -- ensures that global "ref" vars are initialized
        local glb = ENV.clss.Global
        if glb and cls and cls.id=='Main' then
            local var = glb.blk_ifc.vars[me.var.id]
            if var then
                local set = me.__par and me.__par[1]==me and
                            me.__par[2] and me.__par[2].tag=='Set'
                ASR(set, me, 'missing initialization for global variable "'..var.id..'"', [[
    Global aliases must be bound on declaration.
]])
            end
        end
]=]
    end,

    Var = function (me)
        if not (me.var.pre=='var' or me.var.pre=='pool') then
            return
        end
        if me.__par.tag == 'SetBlock' then
            return  -- a = do <...> end;
        end
        if SET_TARGET[me.var] then
            return  -- im exactly the target of an assignment
        end
        if TP.check(me.var.tp,'?') then
            return  -- optional assignment
        end

        local constr = AST.par(me,'Dcl_constr')
        if constr and constr.cls==AST.par(me,'Dcl_cls') then
            return  -- recursive spawn
        end

        local dcl = VARS_UNINIT[me.var]

        for setblk in AST.iter'SetBlock' do
            local _,to = unpack(setblk)
            assert(to.var, 'bug found')
            if to.var == me.var then
                dcl = to.var.blk.vars[to.var.id].dcl
                break
            end
        end

        ASR(not dcl, me, dcl and
            'invalid access to uninitialized variable "'..me.var.id..'"'..
            ' (declared at '..dcl.ln[1]..':'..dcl.ln[2]..')', [[
    To access a variable, first assign to it.
    When using an `if-then-elseÂ´ to initialize a variable declared outside it,
    the `if-then-elseÂ´ can only serve this purpose and cannot perform extra
    accesses to the variable.
]])
    end,

    -- before access to "to" which I want to mark as initialized
    Set_bef = function (me, sub)
        local _, _, fr, to = unpack(me)
        if sub ~= to then
            return
        end
        local TO = (to.tag=='VarList' and to) or {to}
        for _, to in ipairs(TO) do
            to_ = (to.var and to) or
                  (to.fst==to.lst and to.fst.var and to.tag~='Op2_.' and to.fst)
            if to_ then
                local _, _, fr, _ = unpack(me)
                F.__Set_bef_one(me, fr, to_)
            end
        end
    end,
    __Set_bef_one = function (me, fr, to)
        SET_TARGET[to.var] = true

        local outermost_if = nil
        if VARS_UNINIT[to.var] then
            -- Unitialized variables being first-assigned in an "if":
            --      var int x;          // declared outside
            --      if <...> then
            --          x = <...>       // first-assigned inside
            --      else
            --          x = <...        // first-assigned inside>
            --      end
            -- We want to
            --  - check first-assignment in all branches
            --  - refuse accesses inside it (besides the first assignment)
            --
            do
                for if_ in AST.iter'If' do
                    if (if_.__depth < to.var.blk.__depth) then
                        break   -- var defined inside the if
                    end
                    local constr = AST.par(me,'Dcl_constr')
                    if constr and if_.__depth<constr.__depth then
                        break
                    end
                    outermost_if = if_
                    local _, t, f = unpack(if_)
                    local inits
                    if AST.isParent(t, me) then
                        inits = t.__ref_inits or {}
                        t.__ref_inits = inits
                    else
                        inits = f.__ref_inits or {}
                        f.__ref_inits = inits
                    end

                    if not IF_INITS[to] then
                        ASR(not inits[to.var], me,
                        'invalid extra access to variable "'..to.var.id..'"'..
                        ' inside the initializing `if-then-elseÂ´ ('..if_.ln[1]..':'..if_.ln[2]..')', [[
    When using an `if-then-elseÂ´ to initialize a variable declared outside it,
    the `if-then-elseÂ´ can only serve this purpose and cannot perform extra
    accesses to the variable.
]])
                        IF_INITS[to] = true
                    end
                    if not inits[to.var] then   -- 1st has priority
                        inits[to.var] = me  -- save stmt of the assignment of "me"
                    end
                end
                if outermost_if then
                    outermost_if.__ref_outermost = true
                end
            end
        end

        -- check aliases bindings/no-bindings
        if TP.check(to.tp,'&','-?') then
            if VARS_UNINIT[to.var] then
                -- first assignment has to use &var
                ASR(fr.tag == 'Op1_&', me,
                    'invalid attribution : missing alias operator `&Â´ on the right', [[
    The first attribution to an alias, declared with the modifier `&Â´, binds
    the right-hand location to the left-hand variable.
    The attribution expects the explicit alias operator `&Â´ in the righ-hand
    side to make explicit that it is binding the location and not the value.
]])

                -- check if aliased value has wider scope
                local fr_blk = NODE2BLK(fr)
                local to_blk = NODE2BLK(to)
                local to_org_blk
                if to.tag=='Field' and to[2].tag=='This' then
                    local constr = AST.par(me, 'Dcl_constr')
                    if constr then
                        local dcl = AST.par(constr, 'Dcl_var')
                        if dcl then
                            to_org_blk = dcl.var.blk
                        else
                            local spw = AST.par(constr, 'Spawn')
                            to_org_blk = spw[2].var.blk or MAIN.blk_body
                                            -- pool.blk
                        end
                    end
                end
                if to_org_blk then
                    local fr_id = (fr.fst and fr.fst.var and fr.fst.var.id)
                                    or '?'
                    ASR(to_org_blk.__depth >= fr_blk.__depth, me,
                        'invalid attribution : variable "'..fr_id..'" has narrower scope than its destination', [[
    The aliased variable (source) must have wider scope than alias variable
    (destination).
]])
                        -- NO:
                        -- var int& r;
                        -- do
                        --     var int v;
                        --     r = v;
                        -- end
                end
            else
                -- not-first assignment
                ASR(fr.tag ~= 'Op1_&', me,
                    'invalid attribution : variable "'..to.var.id..'" is already bound', [[
    Once an alias is first attributed, it cannot be rebound.
    Also, a declaration and corresponding initialization cannot be separated by 
    compound statements.
]])
            end
        end

        if not outermost_if then
            VARS_UNINIT[to.var] = nil

            -- associated "global" should also be uninited
            for var, dcl in pairs(VARS_UNINIT) do
                if AST.par(dcl,'Dcl_cls') == ENV.clss.Global then
                    if to.var.id == var.id then
                        VARS_UNINIT[var] = nil
                    end
                end
            end
        end
    end,

    If = function (me)
        local c, t, f = unpack(me)
        local var, stmt = next(F.__diff(t.__ref_inits,f.__ref_inits))
        ASR((not var) or TP.check(var.tp,'?'), stmt, var and
            'missing initialization for variable "'..(var.id or '?')..'" in the other branch of the `if-then-elseÂ´ ('..me.ln[1]..':'..me.ln[2]..')')
        if me.__ref_outermost then
            for var in pairs(t.__ref_inits or {}) do
                VARS_UNINIT[var] = nil
            end
        end
    end,
    __diff = function (A,B)
        local C = {}
        for k,v in pairs(A or {}) do
            C[k] = v
        end
        for k,v in pairs(B or {}) do
            if C[k] then
                C[k] = nil
            else
                C[k] = v
            end
        end
        return C
    end,

    _TMP_INIT_pre = function (me)
        -- HACK_9
        local var = unpack(me)
        VARS_UNINIT[var.var] = nil
        me.tag = 'Nothing'
        me[1] = nil
    end,

    SetBlock_pre = function (me)
        local _,to = unpack(me)
        local var = assert(to.var,'bug found')
        if VARS_UNINIT[var] then
            VARS_UNINIT[var] = nil
        else
            var.__ref_was_inited = true
        end
    end,

    Dcl_cls_pre = '__compound',
    ParEver_pre = '__compound',
    ParAnd_pre  = '__compound',
    Pause_pre   = '__compound',
    Async_pre   = '__compound',
    --Atomic_pre  = '__compound',
    Thread_pre  = '__compound',
    Loop_pre    = '__compound',
    Spawn_pre   = '__compound',
    Do_pre = function (me)
        if not me.__adj_is_do_org then
            F.__compound(me)
        end
    end,
    ParOr_pre = function (me)
        if not me.__adj_watching then
            F.__compound(me)
        end
    end,
    Loop_pre = function (me)
        if not me.isAwaitUntil then
            F.__compound(me)
        end
    end,
    __compound = function (me)
        for var,dcl in pairs(VARS_UNINIT) do
            local setblk = find_set_thread(var)
            if setblk and me.__depth>setblk.__depth then
                -- Statement is inside a block assignment to "v":
                --      var int v = do <...> end
                -- No problem because "v" cannot be accessed inside it.
            elseif AST.par(var.blk,'Dcl_cls') ~= AST.par(me,'Dcl_cls') then
                -- Statement is in another class declared inline:
                --      var int v;
                --      class with <...> do <...> end
                -- No problem because "v" cannot be accessed inside it.
            elseif TP.check(var.tp,'?') then
                -- initialization is not obligatory, but it is not
                -- considered first assignment either
                --  var int&? v;
                --  loop do
                --      v = &<...>;     // not first assignment
                --  end
                VARS_UNINIT[var] = nil
            else
                ASR(false, dcl, [[
uninitialized variable "]]..var.id..[[" crossing compound statement (]]..me.ln[1]..':'..me.ln[2]..[[)]],
[[
    All variables must be initialized before use.
    Also, a declaration and corresponding initialization cannot be separated by 
    compound statements.
    The exception are `if-then-elseÂ´ statements to alternative initializations.
]])
            end
        end
    end,

--- check function calls

    __check_params = function (me, ins, params, f)
        local old = VARS_UNINIT
        for i, param in ipairs(params) do
            -- f(<x>)
            --      becomes
            -- <var-in-ifc> = <x>
            local var = AST.node('Var', me.ln, '_')
            var.tp = ins.tup[i]
            var.lst = var
            var.var = {id=ins[i][3], blk=me, tp=var.tp}
            VARS_UNINIT[var.var] = me
            F.__Set_bef_one(me, param, var)
                -- TODO: error message: 'invalid argument #i : ...'
        end
        VARS_UNINIT = old
    end,
    Op2_call = function (me)
        local _, f, params, fin = unpack(me)
        if not (me.c and (me.c.mod=='@pure' or me.c.mod=='@nohold')) then
            local ins = f.var and f.var.fun and f.var.fun.ins
            if ins then
                req = F.__check_params(
                        me,
                        ins,
                        params,
                        f)
            end
        end

        -- all initialization is guaranteed
        --  var T t = T.constr(...)
        local constr = AST.par(me, 'Dcl_constr')
        if constr and f.var and f.var.fun and
            TP.check(f.var.fun.out, constr.cls.id)
        then
            VARS_UNINIT = {}
        end
    end,

--- check class constructors, i.e., if all uninit vars are inited

    BlockI_pre = function (me)
        if CLS() ~= ENV.clss.Global then
            me.__old = VARS_UNINIT
            VARS_UNINIT = {}
        end
    end,
    BlockI_pos = function (me)
        if CLS() ~= ENV.clss.Global then
            AST.par(me,'Dcl_cls').vars_uninit = VARS_UNINIT
            VARS_UNINIT = me.__old
        end
    end,

    Dcl_constr_pre = function (me, cls)
        cls = cls or me.cls
        me.__old = VARS_UNINIT
        VARS_UNINIT = {}
        for k,v in pairs(cls.vars_uninit) do
            VARS_UNINIT[k] = v
        end
    end,
    Dcl_constr_pos = function (me)
        for var,dcl in pairs(VARS_UNINIT) do
            ASR(TP.check(var.tp,'?'), me, [[
missing initialization for field "]]..var.id..[[" (declared in ]]..dcl.ln[1]..':'..dcl.ln[2]..')',
[[
    The constructor must initialize all variables (withouth default values)
    declared in the class interface.
]])
        end
        VARS_UNINIT = me.__old
    end,

    Dcl_fun_pre = function (me)
        local _, _, _, out, _, blk = unpack(me)
        local cls = CLS()
        if blk and TP.check(out,cls.id) then
            -- is a constructor body
            F.Dcl_constr_pre(me, cls)
        end
    end,
    Dcl_fun_pos = function (me)
        local _, _, _, out, _, blk = unpack(me)
        local cls = CLS()
        if blk and TP.check(out,cls.id) then
            -- is a constructor body
            F.Dcl_constr_pos(me)
        end
    end,

--- disable VARS_UNINIT in data type declarations

    Dcl_adt_pre = function (me)
        me.__old = VARS_UNINIT
        VARS_UNINIT = {}
    end,
    Dcl_adt_pos = function (me)
        VARS_UNINIT = me.__old
    end,
}

AST.visit(F)

end

    
do
local _ceu2c = { ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

--[[
-- cval: C value
--]]

F =
{
    Dcl_var = function (me)
        if me.var.pre=='var' then
            local is_arr = TP.check(me.var.tp,'[]','-&')
            if is_arr and TP.is_ext(me.var.tp,'_') then
                local arr = me.var.tp.arr
                ASR(type(arr)=='table' and arr.cval,
                    me, 'invalid array dimension')
            end
        end
    end,

    Op2_call = function (me)
        local _, f, ins = unpack(me)
        if not f.cval then
            return
        end
        local ps = {}
        for i, exp in ipairs(ins) do
            if not exp.cval then
                return
            end
            ps[i] = exp.cval
        end
        me.cval = f.cval..'('..table.concat(ps,',')..')'
    end,

    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        if e1.cval and e2.cval then
            me.cval = '('..e1.cval..ceu2c(op)..e2.cval..')'
        end
    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me)
        local op, e1 = unpack(me)
        if e1.cval then
            me.cval = '('..ceu2c(op)..e1.cval..')'
        end
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',
    ['Op1_+']   = 'Op1_any',
    ['Op1_not'] = 'Op1_any',

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        if tp.tag=='Type' and exp.cval then
            me.cval = '(('..TP.toc(tp)..')'..exp.cval..')'
        end
    end,

    RawExp = function (me)
        me.cval = unpack(me)
    end,

    Nat = function (me)
        me.cval = string.sub(me[1], 2)
    end,
    STRING = function (me)
        me.cval = me[1]
    end,
    NUMBER = function (me)
        me.cval = me[1]
    end,
    NULL = function (me)
        me.cval = '((void *)0)'
    end,
}

AST.visit(F)

end

    
do
TIGHT = false

function OR_all (me, t)
    t = t or me
    me.tl_awaits  = false
    me.tl_escapes = false
    me.tl_blocks  = false
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            me.tl_awaits  = me.tl_awaits  or sub.tl_awaits
            me.tl_escapes = me.tl_escapes or sub.tl_escapes
            me.tl_blocks  = me.tl_blocks  or sub.tl_blocks
        end
    end
end

function AND_all (me, t)
    t = t or me
    me.tl_awaits  = true
    me.tl_escapes = true
    me.tl_blocks  = true
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            me.tl_awaits  = me.tl_awaits  and sub.tl_awaits
            me.tl_escapes = me.tl_escapes and sub.tl_escapes
            me.tl_blocks  = me.tl_blocks  and sub.tl_blocks
        end
    end
end

function SAME (me, sub)
    me.tl_awaits  = sub.tl_awaits
    me.tl_escapes = sub.tl_escapes
    me.tl_blocks  = sub.tl_blocks
end

F = {
    Node_pre = function (me)
        me.tl_awaits  = false
        me.tl_escapes = false
        me.tl_blocks  = false
    end,
    Node = function (me)
        if not F[me.tag] then
            OR_all(me)
        end
    end,

    Stmts   = OR_all,

    ParEver = OR_all,
    ParAnd  = OR_all,
    ParOr   = AND_all,

    If = function (me)
        local c, t, f = unpack(me)
        AND_all(me, {t,f})
    end,

    Break = function (me)
        me.tl_blocks = true
    end,

    Loop = function (me)
        local max,iter,_,body = unpack(me)

        me.is_bounded = false
        if max then
            ASR(max.cval, me, '`loopÂ´ bound must be constant')
            me.is_bounded = true
        elseif iter then
            local tp_id = iter.tp and TP.id(iter.tp)
            me.is_bounded = (iter.cval or
                             iter.tag=='Op1_$$' or
                             iter.tp and (
                                 ENV.clss[tp_id] or
                                 ENV.adts[tp_id]))
        end

        SAME(me, body)
        local isTight = (not AST.iter(AST.pred_async)())
                            and (not body.tl_blocks)
                            and (not me.is_bounded)
        WRN(not isTight, me, 'tight loop')
        TIGHT = TIGHT or isTight
        me.tl_blocks = me.is_bounded or (body.tl_awaits or body.tl_escapes)

        local dcl = AST.iter'Dcl_fun'()
        if dcl and isTight then
            dcl.var.fun.isTight = true
        end
    end,

    SetBlock = function (me)
        local blk,_ = unpack(me)
        SAME(me, blk)
        me.tl_escapes = false
    end,
    Escape = function (me)
        me.tl_escapes = true
        me.tl_blocks  = true
    end,

    Thread = 'Async',
    Async = function (me)
        local _,body = unpack(me)
        SAME(me, body)
        me.tl_awaits = true
        me.tl_blocks = true
    end,

    Await = function (me)
        me.tl_awaits = true
        me.tl_blocks = true
    end,
    AwaitN = 'Await',

    --[[
    -- fin.isTight (for function declarations):
    --      - true      (body parsed and known to be recursive)
    --      - false     (body parsed and known to be not recursive)
    --      - 'maybe'   (body parsed, but calls body unparsed)
    --      - nil       (body unparsed)
    --]]
    Op2_call = function (me)
        local op, f, _ = unpack(me)

        if not (f.var and f.var.fun) then
            return  -- ignore native and pointer calls
        end

        -- if calling a tight (or unknown) function,
        --  then the top function is also tight
        local dcl = AST.par(me, 'Dcl_fun')
        if dcl then
            local matches_ifc = false
            local cls = AST.par(dcl,'Dcl_cls')
            for ifc in pairs(cls.matches) do
                if ifc==f.org.cls and dcl.var.id==f.var.id then
                    matches_ifc = true
                    break
                end
            end

            local f_cls = AST.par(f.var.blk,'Dcl_cls')
            local deps_on_unk_ifc = (f.var.fun.isTight==nil and f_cls.is_ifc)

            if (f.var.fun.isTight==true or f.var.fun.isTight=='maybe'
            or dcl.var.fun==f.var.fun or matches_ifc) then
                dcl.var.fun.isTight = true
                f.var.fun.isTight   = true
                ASR(dcl.var.fun.mod.rec == true,
                    dcl, 'function must be annotated as `@recÂ´ (recursive)')

                -- f must be re-checked after dcl completes
                dcl.__tight_calls = dcl.__tight_calls or {}
                dcl.__tight_calls[#dcl.__tight_calls+1] = f
            elseif f.var.fun.isTight==nil and (not deps_on_unk_ifc) then
                dcl.var.fun.isTight = 'maybe'
            else
                assert(f.var.fun.isTight==false or deps_on_unk_ifc)
                assert(dcl.var.fun.isTight == nil)      -- remains nil
            end
        end

        -- assert that the call is using call/rec correctly
        if f.var.fun.mod.rec then
            ASR(op=='call/rec',
                me, '`call/recÂ´ is required for "'..f.var.fun.id..'"')
        else
            ASR(op=='call',
                me, '`call/recÂ´ is not required for "'..f.var.fun.id..'"')
        end
    end,
    Dcl_fun = function (me)
        local _, rec, _, _, id, blk = unpack(me)
        if not blk then
            return          -- pure declarations
        end

        -- if I'm not discovered as tight or maybe, then I'm not tight
        if me.var.fun.isTight == nil then
            me.var.fun.isTight = false
        end
        if me.var.fun.isTight == true then
            ASR(me.var.fun.mod.rec == me.var.fun.isTight,
                me, 'function must be annotated as `@recÂ´ (recursive)')
            if me.__tight_calls then
                for _,f in ipairs(me.__tight_calls) do
                    ASR(f.var.fun.mod.rec == f.var.fun.isTight,
                        f.var.dcl, 'function must be annotated as `@recÂ´ (recursive)')
                end
            end
        elseif me.var.fun.isTight == false then
            WRN(me.var.fun.mod.rec == false,
                me, 'function may be declared without `recursiveÂ´')
        else
            assert(me.var.fun.isTight == 'maybe', 'bug found')
        end

        -- copy isTight to all matching interfaces with method "id"
        local matches = CLS().matches or {}
        for ifc in pairs(matches) do
            local var = ifc.blk_ifc.vars[id]
            if var then
                assert(var.fun)
                local t = var.fun.__tights or {}
                var.fun.__tights = t
                t[#t+1] = me.var.fun.isTight
            end
        end
    end,

    Root = function (me)
        -- check if all interface methods have "mod.rec"
        -- respecting their implementations
        for _, ifc in pairs(ENV.clss_ifc) do
            for _,var in ipairs(ifc.blk_ifc.vars) do
                if var.fun then
                    local t = var.fun.__tights or {}

                    -- If "rec", at least one implementation should
                    -- not be isTight.
                    if var.fun.mod.rec then
                        local ok = false
                        for _, isTight in ipairs(t) do
                            if isTight then
                                ok = true
                                break
                            end
                        end
                        WRN(ok, var.ln,
                            'function may be declared without `recursiveÂ´')

                    -- If not "rec", all implementations should be
                    -- isTight.
                    else
                        for _, isTight in ipairs(t) do
                            ASR((not isTight), var.ln,
                                'function must be annotated as `@recÂ´ (recursive)')
                        end
                    end
                end
            end
        end
    end,
}

AST.visit(F)

-- YIELD inside LOOPS:
--  - BAD for pointers
--  ptr = ...;
--  loop do             // works as await
--      *ptr = ...;     // crosses loop/await
--      await X;
--  end
--  - BAD for pool iterators
local E
E = {
    __await = function ()
        for loop in AST.iter'Loop' do
            loop.has_yield = true
        end
    end,
    EmitInt = '__await',
    Kill    = '__await',
    Spawn   = '__await',
    AwaitN  = '__await',
    Await   = function (me)
        if me.tl_awaits then
            E.__await(me)
        end
    end,
    Set = function (me)
        local _, set, fr, to = unpack(me)
        if set=='adt-mut' or set=='adt-constr' then
            local adt = assert(ENV.adts[TP.id(to.tp)], 'bug found')
            if adt.is_rec then
                me.has_yield = true
                E.__await(me)
            end
        end
    end,
}
AST.visit(E)

end

    
do
-- Track all declared pointers to assert that they are not accessed across
-- await statements:
local TRACK = {
    --[var] = true,   -- tracking but no await yet
    --[var] = await,  -- an "await" happened while tracking "var"
                      --   now, any access to "var" yields error
}

local function GET ()
    return TRACK[#TRACK]
end

local function JOIN (me)
    local TOP = GET()
    for T in pairs(me.__tojoin) do
        for k,v in pairs(T) do
            -- awaits have higher priority to catch more errors
            if type(TOP[k]) ~= 'table' then
                TOP[k] = v
            end
        end
    end
end

local function PUSH (me)
    local old = TRACK[#TRACK]
    local new = setmetatable({}, {__index=old})
    TRACK[#TRACK+1] = new
    if me then
        me.__tojoin[new] = true
    end
end
local function POP ()
    TRACK[#TRACK] = nil
end

function ISPTR (node_or_var)
    if node_or_var.tag == 'Adt_constr_root' then
        return false
    end

    local tp = node_or_var.tp
    local tp_id = TP.id(tp)

    -- type with '&&' anywhere
    for _, v in ipairs(tp.tt) do
        if v == '&&' then
            if ENV.clss[tp_id] and TP.check(tp,tp_id,'&&','?','-[]','-&') then
                -- skip [var T*? ptr], [var T*?[] ts]
            else
                return true
            end
        end
    end

    -- either native dcl or derived
    -- _SDL_Renderer&?: "_ext &?" should not be considered a pointer
    if TP.is_ext(tp,'_','@') and
       (not (TP.get(tp_id).plain or tp.plain or node_or_var['@plain'] or TP.check(tp,'&','?')))
    then
        if node_or_var.id == '_top_pool' then
            return false    -- TODO: should not be considered "is_ext"
        end
        return true
    end

    return false
end

F = {
    Dcl_cls_pre = function (me)
        me.__fin_straight = true
        PUSH()
    end,
    Dcl_cls_pos = function (me)
        POP()
    end,

    Set = function (me)
        local op, set, fr, to = unpack(me)
        to = to or AST.iter'SetBlock'()[1]

        -- TODO
        if set=='await' or set=='vector' then
            ASR(op == '=', me, 1103, 'wrong operator')
            return
        end

        local cls = CLS()

    --
    -- NON-POINTER ATTRIBUTIONS (always safe)
    --

        -- _r.x = (int) ...;
        if not (ISPTR(to) or TP.check(to.tp,'&','?')) or
           not (ISPTR(fr) or TP.check(TP.pop(fr.tp,'&'),'[]')) then
            ASR(op == '=', me, 1101, 'wrong operator')
            ASR(not me.fin, me, 1102, 'attribution does not require `finalizeÂ´')
            return
        end

    --
    -- POINTER ATTRIBUTIONS
    --

        -- an attribution restarts tracking accesses to "to"
        -- variables or native symbols
        if (to.var and (not TP.check(to.var.tp,'&'))) or to.c then
                        -- do not track references
-- TODO: repeated with Var?
            if to.var and ENV.clss[TP.id(to.var.tp)] then
                local old = GET()[to.var]
                -- do not restart in case of pointers to organisms
                GET()[to.var] = old or 'accessed'
            else
                GET()[to.var or to.id] = 'accessed'
            end
        end

        -- constants are safe
        if fr.sval then
            ASR(op == '=', me, 1103, 'wrong operator')
            ASR(not me.fin, me, 1104, 'attribution does not require `finalizeÂ´')
            return
        end

    -- NON-CONSTANT ATTRIBUTIONS

        -- determine "to_blk": block/scope for "to"
        local to_blk
        local constr = AST.iter'Dcl_constr'()
        if constr then
            -- var T t with
            --  this.x = y;     -- blk of this is the same as block of t
            -- end;
            -- spawn T with
            --  this.x = y;     -- blk of this is the same spawn pool
            -- end
            local dcl = AST.iter'Dcl_var'()
            if dcl then
                to_blk = dcl.var.blk
            else
                AST.asr(constr.__par, 'Spawn')
                local _,pool,_ = unpack(constr.__par)
                assert(assert(pool.lst).var)
                to_blk = pool.lst.var.blk
            end
        else
            -- block where variable is defined
            to_blk = NODE2BLK(to)
        end

        local fr_blk = NODE2BLK(fr)

    -- CHECK IF "FINALIZE" IS REQUIRED

        local func_ceu, func_impure, input_call = false, false, false
        local T = fr.lst
        if T then
            if T.tag == 'Op2_call' then
                local _, f = unpack(T)
                func_ceu = f and f.var and f.var.fun
                func_impure = not (T.c.mod=='@pure' or f['@pure'])
            elseif T.tag == 'EmitExt' then
                local op, ext, param = unpack(T)
                input_call = op=='call' and ext.evt.pre=='input'
            end
        end

        if me.fin then
            ASR( AST.isParent(cls, to_blk), me,
                'cannot finalize a variable defined in another class' )
            --  class T with
            --  do
            --      finalize
            --          _GLB = <...>
            --      with
            --          <...>
            --      end
            --  end
        end

        -- TODO: move to exp/ref.lua
        if (not func_ceu) and (func_impure or input_call or fr.tag=='RawExp') then
            -- We assume that a impure function that returns a global pointer
            -- creates memory (e.g. malloc, fopen):
            --      var void&? pa = _fopen();
            -- We assume that a RawExp that returns a global pointer
            -- creates memory (e.g. { new T }):
            --      var void&? pa = { new T() };
            -- In these cases, the return memory would persist when
            -- the local goes out of scope, hence, we require finalization.
            -- The "to" pointers must be option types `&?Â´.

            if TP.check(to.tp,'&','?') then
                T.__fin_opt_tp = to.tp  -- return value must be packed in the "&?" type
            else
                ASR(TP.id(to.tp)=='@', me, 1105,
                    'must assign to a option reference (declared with `&?Â´)')
                -- var void* ptr = _malloc(1);  // no
                -- _ptr = _malloc(1);           // ok
            end

            ASR(me.fin, me, 'attribution requires `finalizeÂ´')
                -- var void&? ptr = _malloc(1);
            if me.fin and me.fin.active then
                to_blk.fins = to_blk.fins or {}
                table.insert(to_blk.fins, 1, me.fin)
            end
            return
        end
        ASR(not me.fin, me, 'attribution does not require `finalizeÂ´')


    -- REFUSE THE FOLLOWING POINTER ATTRIBUTIONS:
        -- to pointers inside organisms (e.g., org.x=y)
        -- to pointers with greater scope than source
    -- (CHECK IF ":=" IS REQUIRED)

        -- refuse "org.x=y", unless "this" (inside constructor or not)
        -- "this" is easy to follow inside the single body
        -- other assignments are spread in multiple bodies
--[[
        if to.org and to.fst.tag~='This' then
            ASR(op==':=', me,
                'organism pointer attribution only inside constructors')
                -- var T t;
                -- t.v = null;

        else
]]
            -- OK: "fr" is a pointer to org (watching makes it safe)
            -- OK: "fr" `&Â´ reference has bigger scope than "to"
            -- int a; int* pa; pa=&a;
            -- int a; do int* pa; pa=&a; end
-- TODO: this code is duplicated with "ref.lua"
            local to_tp_id = TP.id(to.tp)
            if not (
                fr.isConst                 or -- constants are globals
                fr.fst.tag == 'Nat'        or -- natives are globals
                (fr.tag=='Op2_call' and       -- native calls are globals
                 fr[2].fst.tag=='Nat')     or
                AST.iter'Dcl_constr'()     or -- org bodies can't hold
                (fr.org and                   -- "global:*" is global
                 fr.org.cls.id=='Global')  or
                (ENV.clss[to_tp_id] and       -- organisms must use "watching"
                 fr.tag~='Op1_&&')         or -- (but avoid &org)
                (ENV.adts[to_tp_id] and       -- adts must use "watching"
                 fr.tag~='Op1_&&')         or -- (but avoid &adt)
                (   -- same class and scope of "to" <= "fr"
                    (AST.par(to_blk,'Dcl_cls') == AST.par(fr_blk,'Dcl_cls')) and
                        (   to_blk.__depth >= fr_blk.__depth            -- to <= fr
                        or (to_blk.__depth==cls.blk_ifc.__depth and     --    or
                            fr_blk.__depth==cls.blk_body.__depth)       -- ifc/bdy
                        )
                )
            ) then
                ASR(op==':=', me, 'attribution to pointer with greater scope')
                    -- NO:
                    -- var int* p;
                    -- do
                    --     var int i;
                    --     p = &i;
                    -- end
            else
                ASR(op=='=', me, 'wrong operator')
            end
        --end

    -- FORCE @hold FOR UNSAFE ATTRIBUTIONS INSIDE FUNCTIONS

        local fun = AST.iter'Dcl_fun'()
        if op==':=' and fun and                          -- unsafe attribution
           (to_blk==cls.blk_ifc or to_blk==cls.blk_body) -- inside a function
        then                                             -- to ifc/body field
            -- must be hold
            local _, _, ins, _, _, _ = unpack(fun)
            -- functions/methods that hold pointers
            -- must annotate those arguments
            ASR(ins[fr.lst.var.funIdx][1], me, 1106, 'parameter must be `holdÂ´')
                -- function (void* v)=>void f do
                --     _V := v;
                -- end
                -- class T with
                --     var void* a;
                -- do
                --     function (void* v)=>void f do
                --         this.a := v;
                --     end
                -- end
        end
    end,

    Return = function (me)
        local exp = unpack(me)
        local dcl = AST.par(me, 'Dcl_fun')
        if not dcl then
            return  -- checked in props.lua
        end

        -- return <x>
        --      becomes
        -- <var-in-ifc> = <x>
        local var = AST.node('Var', me.ln, '_')
        var.tp = dcl.var.fun.out
        var.var = {blk=CLS().blk_ifc, tp=var.tp}
        --F.Set(AST.node('Return', me.ln, '=', 'set', exp, var))
    end,

    Dcl_pool = 'Dcl_var',
    Dcl_var = function (me)
        if AST.par(me,'BlockI') then
            F.Var(me)
        end
    end,
    Var = function (me)
        if not ISPTR(me.var) then
            return
        end
        if me.var.pre=='function' then
            return
        end

        -- re-setting variable
        local set = AST.par(me,'Set')
        local to  = set and set[4]
        if to and AST.isParent(to,me) then
            local ok = (to==me)
            ok = ok or (to.tag=='Field' and to.var==me.var)
            ok = ok or (to.tag=='VarList' and AST.isParent(to, me))
            if ok then
-- TODO: repeated with Set?
                if ENV.clss[TP.id(me.var.tp)] then
                    local old = GET()[me.var]
                    -- do not restart in case of pointers to organisms
                    GET()[me.var] = old or 'accessed'
                else
                    GET()[me.var] = 'accessed'
                end
                --GET()[me.var] = 'accessed'
                -- set[4] is VarList or Var
                return
            end
        end
        if AST.par(me,'Dcl_constr') and me.__par.fst.tag=='This' then
            return  -- constructor access
        end

        local loop = AST.par(me, 'Loop')
        local ext  = AST.get(loop,'Loop', 4,'Stmts', 1,'Set', 3,'Await', 1,'Ext')
        if loop and loop.isAwaitUntil and ext and ext[1]=='_ok_killed' then
-- TODO: bug: what if the "o" expression contains other pointers?
            return  -- o'=await o until o==o'
        end

        -- access to pointer defined in variable outside the class boundary
        local cls = CLS()
        local acc = GET()[me.var]
        if (not acc) and (not AST.isParent(cls,me.var.blk)) then
            acc = cls
        end

        if type(acc) ~= 'table' then
            GET()[me.var] = 'accessed'
            return  -- no await happened yet
        end

        -- access in the beginning of recursive class
        -- check if enclosing par/or is a "watching me.var"
        -- if so, this access is safe
        if acc.tag == 'Dcl_cls' then
            for paror in AST.iter('ParOr') do
                if paror and AST.isParent(paror[1],me) then
                    local var = paror.__adj_watching and 
                                                     paror.__adj_watching.lst
                                                     and paror.__adj_watching.lst.var
                    if var and var==me.var then
                        -- sets all accesses to "me.var" in the recursive class
                        -- table (acc.GET) to point to the "watching"
                        -- (so that they become child of it)
                        acc.GET[me.var] = paror

                        -- make this access safe
                        acc = paror
                    end
                end
            end
        end

        -- possible dangling pointer "me.var" is accessed across await

        local tp_id = TP.id(me.tp)
        if (ENV.clss[tp_id] or ENV.adts[tp_id]) then
            -- pointer to org: check if it is enclosed by "watching me.var"
            -- since before the first await
            for paror in AST.iter('ParOr') do
                local var = paror.__adj_watching and paror.__adj_watching.lst
                                                 and paror.__adj_watching.lst.var
                if var==me.var and AST.isParent(paror,acc) then
                    return      -- ok, I'm safely watching "me.var"
                end
            end
        end

        -- invalid access!
        local acc_id = assert(AST.tag2id[acc.tag], 'bug found')
        ASR(false, me, 1107,
            'unsafe access to pointer "'..me.var.id..'" across `'..
                acc_id..'Â´ ('..acc.ln[1]..' : '..acc.ln[2]..')')
    end,

    __await = function (me)
        CLS().__fin_straight = false
        for _, T in ipairs(TRACK) do        -- search in all levels
            for var, v in pairs(T) do
                if v == 'accessed' then
                    GET()[var] = me   -- tracks the *first* await
                end
            end
        end
        GET()['_'] = me
    end,
    EmitInt = '__await',
    Kill    = '__await',

    Set_pos = function (me)
        if me.has_yield then
            F.__await(me)  -- 'adt-mut/constr'
        end
    end,

    Spawn = function (me)
        if me.cls.is_traverse and me.cls.__fin_straight then
            return
        else
            F.__await(me)
        end
    end,

    Await = function (me)
        local loop = AST.par(me,'Loop')
        if loop and loop.isAwaitUntil then
            --  await E until ptr==<...>
            -- becomes
            --  loop do
            --      ptr = await E;
            --      if ptr==<...> then
            --          break;
            --      end
            --  end
            --
            --  "ptr" can be used until after the loop
            return
        end

        if me.tl_awaits or me.has_yield then
            if me.__env_org then
                local id = TP.id(me.__env_org.tp)
                if ENV.clss[id].__fin_straight then
                    return
                end
            end
            F.__await(me)
        end
    end,
    AwaitN   = 'Await',
    Async_pre  = 'Await',
    Thread_pre = 'Await',

    Loop_bef = function (me, sub, i)
        -- skip iter exp (loop i in <exp> do ... end)
        if i==3 or (i<3 and i==#me) then
            if not me.isAwaitUntil then
                F.Await(me)
            end
        end
    end,

    Finalize_pre = function (me, set, fin)
        if not fin then
            set, fin = unpack(me)
        end
        AST.asr(fin[1],'Block', 1,'Stmts')
        fin.active = (#fin[1][1]>1 or
                      fin[1][1][1] and fin[1][1][1].tag~='Nothing')

        if AST.par(me,'Dcl_constr') then
            ASR(not fin.active, me, 1108,
                    'constructor cannot contain `finalizeÂ´')
        end
        if AST.par(me,'Dcl_fun') then
            ASR(not fin.active, me,
                    'function cannot contain `finalizeÂ´')
        end

        if set then
            -- EmitExt changes the AST
            if set.tag=='Block' then
                set = set[1][2] -- Block->Stmt->Set
            end
            set.fin = fin                   -- let call/set handle
        elseif fin.active then
            local blk = AST.iter'Block'()
            blk.fins = blk.fins or {}
            table.insert(blk.fins, 1, fin)  -- force finalize for this blk
        end
    end,

    Op2_call_pre = function (me)
        local _, f, exps, fin = unpack(me)
        if fin then
            F.Finalize_pre(me, me, fin)
        end
    end,

    __check_params = function (me, ins, params, f)
        local req = false
        for i, param in ipairs(params) do
            local hold = true
            if ins then
                hold = ins.tup[i].hold
            end
            if hold then
                -- int* pa; _f(pa);
                --  (`paÂ´ termination must consider `_fÂ´)
                local r = (ISPTR(param) or TP.check(TP.pop(param.tp,'&'),'[]')) and
                          (not param.isConst) and
                          (not param.c or param.c.mod~='const')
                                -- except constants

                r = r and param.fst and param.fst.blk or
                    r and param.fst and param.fst.var and param.fst.var.blk
                            -- need to hold block
                WRN( (not r) or (not req) or (r==req),
                        me, 'invalid call (multiple scopes)')
                req = req or r

                -- f(<x>)
                --      becomes
                -- <var-in-ifc> = <x>
                if ins then
                    local var = AST.node('Var', me.ln, '_')
                    var.tp = ins.tup[i]
                    var.var = {blk=AST.par(f,'Dcl_cls').blk_ifc, tp=var.tp}
                    F.Set(AST.node('Return', me.ln, '=', 'set', param, var))
                end
            end
        end
        return req
    end,

    Op2_call = function (me)
        local _, f, params, fin = unpack(me)

        local req = false

        if not (me.c and (me.c.mod=='@pure' or me.c.mod=='@nohold' or f['@nohold'] or f['@pure'])) then
            req = F.__check_params(
                    me,
                    f.var and f.var.fun and f.var.fun.ins,
                    params,
                    f)
        end

        -- TODO: should yield error if requires finalize and is inside Thread?
        if AST.iter'Thread'() then
            req = false     -- impossible to run finalizers on threads
        end

        ASR((not req) or fin or AST.iter'Dcl_fun'(), me, 1109,
            'call requires `finalizeÂ´')
        ASR((not fin) or req, me, 1110, 'invalid `finalizeÂ´')

        if fin and fin.active then
            req.fins = req.fins or {}
            table.insert(req.fins, 1, fin)
        end
    end,

    ParEver_pre = function (me)
        me.__tojoin = {}
    end,
    ParEver_pos = function (me)
        JOIN(me)
    end,
    ParEver_bef = function (me)
        PUSH(me)
    end,
    ParEver_aft = function (me)
        POP()
    end,
    ParAnd_pre = 'ParEver_pre',
    ParAnd_bef = 'ParEver_bef',
    ParAnd_aft = 'ParEver_aft',
    ParAnd_pos = 'ParEver_pos',
    ParOr_pre  = 'ParEver_pre',
    ParOr_bef  = 'ParEver_bef',
    ParOr_aft  = 'ParEver_aft',
    ParOr_pos  = 'ParEver_pos',

    -- skip condition (i>1)
    If_bef = function (me, _, i)
        if i > 1 then
            PUSH(me)
        end
    end,
    If_aft = function (me, _, i)
        if i > 1 then
            POP()
        end
    end,
    If_pre = 'ParEver_pre',
    If_pos = 'ParEver_pos',
}

AST.visit(F)

--[[
-- EVENTS:
--
-- The event emitter may pass a pointer that is already out of scope when the
-- awaking trail uses it:
--
-- event void* e;
-- var void* v = await e;
-- await ...;   // v goes out of scope
-- *v;          // segfault
--
-- We have to force the receiving "v" to go out of scope immediatelly:
--
--  event void* e;
--  do
--      var void* v = await e;
--      await ...;   // ERROR: cannot inside the "v" enclosing do-end
--      *v;
--  end
--
-------------------------------------------------------------------------------
--
-- FUNCTIONS:
--
-- When holding a parameter, a function could do either on native globals
-- or on object fields:
--
--      function (void* v1, void* v2)=>void f do
--          this.v = v1;    // OK
--          _V     = v2;    // NO!
--      end
--
-- For object fields, the caller must write a finalizer only if the
-- parameter has a shorter scope than the object of the method call:
--
--      // w/o fin
--      var void* p;
--      var T t;
--      t.f(p);     // t == p (scope)
--
--      // w/ fin
--      var T t;
--      do
--          var void* p;
--          t.f(p)      // t > p (scope)
--              finalize with ... end;
--      end
--
-- Native globals should be forbidden because we would need two different
-- kinds of "nohold" annotations to distinguish the two scopes (object and
-- global).
--
-- Native globals can be assigned in static functions requiring finalizer
-- whenever appliable.
]]

end

    
do
PROPS = {
    has_exts    = false,
    has_wclocks = false,
    has_ints    = false,
    has_asyncs  = false,
    has_threads = false,
    has_isrs    = false,
    has_orgs    = false,
    has_ifcs    = false,
    has_clear   = false,
    has_stack_clear = false,
    has_pses    = false,
    has_ret     = false,
    has_lua     = false,
    has_orgs_await = false,
    has_adts_await = {},
    has_enums   = false,

    has_vector        = false,
    has_vector_pool   = false,
    has_vector_malloc = false,

    has_orgs_news        = false,
    has_orgs_news_pool   = false,
    has_orgs_news_malloc = false,
    has_adts_news        = false,
    has_adts_news_pool   = false,
    has_adts_news_malloc = false,
}

local NO_atomic = {
    Finalize=true, Finally=true,
    Host=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true, EmitExt=true,
    Pause=true,
    -- TODO:
    Loop=true, Break=true, Escape=true,
}

local NO_fun = {
    --Finalize=true, Finally=true,
    Host=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true, --EmitExt=true,
    Pause=true,
    Spawn=true,
}

local NO_fin = {
    Finalize=true, Finally=true,
    Host=true, Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true,
    Pause=true,
    Kill=true,
}

local NO_async = {
    Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true,
    Pause=true,
    Escape=true,
    Finalize=true,
    This=true,
}

local NO_isr = {
    Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true,
    Pause=true,
    Escape=true,
    Finalize=true,
    Atomic=true,
    This=true,
}

local NO_thread = {
    Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true, EmitExt=true,
    Pause=true,
    Escape=true,
    Finalize=true,
    This=true,
}

local NO_constr = {
    --Finalize=true, Finally=true,
    Escape=true, Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true,
    Pause=true,
}

-- Loop, SetBlock may need clear
-- if break/return are in parallel w/ something
--                  or inside block that needs_clr
function NEEDS_CLR (top)
    for n in AST.iter() do
        if n.tag == top.tag then
            break
        elseif n.tag == 'ParEver' or
               n.tag == 'ParAnd'  or
               n.tag == 'ParOr'   or
               n.tag == 'Block' and n.needs_clr then
            PROPS.has_clear = true
            PROPS.has_stack_clear = true
            top.needs_clr = true
            break
        end
    end
end

function PARENTS_SET_FIELD (upto, field)
    for n in AST.iter() do
        if n == upto then
            break
        end
        if n.tag == 'Block'    or
           n.tag == 'ParOr'    or
           n.tag == 'Loop'     or
           n.tag == 'SetBlock' then
            n[field] = true
        end
    end
end

F = {
    Node_pre = function (me)
        if NO_atomic[me.tag] then
            ASR(not AST.par(me,'Atomic'), me,
                'not permitted inside `atomicÂ´')
        end
        if NO_fun[me.tag] then
            ASR(not AST.par(me,'Dcl_fun'), me,
                'not permitted inside `functionÂ´')
        end
        if NO_fin[me.tag] then
            ASR(not AST.par(me,'Finally'), me,
                'not permitted inside `finalizeÂ´')
        end
        if NO_async[me.tag] then
            ASR(not AST.par(me,'Async'), me,
                    'not permitted inside `asyncÂ´')
        end
        if NO_thread[me.tag] then
            ASR(not AST.par(me,'Thread'), me,
                    'not permitted inside `threadÂ´')
        end
        if NO_isr[me.tag] then
            ASR(not AST.par(me,'Isr'), me,
                    'not permitted inside `async/isrÂ´')
        end
        if NO_constr[me.tag] then
            ASR(not AST.par(me,'Dcl_constr'), me,
                    'not permitted inside a constructor')
        end
    end,

    Block_pre = function (me)       -- _pre: break/return depends on it
        if me.fins then
            me.needs_clr = true
            me.needs_clr_fin = true
            PROPS.has_clear = true
        end

        for _, var in ipairs(me.vars) do
            local tp_id = TP.id(var.tp)
            if var.cls then
                me.needs_clr = true
                me.has_orgs = true
            end
            if var.pre == 'var' then
                if ENV.clss[tp_id] and TP.check(var.tp,tp_id,'&&','?','-[]') then
                    me.needs_clr = true
                    PROPS.has_orgs_await = true
                end

                if TP.check(var.tp,'[]','-&') and (not TP.is_ext(var.tp,'_')) then
                    PROPS.has_vector = true
                    if not TP.check(var.tp,'&') then
                        me.needs_clr = true
                        PROPS.has_clear = true
                    end
                    if var.tp.arr.cval then
                        PROPS.has_vector_pool   = true
                    else
                        PROPS.has_vector_malloc = true
                    end
                end
            elseif var.pre == 'pool' then
                local s
                if ENV.clss[tp_id] or tp_id=='_TOP_POOL' then
                    s = 'orgs'
                else
                    me.needs_clr = true
                    PROPS.has_clear = true
                    s = 'adts'
                end
                PROPS['has_'..s..'_news'] = true
                if TP.check(var.tp,'[]') then
-- TODO: recurse-type
                    --if var.tp[#var.tp.tt]==true then
                    if var.tp.arr=='[]' then
                        PROPS['has_'..s..'_news_malloc'] = true  -- pool T[] ts
                    else
                        PROPS['has_'..s..'_news_pool'] = true    -- pool T[N] ts
                    end
                end
            end
        end

        local top = CLS()
        if me.needs_clr then
            PARENTS_SET_FIELD(top, 'needs_clr_fin')  -- TODO (-ROM): could avoid ors w/o fins
            PROPS.has_stack_clear = true
        end
        if me.has_orgs then
            PARENTS_SET_FIELD(top, 'has_orgs')
        end
    end,
    Spawn = function (me)
        local _,pool,_ = unpack(me)
        --me.blk.needs_clr = true   (var.cls does this)
        ASR(not AST.par(me,'BlockI'), me,
                'not permitted inside an interface')
    end,

    Dcl_adt = function (me)
        if me.is_rec then
            PROPS.has_clear = true
            PROPS.has_adts_news = true
        end
    end,
    Dcl_pool = function (me)
        local pre, tp, id, constr = unpack(me)
        local tid = tp[1]
        local is_unbounded = (tp[2]=='[]')
        if ENV.clss[tid] then
            PROPS.has_orgs_news = true
            if is_unbounded then
                PROPS.has_orgs_news_malloc = true       -- pool T[]  ts
            else
                PROPS.has_orgs_news_pool = true         -- pool T[N] ts
            end
        elseif ENV.adts[tid] then
            if is_unbounded then
                PROPS.has_adts_news_malloc = true       -- pool T[]  ts
            else
                PROPS.has_adts_news_pool = true         -- pool T[N] ts
            end
        end
    end,

    ParOr = function (me)
        me.needs_clr = true
        PROPS.has_clear = true
        PROPS.has_stack_clear = true
    end,

    Loop_pre = function (me)
        me.brks = {}

        if me.iter_tp == 'org' then
            ASR(not me.has_yield, me,
                'pool iterator cannot contain yielding statements (`awaitÂ´, `emitÂ´, `spawnÂ´, `killÂ´)')
        end
    end,
    Break = function (me)
        local loop = AST.par(me,'Loop')
        ASR(loop, me, '`breakÂ´ without loop')
        loop.brks[me] = true
        loop.has_break = true

        NEEDS_CLR(loop)

        local fin = AST.par(me, 'Finally')
        ASR((not fin) or AST.isParent(fin, loop), me,
                'not permitted inside `finalizeÂ´')

        ASR(not loop.isEvery, me,
                'not permitted inside `everyÂ´')

        local async = AST.iter(AST.pred_async)()
        if async then
            local loop = AST.iter'Loop'()
            ASR(loop.__depth>async.__depth, me, '`breakÂ´ without loop')
        end
    end,

    SetBlock_pre = function (me)
        me.rets = {}
        ASR(not AST.par(me,'BlockI'), me,
                'not permitted inside an interface')
    end,
    Escape = function (me)
        local blk = AST.par(me, 'SetBlock')
        blk.rets[me] = true
        blk.has_escape = true

        local fun = AST.par(me, 'Dcl_fun')
        if fun then
            ASR(blk.__depth > fun.__depth, me,
                    'not permitted across function declaration')
        end

        local fin = AST.par(me, 'Finally')
        if fin then
            ASR(AST.isParent(fin, blk), me,
                'not permitted inside `finalizeÂ´')
        end

        local evr = AST.iter(function (me) return me.tag=='Loop' and me.isEvery end)()
        if evr then
            ASR(AST.isParent(evr,blk), me,
                    'not permitted inside `everyÂ´')
        end

        NEEDS_CLR(blk)
    end,

    Return = function (me)
        ASR(AST.iter'Dcl_fun'(), me,
                'not permitted outside a function')
    end,

    Outer = function (me)
        ASR(AST.par(me,'Dcl_constr'), me,
            '`outerÂ´ can only be unsed inside constructors')
    end,

    Dcl_cls = function (me)
        if me.id ~= 'Main' then
            PROPS.has_orgs  = true
            PROPS.has_clear = true
        end
        if me.is_ifc then
            PROPS.has_ifcs = true
        end
    end,

    Dcl_ext = function (me)
        PROPS.has_exts = true

        local _,_,ins,_,_ = unpack(me)
        for _, item in ipairs(ins) do
            local _,tp,_ = unpack(item)
            for _, v in ipairs(tp.tt) do
                if v == '[]' then
                    PROPS.has_vector = true
                end
            end
        end
    end,

    Dcl_var = function (me)
        if AST.par(me, 'BlockI') then
            --ASR(not TP.check(me.var.tp,'[]') or TP.is_ext(me.var.tp,'_','@'), me,
                --'not permitted inside an interface : vectors')
            ASR(not me.var.cls, me,
                'not permitted inside an interface : organisms')
            if TP.check(me.var.tp,'?') then
                CLS().has_pre = true   -- code for pre (before constr)
            end
            if TP.check(me.var.tp,'[]') then
                CLS().has_pre = true   -- code for pre (before constr)
            end
        end
    end,

    Async = function (me)
        PROPS.has_asyncs = true
    end,
    Thread = function (me)
        PROPS.has_threads = true
    end,
    Isr = function (me)
        PROPS.has_isrs = true
    end,

    Pause = function (me)
        PROPS.has_pses = true
    end,

    Nothing = function (me)
        -- detects if "watching" an org/adt
        local watch = me.__env_watching
        if watch then
            if watch == true then
                PROPS.has_orgs_await = true
            else
                PROPS.has_adts_await[watch] = true
                for id in pairs(ENV.adts[watch].subs or {}) do
                    PROPS.has_adts_await[id] = true
                end
            end
        end
    end,

    _loop1 = function (me)
        for loop in AST.iter'Loop' do
            if loop.isEvery then
                ASR(me.isEvery, me,
                    '`everyÂ´ cannot contain `awaitÂ´')
            end
        end
    end,

    Await = function (me)
        local e, dt = unpack(me)
        if e.tag ~= 'Ext' then
            PROPS.has_ints = true
        elseif dt then
            PROPS.has_wclocks = true
        end

        if e.tag=='Ext' and e[1]=='_ok_killed' then
            return
        else
            F._loop1(me)
        end
    end,
    AwaitN = function (me)
        F._loop1(me)
    end,

    EmitInt = function (me)
        PROPS.has_ints = true
    end,

    EmitExt = function (me)
        local op, ext = unpack(me)
        if ext.evt.pre=='input' and op~='call' then
            ASR(AST.par(me,'Async') or AST.par(me,'Isr'),
                me, 'invalid `'..op..'Â´')
                    -- no <emit I> on sync
        end

        if AST.par(me,'Dcl_fun') then
            ASR(op=='call', me, 'invalid `emitÂ´')
        end
    end,

    Set = function (me)
        local _, set, fr, to = unpack(me)
        local thr = AST.par(me, 'Thread')
        if thr and (not to) then
            ASR( thr.__depth <= AST.iter'SetBlock'().__depth+1, me,
                    'invalid access from `threadÂ´')
        end

        if AST.par(me,'BlockI') then
            CLS().has_pre = true   -- code for pre (before constr)
            ASR(set=='exp' or set=='adt-constr',
                me, 'not permitted inside an interface')
        end

        if to.tag=='Var' and to.var.id=='_ret' then
            PROPS.has_ret = true
        end
    end,

    Op1_cast = function (me)
        local tp, _ = unpack(me)
        if tp.tag=='Type' and ENV.clss[TP.id(tp)] and TP.check(tp,'&&') then
            PROPS.has_ifcs = true      -- cast must check org->cls_id
        end
    end,

    Lua = function (me)
        PROPS.has_lua = true
    end,
}

AST.visit(F)

end

    
do
-- TODO: rename to flow
ANA = {
    ana = {
        isForever  = nil,
        reachs   = 0,      -- unexpected reaches
        unreachs = 0,      -- unexpected unreaches
    },
    no_nested_termination = true,
}

function ANA.dbg_one (p)
    for e in pairs(p) do
        if e == true then
            DBG('', '$$$')
        else
            if type(e) == 'table' then
                for _,t in pairs(e) do
                    DBG('', _, t.id)
                end
            else
                DBG('', e)
            end
        end
    end
end
function ANA.dbg (me)
    DBG('== '..me.tag, me)
    DBG('-- PRE')
    ANA.dbg_one(me.ana.pre)
    DBG('-- POS')
    ANA.dbg_one(me.ana.pos)
end

-- avoids counting twice (due to loops)
-- TODO: remove
local __inc = {}
function INC (me, c)
    if __inc[me] then
        return true
    else
        ANA.ana[c] = ANA.ana[c] + 1
        __inc[me] = true
        return false
    end
end

-- [false]  => never terminates
-- [true]   => terminates w/o event

function OR (me, sub, short)

    -- TODO: short
    -- short: for ParOr/Loop/SetBlock if any sub.pos is equal to me.pre,
    -- then we have a "short circuit"

    for k in pairs(sub.ana.pos) do
        if k ~= false then
            me.ana.pos[false] = nil      -- remove NEVER
            me.ana.pos[k] = true
        end
    end
end

function COPY (n)
    local ret = {}
    for k in pairs(n) do
        ret[k] = true
    end
    return ret
end

function ANA.IS_EQUAL (n1, n2)
    return ANA.HAS(n1,n2) and ANA.HAS(n2,n1)
end

function ANA.HAS (n1, n2)
    for k2 in pairs(n2) do
        if not n1[k2] then
            return false
        end
    end
    return true
end

local LST = {
    Do=true, Stmts=true, Block=true, Root=true, Dcl_cls=true,
    Pause=true, Set=true,
}

F = {
    Root_pos = function (me)
        ANA.ana.isForever = not (not me.ana.pos[false])
    end,

    Node_pre = function (me)
        if me.ana then
            return
        end

        local top = AST.iter()()
        me.ana = {
            pre  = (top and COPY(top.ana.pre)) or { [true]=true },
        }
    end,
    Node = function (me)
        if me.ana.pos then
            return
        end
        local lst
        for i=#me, 1, -1 do
            if AST.isNode(me[i]) then
                lst = me[i]
                break
            end
        end
        if LST[me.tag] and lst then
            me.ana.pos = COPY(lst.ana.pos)  -- copy lst child pos
        else
            me.ana.pos = COPY(me.ana.pre)       -- or copy own pre
        end
    end,

    Dcl_cls_pos = function (me)
        local _,id = unpack(me)

        -- TODO: evaluated when this is "true" for sure
        ANA.no_nested_termination = false
        me.no_nested_termination  = false

--[[
        DBG('>>>', id)
        for k,v in pairs(me.ana.pos) do
            DBG('',k, v)
            if type(k)=='table' then
                for kk,vv in pairs(k) do
                    DBG('','',kk,vv)
                    if type(vv)=='table' then
                        for kkk,vvv in pairs(vv) do
                            DBG('','','',kkk,vvv)
                        end
                        if vv.id == '_ok_killed' then
ANA.no_nested_termination = false
me.no_nested_termination = false
WRN(true, me,
    'class "'..id..'" may terminate from nested organisms')
print('class "'..id..'" may terminate from nested organisms')
                        end
                    end
                end
            end
        end
]]

        if id ~= 'Main' then
            me.ana.pos = COPY(me.ana.pre) -- no effect on enclosing class
-- TODO: evaluate class termination as well
        end
    end,
    Dcl_cls_pre = function (me)
        me.no_nested_termination = true
        if me ~= MAIN then
            me.ana.pre = { [me.id]=true }
        end
    end,
    Orgs = function (me)
        me.ana.pos = { [false]=true }       -- orgs run forever
    end,

    Dcl_fun_pre = function (me)
        me.ana.pos = COPY(me.ana.pre)
        me.__ana_saved = me.ana
        me.ana = { pre={ [true]=true } }
    end,
    Dcl_fun_pos = function (me)
        me.ana = me.__ana_saved
    end,

    Stmts_bef = function (me, sub, i)
        if i == 1 then
            -- first sub copies parent
            sub.ana = {
                pre = COPY(me.ana.pre)
            }
        else
            -- broken sequences
            if sub.tag~='Host' and sub.tag~='Dcl_fun' and
               me[i-1].ana.pos[false] and (not me[i-1].ana.pre[false]) then
                --ANA.ana.unreachs = ANA.ana.unreachs + 1
                me.__unreach = true
                local n = INC(me, 'unreachs')
                if (not n) and (not sub.__adj_no_not_reachable_warning) then
                    WRN(false, sub, 'statement is not reachable')
                end
            end
            -- other subs follow previous
            sub.ana = {
                pre = COPY(me[i-1].ana.pos)
            }
        end
    end,

    -- TODO: behaves similarly to Stmts
    --  join code
    Set_aft = function (me, sub, i)
        if sub.tag == 'Await' then
            me[i+1].ana = {
                pre = COPY(sub.ana.pos)
            }
        end
    end,

    ParOr_pos = function (me)
        me.ana.pos = { [false]=true }
        for _, sub in ipairs(me) do
            OR(me, sub, true)
        end
        if me.ana.pos[false] and (not me.__adj_no_should_terminate_warning) then
            --ANA.ana.unreachs = ANA.ana.unreachs + 1
            WRN( INC(me, 'unreachs'),
                 me, 'at least one trail should terminate')
        end
    end,

    ParAnd_pos = function (me)
        -- if any of the sides run forever, then me does too
        -- otherwise, behave like ParOr
        for _, sub in ipairs(me) do
            if sub.ana.pos[false] then
                me.ana.pos = { [false]=true }
                --ANA.ana.unreachs = ANA.ana.unreachs + 1
                WRN( INC(me, 'unreachs'),
                     sub, 'trail should terminate')
                return
            end
        end

        -- like ParOr, but remove [true]
        local onlyTrue = true
        me.ana.pos = { [false]=true }
        for _, sub in ipairs(me) do
            OR(me, sub)
            if not sub.ana.pos[true] then
                onlyTrue = false
            end
        end
        if not onlyTrue then
            me.ana.pos[true] = nil
        end
    end,

    ParEver_pos = function (me)
        me.ana.pos = { [false]=true }
        local ok = false
        for _, sub in ipairs(me) do
            if sub.ana.pos[false] then
                ok = true
                break
            end
        end
        if not ok then
            --ANA.ana.reachs = ANA.ana.reachs + 1
            WRN( INC(me, 'reachs'),
                 me, 'all trails terminate')
        end
    end,

    If = function (me)
        me.ana.pos = { [false]=true }
        for _, sub in ipairs{me[2],me[3]} do
            OR(me, sub)
        end
    end,

    SetBlock_pre = function (me)
        me.ana.pos = { [false]=true }   -- `return/breakÂ´ may change this
    end,
    Escape = function (me)
        local top = AST.iter((me.tag=='Escape' and 'SetBlock') or 'Loop')()
        me.ana.pos = COPY(me.ana.pre)
        OR(top, me, true)
        me.ana.pos = { [false]='esc' }   -- diff from [false]=true
    end,
    SetBlock = function (me)
        local blk = me[1]
        if not blk.ana.pos[false] then
            --ANA.ana.reachs = ANA.ana.reachs + 1
            WRN( INC(me, 'reachs'),
                 blk, 'missing `escapeÂ´ statement for the block')
        end
    end,

    Loop_pre = 'SetBlock_pre',
    Break    = 'Escape',

    Loop = function (me)
        local max,iter,_,body = unpack(me)

        -- if eventually terminates (max or iter) and
        --   loop iteration is reachable (not body.pos[false]),
        -- then me.pos=U(me.pre,body.pos)
        -- ('number','org','data' are bounded, 'event' is not)
        if (max or iter and me.iter_tp~='event') and
            (not body.ana.pos[false])
        then
            -- union(me.ana.pre, body.ana.pos)
            me.ana.pos = COPY(me.ana.pre)
            OR(me, body)
            return
        end

        if body.ana.pos[false] then
            --ANA.ana.unreachs = ANA.ana.unreachs + 1
            WRN( INC(me, 'unreachs'),
                 me, '`loopÂ´ iteration is not reachable')
        end
    end,

    -- warn if recursive spawn w/o await path
    Spawn = function (me)
        local id, pool, _,_ = unpack(me)
        local cls = CLS()

        -- recursive spawn (spawn T inside T)
        if id == cls.id then
            -- no await from the begin to spawn
            if me.ana.pre[id] == true then
                local tp = TP.pop(pool.tp,'&')
                assert(TP.check(tp,'[]'))
                if pool.tp.arr == '[]' then
                    -- pool is unbounded
                    WRN(false, me, 'unbounded recursive spawn')
                end
            end
        end
    end,

    Thread = 'Async',
    Async = function (me)
        if me.ana.pre[false] then
            me.ana.pos = COPY(me.ana.pre)
        else
            me.ana.pos = { ['ASYNC_'..me.n]=true }  -- assume it terminates
        end
    end,

    Stmts_pos = function (me)
        if me.__adj_is_spawnanon then
            ASR(me.ana.pos[false] == true, me.ln,
                '`spawnÂ´ body must never terminate')
        end
    end,

    Await_aft = function (me, sub, i)
        if i > 1 then
            return
        end

        -- between Await and Until

        local e, dt, cnd = unpack(me)

        local t
        if me.ana.pre[false] then
            t = { [false]=true }
        else
            -- enclose with a table to differentiate each instance
            t = { [{e.evt or e.var}]=true }
        end
        me.ana.pos = COPY(t)
        if cnd then
            cnd.ana = {
                pre = COPY(t),
            }
        end
    end,

    AwaitN = function (me)
        me.ana.pos = { [false]=true }
    end,
}

local _union = function (a, b, keep)
    if not keep then
        local old = a
        a = {}
        for k in pairs(old) do
            a[k] = true
        end
    end
    for k in pairs(b) do
        a[k] = true
    end
    return a
end

-- TODO: remove
-- if nested node is reachable from "pre", join with loop POS
function ANA.union (root, pre, POS)
    local t = {
        Node = function (me)
            if me.ana.pre[pre] then         -- if matches loop begin
                _union(me.ana.pre, POS, true)
            end
        end,
    }
    AST.visit(t, root)
end

AST.visit(F)

end

    
do
ANA.ana.acc  = 0      -- nd accesses
ANA.ana.abrt  = 0      -- nd flows
ANA.ana.excpt = 0      -- nd excpt

-- any variable access calls this function
-- to be inserted on parent Parallel sub[i] or Class
function iter (n)
    local par = n.__par and n.__par.tag
    return par=='ParOr' or par=='ParAnd' or par=='ParEver'
        or n.tag=='Dcl_cls'
end

function ERR (me, msg)
    return msg..' ('..me.ln[1]..':'..me.ln[2]..')'
end

function INS (acc, exists)
--[[
    if AST.iter'Async'() then
        acc.md = 'no'                       -- protected acc
    end
    if AST.iter'Sync'() then
        acc.md = 'no'                       -- protected acc
    end
]]
    if not exists then
        acc.cls = CLS()                     -- cls that acc resides
    end
    local n = AST.iter(iter)()             -- child Block from PAR
    if n then
        n.ana.accs[#n.ana.accs+1] = acc
    end
    return acc
end

function CHG (acc, md)
    if AST.iter'Thread'() then
        return
    end
    if acc.md == 'nv' then
        return
    else
        acc.md = md
    end
end

F = {
-- accs need to be I-indexed (see CHK_ACC)
    Dcl_cls_pre = function (me)
        me.ana.accs = {}
    end,
    ParOr_pre = function (me)
        for _, sub in ipairs(me) do
            sub.ana.accs = {}
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',

    ParOr_pos = function (me)
        -- insert all my subs on my parent Par
        if AST.iter(AST.pred_par) then -- requires ParX_pos
            for _, sub in ipairs(me) do
                for _,acc in ipairs(sub.ana.accs) do
    -- check par/enter only against immediate pars
                    if acc.md ~= 'par' then
    -- check ParOr esc only against immediate pars
                    if not (acc.md=='esc' and acc.id.tag=='ParOr') then
    -- check Loop esc only against nested pars
                    --if not (acc.md=='esc' and acc.id.tag=='Loop'
                            --and acc.id.depth>me.depth) then
                        INS(acc, true)
                    --end
                    end
                    end
                end
            end
        end
    end,
    ParAnd_pos  = 'ParOr_pos',
    ParEver_pos = 'ParAnd_pos',

    Spawn = function (me)
        local sz = #me.cls.ana.accs -- avoid ipairs due to "spawn myself"
        for i=1, sz do
            INS(me.cls.ana.accs[i], true)
        end
    end,

-- TODO: usar o Dcl_var p/ isso
--[=[
    Orgs = function (me)
        -- insert cls accs on my parent ParOr
        for _, var in ipairs(me.vars) do
            for _,acc in ipairs(var.cls.ana.accs) do
                INS(acc, true)
            end
        end
    end,
]=]

    EmitExt = function (me)
        local _, e1, e2 = unpack(me)
        if e1.evt.pre == 'input' then
            return
        end
        INS {
            path = me.ana.pre,
            id  = e1.evt.id,    -- like functions (not table events)
            md  = 'cl',
            tp  = TP.new{'@'},
            any = false,
            err = ERR(me, 'event `'..e1.evt.id..'Â´')
        }
--[[
        if e2 then
            local tp = TP.deptr(e1.evt.ins, true)
            if e2.accs and tp then
                e2.accs[1][4] = (e2.accs[1][2] ~= 'no')   -- &x does not become 
                    "any"
                e2.accs[1][2] = (me.c and me.c.mod=='@pure' and 'rd') or 'wr'
                e2.accs[1][3] = tp
            end
        end
]]
    end,

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        CHG(f.lst.acc, 'cl')
        me.acc = f.lst.acc
        for _, exp in ipairs(exps) do
            if TP.check(exp.tp,'&&') then
                local v = exp.lst
                if v and v.acc then   -- ignore constants
--DBG(exp.tag, exp.lst)
                    v.acc.any = exp.lval    -- f(&x) // a[N] f(a) // not "any"
                    CHG(v.acc, (me.c and me.c.mod=='@pure' and 'rd') or 'wr')
                    v.acc.tp = TP.pop(exp.tp,'&&')
                end
            end
        end

        -- TODO: never tested
--[[
        me.acc = INS {
            path = me.ana.pre,
            id  = f,
            md  = 'cl',
            tp  = TP.new{'@'},
            any = true,
            err = 'call to `'..f.id..'Â´ (line '..me.ln[2]..')',
        }
]]
    end,

    EmitInt = function (me)
        local _, e1, e2 = unpack(me)
        CHG(e1.lst.acc, 'tr')
        e1.lst.acc.node = me        -- emtChk
        me.emtChk = false
    end,

    Set = function (me)
        local _,_,_,to = unpack(me)
        to = (to.tag=='VarList' and to) or {to}
        for _, v in ipairs(to) do
            if v.lst.acc and v.lst.acc.md~='no' and v.lst.acc.md~='nv' then
                CHG(v.lst.acc, 'wr')
            else
                -- *((u32*)0x100) = v  (no acc)
            end
        end
    end,

    ['Op2_idx'] = function (me)
        local tp = me.lst.var and me.lst.var.tp
        if not (tp and TP.check(tp,'[]','-&')) then
            me.lst.acc.any = true
        end
        me.lst.acc.tp = me.tp  -- deptr'd
    end,
    ['Op1_*'] = function (me)
        if not me.lst.acc then
            assert(me.lst.sval)
            return  -- constants
        end

        me.lst.acc.any = true
        me.lst.acc.tp = me.tp  -- deptr'd

        -- TODO: HACK_3
        -- ignore cast to tceu_org
        if me[2].tag=='Op1_cast' and me[2][1][1]=='_tceu_org' then
            me.lst.acc.tp = me[2][2].tp  -- change to uncast type
        end
    end,
    ['Op1_&&'] = function (me)
        CHG(me.lst.acc, 'no')
    end,

    Field = function (me)
        me.lst.acc.org = me.org.lst
    end,

    Global = function (me)
        me.acc = INS {
            me  = me,
            path = me.ana.pre,
            id  = 'Global',
            md  = 'rd',
            tp  = me.tp,
            any = true,
            err = ERR(me, 'variable `globalÂ´'),
        }
    end,

    Outer = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = me,
            md  = 'rd',
            tp  = me.tp,
            any = true,
            err = ERR(me, 'variable `outerÂ´'),
        }
    end,

    This = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = me,
            md  = (AST.par(me,'Dcl_constr') and 'nv') or 'rd',
            tp  = me.tp,
            any = true,
            err = ERR(me, 'variable `thisÂ´'),
        }
    end,

    Var = function (me)
        local tag = me.__par.tag=='VarList' and me.__par.__par.tag

        if tag=='Async' or tag=='Thread' or tag=='Isr' then
            return  -- <async (v)> is not an access
        end

        local generated = (string.sub(me.var.id,1,1) == '_') and (me.var.id~='_ret')

        me.acc = INS {
            me  = me,
            path = me.ana.pre,
            id  = me.var,
            md  = (generated and 'nv') or 'rd',
            tp  = me.var.tp,
            any = TP.check(me.var.tp,'&'),
            str = me.var.id,
            err = ERR(me, 'variable/event `'..me.var.id..'Â´'),
        }

        if me.__par.tag=='Field' and me.__par[2].tag=='This' and AST.par(me,'Dcl_constr') then
            -- variable being allocated cannot be in parallel with anyone
            me.acc.md = 'no'
        end
    end,

    RawExp = 'Nat',
    Nat = function (me)
        local _, generated = unpack(me);
        me.acc = INS {
            me  = me,
            path = me.ana.pre,
            id  = me[1],
            md  = (generated and 'nv') or 'rd',
            tp  = TP.new{'@'},
            any = false,
            str = me[1],
            err = ERR(me, 'symbol `'..me[1]..'Â´'),
        }
    end,

    -- FLOW --

    Break = function (me, TAG, PRE)
        TAG = TAG or 'Loop'
        PRE = PRE or me.ana.pre
        local top = AST.iter(TAG)()
        INS {
            path = PRE,
            id  = top,
            md  = 'esc',
            err = ERR(me, 'escape'),
        }
    end,
    Escape = function (me)
        F.Break(me, 'SetBlock')
    end,
    Node = function (me)
        local top = me.__par and me.__par.tag
        if top == 'ParOr' then
            if not me.ana.pos[false] then
                F.Break(me, 'ParOr', me.ana.pos)
            end
        end

        if top=='ParOr' or top=='ParAnd' or top=='ParEver' then
            if not me.ana.pre[false] then
                me.parChk = false           -- only chk if ND flw
                INS {
                    path = me.ana.pre,
                    id   = me,--.__par,
                    md   = 'par',
                    err  = ERR(me,'par enter'),
                }
            end
        end
    end,

    Await = function (me)
        local e = unpack(me)
        if e.tag ~= 'Ext' then
            CHG(me[1].lst.acc, 'aw')
        end
        INS {
            path = me.ana.pos,
            id  = me,--AST.iter(TAG)(),
            md  = 'awk',
            err = ERR(me, 'awake'),
        }
    end,
}

AST.visit(F)

------------------------------------------------------------------------------

local ND = {
    acc = { par={},awk={},esc={},
        cl  = { cl=2, tr=2,     wr=2,     rd=2,     aw=2  },
        tr  = { cl=2, tr=1,     wr=false, rd=false, aw=1  },
        wr  = { cl=2, tr=false, wr=2,     rd=2,     aw=false },
        rd  = { cl=2, tr=false, wr=2,     rd=false, aw=false },
        aw  = { cl=2, tr=1,     wr=false, rd=false, aw=false },
        no  = {},   -- never ND ('ref')
        nv  = {},   -- never ND ('ref')
    },

    flw = { cl={},tr={},wr={},rd={},aw={},no={},nv={},
        par = { par=false, awk=false, esc=1 },
        awk = { par=false, awk=false, esc=1 },
        esc = { par=1,     awk=1,     esc=1 },
    },
}

local ALL = nil     -- holds all emits starting from top-most PAR

--[[
    ana = {
        acc = 1,  -- false positive
    },
    ana = {
        isForever = true,
        n_unreachs = 1,
    },
]]

-- {path [A]=true, [a]=true } => {ret [A]=true, [aX]=true,[aY]=true }
-- {T [a]={[X]=true,[Y]=true} } (emits2pres)
local function int2exts (path, NO_emts, ret)
    ret = ret or {}

    local more = false                  -- converged
    for int in pairs(path) do
        if type(int)=='table' and int[1].pre=='event' then
            for emt_acc in pairs(ALL) do
                if int[1]==emt_acc.id and (not NO_emts[emt_acc]) then
                    for ext in pairs(emt_acc.path) do
                        if not ret[ext] then
                            more = true         -- not converged yet
                            ret[ext] = true     -- insert new ext
                        end
                    end
                end
            end
        else
            ret[int] = true             -- already an ext
        end
    end
    if more then
        return int2exts(ret, NO_emts, ret, cache) -- not converged
    else
        if next(ret)==nil then
            ret[false] = true   -- include "never" if empty
        end
        return ret
    end
end

function par_rem (path, NO_par)
    for id in pairs(path) do
        if NO_par[id] then
            path[id] = nil
        end
    end
    if next(path)==nil then
        path[true] = true       -- include "tight" became empty
    end
    return path
end

function par_level1 (path1, path2)
    for id1 in pairs(path1) do
        for id2 in pairs(path2) do
            if (id1 == false) then
            elseif (id1 == id2) or
                     (type(id1) == 'table') and (type(id2) == 'table') and
                     (id1[1] == id2[1])
            then
                return true
            end
        end
    end
end

--local CACHE = setmetatable({},
    --{__index=function(t,k) t[k]={} return t[k] end})

function CHK_ACC (accs1, accs2, NO_par, NO_emts)
    local cls = CLS()

    -- "acc": i/j are concurrent, and have incomp. acc
    -- accs need to be I-indexed
    for _, acc1 in ipairs(accs1) do
        local path1 = int2exts(acc1.path, NO_emts)
              path1 = par_rem(path1, NO_par)
        for _, acc2 in ipairs(accs2) do
            local path2 = int2exts(acc2.path, NO_emts)
                  path2 = par_rem(path2, NO_par)

            local isLvl1 = par_level1(path1,path2)

-- FLOW (only in safety level-1)
            if isLvl1 and ND.flw[acc1.md][acc2.md] then
                if AST.isParent(acc1.id, acc2.id)
                or AST.isParent(acc2.id, acc1.id)
                then
                    if OPTS.safety > 0 then
                        DBG('WRN : abortion : '..
                                acc1.err..' vs '..acc2.err)
                    end
                    ANA.ana.abrt = ANA.ana.abrt + 1
                    if acc1.md == 'par' then
                        acc1.id.parChk = true
                    end
                    if acc2.md == 'par' then
                        acc2.id.parChk = true
                    end
                end
            end

-- ACC (in both safety levels, ignore aw/tr for level-2)
--DBG(acc1.md,acc2.md, OPTS.safety, ND.acc[acc1.md],ND.acc[acc2.md])
            if par_level1(path1,path2) and ND.acc[acc1.md][acc2.md] or
               OPTS.safety==2 and ND.acc[acc1.md][acc2.md]==2
            then
                local err = false
                local c1 = ENV.c[acc1.id]
                local c2 = ENV.c[acc2.id]

                if c1 and c2 then
                    -- C's are det?
                    local c1_err = c1.mod~='@pure' and c1.mod~='const'
                    local c2_err = c2.mod~='@pure' and c2.mod~='const'
                    if c1_err and c2_err and
                        ( acc1.md=='cl' and acc2.md=='cl'
                        or
                          acc1.id==acc2.id )
                    then
                        err = true
                    end
                else
                    -- this.x vs this.x (both accs bounded to cls)
                    local cls_err = (acc1.cls == cls) or
                                    (acc2.cls == cls)

                    -- orgs are compatible?
                    -- a.x vs this.x
                    local _nil = {}
                    local o1 = (acc1.org or acc2.org)
                    o1 = o1 and o1.acc or _nil
                    local o2 = (acc2.org or acc1.org)
                    o2 = o2 and o2.acc or _nil
                    local org_err = o1.id == o2.id
                                    or o1.any
                                    or o2.any

                    -- ids are compatible?
                    local id_err = acc1.id == acc2.id
                                 or acc1.md=='cl' and acc2.md=='cl'
                                 or acc1.any and TP.contains(acc1.tp,acc2.tp)
                                 or acc2.any and TP.contains(acc2.tp,acc1.tp)
                    err = cls_err and org_err and id_err
                end

                if err then
                    local ok = (ENV.dets[acc1.id] and
                                (ENV.dets[acc1.id]==true or
                                 ENV.dets[acc1.id][acc2.id]))
                             or
                               (ENV.dets[acc2.id] and
                                (ENV.dets[acc2.id]==true or
                                 ENV.dets[acc2.id][acc1.id]))
                    err = not ok
                end
--[[
DBG'==============='
DBG(acc1.cls.id, acc1, acc1.id, acc1.md, TP.toc(acc1.tp), acc1.any, acc1.err)
for k in pairs(path1) do
DBG('path1', acc1.path, type(k)=='table' and k[1].id or k)
end
DBG(acc2.cls.id, acc2, acc2.id, acc2.md, TP.toc(acc2.tp), acc2.any, acc2.err)
for k in pairs(path2) do
DBG('path2', acc2.path, type(k)=='table' and k[1].id or k)
end
DBG'==============='
]]
                if err then
                    if OPTS.safety > 0 then
                        DBG('WRN : nondeterminism : '..acc1.err
                                ..' vs '..acc2.err)
                    end
                    ANA.ana.acc = ANA.ana.acc + 1

                    if acc1.me and      AST.par(acc1.me,'Isr') and
                       acc2.me and (not AST.par(acc2.me,'Isr'))
                    then
                        ASR(AST.par(acc2.me,'Atomic'), acc2.me.ln,
                            'access to symbol "'..acc2.str..'" must be atomic'..
                            ' (vs '..acc1.err..')')
                    end
                    if acc2.me and      AST.par(acc2.me,'Isr') and
                       acc1.me and (not AST.par(acc1.me,'Isr'))
                    then
                        ASR(AST.par(acc1.me,'Atomic'), acc1.me.ln,
                            'access to symbol "'..acc1.str..'" must be atomic'..
                            ' (vs '..acc2.err..')')
                    end
                end
            end
        end
    end
end

function _chk (n, id)
    for k in pairs(n) do
        if type(k)=='table' and k[1]==id then
            return true
        end
    end
    return false
end

-- TODO: join with CHK_ACC
-- emits vs rets/ors/breaks (the problem is that emits are considered in par)
function CHK_EXCPT (s1, s2, isOR)
    for _, ana in ipairs(s1.ana.accs) do
        if ana.md == 'tr' then
            if _chk(s2.ana.pos,ana.id) and isOR or -- terminates w/ same event
               s2.ana.pos[false] --or       -- ~terminates (return/break)
               --s2.ana.pos[true]                 -- terminates tight
            then
                if OPTS.warn_exception then
                    DBG('WRN : exception : line '..s2.ln[2]..' vs '..ana.err)
                end
                ANA.ana.excpt = ANA.ana.excpt + 1
                ana.node.emtChk = true
            end
        end
    end
end

G = {
-- take all emits from top-level PAR
    ParOr_pre = function (me)
        if ALL then
            return
        end
        ALL = {}
        for _, sub in ipairs(me) do
            for _,acc in ipairs(sub.ana.accs) do
                if acc.md == 'tr' then
                    ALL[acc] = true
                end
            end
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',

-- look for nondeterminism
    ParOr = function (me)
        for i=1, #me do
            for j=i+1, #me do

                -- holds invalid emits
                local NO_emts = {}
                for _,acc in ipairs(me[i].ana.accs) do
                    if acc.md == 'tr' then
                        NO_emts[acc] = true -- same trail (happens bef or aft)
                    end
                end
                for _,acc in ipairs(me[j].ana.accs) do
                    if acc.md == 'tr' then
                        NO_emts[acc] = true -- same trail (happens bef or aft)
                    end
                end
                for acc in pairs(ALL) do
                    if ANA.IS_EQUAL(acc.path, me.ana.pre) then
                        NO_emts[acc] = true -- instantaneous emit
                    end
                end

                CHK_ACC(me[i].ana.accs, me[j].ana.accs,
                        me.ana.pre,
                        --ANA.union(me.ana.pre,me.ana.pos),
                        NO_emts)
                CHK_EXCPT(me[i], me[j], me.tag=='ParOr')
                CHK_EXCPT(me[j], me[i], me.tag=='ParOr')
            end
        end
    end,
    ParAnd  = 'ParOr',
    ParEver = 'ParOr',

-- TODO: workaround
    -- Loop can only be repeated after nested PARs evaluate CHK_*
    Loop = function (me)
        local _,_,_,body = unpack(me)
        -- pre = pre U pos
        if not body.ana.pos[false] then
            ANA.union(body, next(me.ana.pre), body.ana.pos)
        end
    end,
}

AST.visit(G)

end

    
do
function MAX_all (me, t)
    t = t or me
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            me.trails_n = MAX(me.trails_n, sub.trails_n)
        end
    end
end

F = {
    Node_pre = function (me)
        me.trails_n = 1
    end,
    Node_pos = function (me)
        if not F[me.tag] then
            MAX_all(me)
        end
    end,

    If = function (me)
        local c, t, f = unpack(me)
        MAX_all(me, {t,f})
    end,

    Dcl_cls = function (me)
        MAX_all(me)

        -- pointer to next org or parent/trail
        -- [ IN__ORG_UP/DOWN ]
        if me ~= MAIN then
            me.trails_n = me.trails_n + 1
        end

        ASR(me.trails_n < 256, me, 'too many trails')
    end,

    Block = function (me)
        MAX_all(me)

        -- [ CLR | ADT_I | VEC_I | ORG_STATS_I | ORG_POOL_I | ... | STMTS | FIN ]
        -- clear trail
        -- adt finalization
        -- vector finalization
        -- org*? reset to NULL
        -- pointer to contiguous static orgs
        -- pointers to each of the pools
        -- statements
        -- finalization
        -- STATS and POOL must interleave to respect execution order:
        -- var  T a;
        -- pool T ts;
        -- var  T b;
        -- First execute a, then all ts, then b.

        for i=1, #me.vars do
            local var = me.vars[i]

            local is_arr_dyn = (TP.check(var.tp,'[]')           and
                               (var.pre == 'var')               and
                               (not TP.is_ext(var.tp,'_','@'))) and 
                               (var.tp.arr=='[]')               and
                               (not var.cls)
            if is_arr_dyn then
                me.trails_n = me.trails_n + 1
            end

            if var.pre=='pool' or is_arr_dyn then
                me.fins = me.fins or {}     -- release adts/vectors
            end

            local tp_id = TP.id(var.tp)
            if ENV.clss[tp_id] and TP.check(var.tp,tp_id,'&&','?','-[]') then
                me.trails_n = me.trails_n + 1
            elseif var.adt and var.pre=='pool' then
                me.trails_n = me.trails_n + 1
            elseif var.cls then
                me.trails_n = me.trails_n + 1   -- ORG_POOL_I/ORG_STATS_I
                var.trl_orgs_first = true       -- avoids repetition in initialization of STATS

                -- for STATS, unify all skipping all non-pool vars
                if var.pre ~= 'pool' then
                    for j=i+1, #me.vars do
                        local var2 = me.vars[j]
                        if var2.pre == 'pool' then
                            break
                        else
                            i = i + 1   -- skip on outer loop
                        end
                    end
                end
            end
        end

        if me.fins then
            -- implicit await in parallel
            me.trails_n = me.trails_n + 1
        end
    end,

    ParAnd  = 'ParOr',
    ParEver = 'ParOr',
    ParOr = function (me)
        me.trails_n = 0
        for _, sub in ipairs(me) do
            me.trails_n = me.trails_n + sub.trails_n
        end
    end,
}

AST.visit(F)

-------------------------------------------------------------------------------

function pred (n)
    return n.trails
end

G = {
    Root_pre = 'Dcl_cls_pre',
    Dcl_cls_pre = function (me)
        me.trails  = { 0, me.trails_n -1 }     -- [0, N]
    end,

    Node = function (me)
        if me.trails then
            return
        end
        me.trails  = AST.iter(pred)().trails
    end,

    Block_pre = function (me)
        local stmts = unpack(me)

        -- [ 1, 1, S, 1 ] (clr, org0, stmts, fin)

        me.trails = me.trails or AST.iter(pred)().trails

        local t0 = me.trails[1]

        -- [ ORG_STATS | ORG_POOL_I | STMTS | FIN ]
        -- pointer to all static orgs
        -- pointers to each of the pools
        -- statements
        -- finalization

        for i=1, #me.vars do
            local var = me.vars[i]

            local is_arr_dyn = (TP.check(var.tp,'[]')           and
                               (var.pre == 'var')               and
                               (not TP.is_ext(var.tp,'_','@'))) and 
                               (var.tp.arr=='[]')               and
                               (not var.cls)
            if is_arr_dyn then
                var.trl_vector = { t0, t0 }
                t0 = t0 + 1
            end

            local tp_id = TP.id(var.tp)
            if ENV.clss[tp_id] and TP.check(var.tp,tp_id,'&&','?','-[]') then
                var.trl_optorg = { t0, t0 }
                t0 = t0 + 1

            elseif var.adt and var.pre=='pool' then
                var.trl_adt = { t0, t0 }
                t0 = t0 + 1

            elseif var.cls then
                var.trl_orgs = { t0, t0 }   -- ORG_POOL_I/ORG_STATS_I
                t0 = t0 + 1

                -- for STATS, unify all skipping all non-pool vars
                if var.pre ~= 'pool' then
                    for j=i+1, #me.vars do
                        local var2 = me.vars[j]
                        if var2.pre == 'pool' then
                            break
                        else
                            if var2.cls then
                                var2.trl_orgs = { t0-1, t0-1 }   -- ORG_STATS_I
                            end
                            i = i + 1   -- skip on outer loop
                        end
                    end
                end
            end
        end

        -- BLOCK
        stmts.trails = { t0, t0+stmts.trails_n-1 }
            t0 = t0 + stmts.trails_n    -- stmts

        -- FINS (must be the last to properly nest fins)
        if me.fins then
            me.trl_fins  = { t0, t0 }
                t0 = t0 + 1             -- fin
        end
    end,

    _Par_pre = function (me)
        me.trails = AST.iter(pred)().trails

        for i, sub in ipairs(me) do
            sub.trails = {}
            if i == 1 then
                sub.trails[1] = me.trails[1]
            else
                local pre = me[i-1]
                sub.trails[1] = pre.trails[1] + pre.trails_n
            end
            sub.trails[2] = sub.trails[1] + sub.trails_n  - 1
        end
    end,

    ParOr_pre   = '_Par_pre',
    ParAnd_pre  = '_Par_pre',
    ParEver_pre = '_Par_pre',
}

AST.visit(G)

end

    
do
LBLS = {
    list = {},      -- { [lbl]={}, [i]=lbl }
    code_enum = '',
}

function new (lbl)
    if lbl[2] then
        lbl.id = lbl[1]
    else
        lbl.id = CLS().id..'_'..lbl[1]..'_'..#LBLS.list
    end
    lbl.id = string.gsub(lbl.id, '%*','')
    lbl.id = string.gsub(lbl.id, '%.','')
    lbl.id = string.gsub(lbl.id, '%$','')
    lbl.id = string.gsub(lbl.id, '%%','')
    LBLS.list[lbl] = true
    lbl.n = #LBLS.list                   -- starts from 0
    LBLS.list[#LBLS.list+1] = lbl

    for n in AST.iter() do
        if n.lbls_all then
            n.lbls_all[lbl] = true
        end
    end

    return lbl
end

--new{'CEU_LBL__NONE', true}

F = {
    Node_pre = function (me)
        me.lbls = { #LBLS.list }
    end,
    Node = function (me)
        me.lbls[2] = #LBLS.list-1
    end,

    Root_pre = function (me)
        --new{'CEU_INACTIVE', true}
    end,
    Root = function (me)
        -- 0, 1,-1, tot,-tot
        -- <0 = off (for internal events)
        TP.types.tceu_nlbl.len  = TP.n2bytes(1+2 + #LBLS.list*2)

        -- enum of labels
        for i, lbl in ipairs(LBLS.list) do
            LBLS.code_enum = LBLS.code_enum..'    '
                                ..lbl.id..' = '..lbl.n..',\n'
        end
    end,

    Block = function (me)
        if me.fins then
            me.lbl_fin = new{'Block__fin'}
        end

        for _, var in ipairs(me.vars) do
            local is_arr_dyn = (TP.check(var.tp,'[]')           and
                               (var.pre == 'var')               and
                               (not TP.is_ext(var.tp,'_','@'))) and 
                               (var.tp.arr=='[]')               and
                               (not var.cls)
            if is_arr_dyn then
                var.lbl_fin_free = new{'vector_fin_free'}
            end

            local tp_id = TP.id(var.tp)
            if ENV.clss[tp_id] and TP.check(var.tp,tp_id,'&&','?','-[]') then
                var.lbl_optorg_reset = new{'optorg_reset'}
            elseif var.adt and var.pre=='pool' then
                var.lbl_fin_kill_free = new{'adt_fin_kill_free'}
            end
        end
    end,

    Dcl_cls = function (me)
        if me.is_ifc then
            return
        end

        me.lbl = new{'Class_'..me.id, true}
    end,

    SetBlock_pre = function (me)
        me.lbl_out = new{'Set_out'}
    end,

    _Par_pre = function (me)
        me.lbls_in = {}
        for i, sub in ipairs(me) do
            if i < #me then
                -- the last executes directly (no label needed)
                me.lbls_in[i] = new{me.tag..'_sub_'..i}
            end
        end
    end,
    ParEver_pre = function (me)
        F._Par_pre(me)
        me.lbl_out = new{'ParEver_out'}
    end,
    ParOr_pre = function (me)
        F._Par_pre(me)
        me.lbl_out = new{'ParOr_out'}
    end,
    ParAnd_pre = function (me)
        F._Par_pre(me)
        me.lbl_tst = new{'ParAnd_chk'}
        me.lbl_out = new{'ParAnd_out'}
    end,

    Thread = function (me)
        me.lbl = new{'Thread'}
        me.lbl_out = new{'Thread_out'}
    end,
    Async = function (me)
        me.lbl = new{'Async'}
    end,

    Loop_pre = function (me)
        if AST.iter'Async'() then
            me.lbl_asy = new{'Async_cnt'}
        end
    end,

    EmitExt = function (me)
        -- only async needs to break up (avoids stack growth)
        if AST.iter'Async'() then
            me.lbl_cnt = new{'Async_cont'}
        end
    end,

    Await = function (me)
        local e, dt = unpack(me)
        if dt then
            me.lbl = new{'Awake_DT'}
        else
            me.lbl = new{'Awake_'..(e.evt or e.var.evt).id}
        end
    end,
}

AST.visit(F)

end

    
do
local VARS = {}

--do return end     -- uncomment to force all as NO-TMP

if not ANA then
    return          -- isTmp=false for all vars
end

F = {
    Set_bef = function (me, sub, i)
        local _, set, fr, to = unpack(me)
        if i ~= 4 then
            return
        end
        if set=='thread' or set=='spawn' then
            VARS[sub.fst.var] = nil     -- remove previously accessed vars
            return
        end
        if sub.tag ~= 'VarList' then
            sub = { sub }
        end
        for _, v in ipairs(sub) do
            if v.fst.tag == 'Var' then
                local dcl = v.fst.var.dcl
                local loop = AST.par(me, 'Loop')
                if loop and dcl.__depth>loop.__depth then
                    -- reset last access
                    VARS[v.fst.var] = v.fst.ana.pre
                end
            end
        end
    end,

    Dcl_var_pre = function (me)
        local var = me.var

        -- EXTERNAL OPTION
        -- ignore all optimizations
        if not OPTS.tmp_vars then
            var.isTmp = false
        end

        local cls = ENV.clss[TP.id(var.tp)]

        local is_arr = (TP.check(var.tp,'[]')           and
                       (var.pre == 'var')               and
                       (not TP.is_ext(var.tp,'_','@'))) and
                       (not var.cls)
        local is_dyn = (var.tp.arr=='[]')

        -- ALWAYS PERSISTENT (isTmp=false)
        if var.pre ~= 'var' then
            var.isTmp = false       -- non 'var' variables
        elseif var.cls then
            var.isTmp = false       -- plain 'cls' variables
        elseif (cls and TP.check(var.tp,'&&','?')) then
            var.isTmp = false       -- option pointer to cls (T&&?)
        elseif is_arr and is_dyn then
            var.isTmp = false       -- dynamic vector
        elseif AST.par(me,'Dcl_adt') then
            var.isTmp = false       -- ADT field declaration
        elseif var.id == '_out' then
            var.isTmp = false       -- recursive ADT '_out' field

        -- ALWAYS TEMPORARY (isTmp=true)
        elseif AST.par(me, 'Dcl_fun') then
            var.isTmp = true        -- functions vars (no yields inside)
        end

        -- NOT SET, DEFAULT=true
        if var.isTmp == nil then
            var.isTmp = true
        end

        -- start tracking the var

        -- crossing a class limit,
        --  eliminate all current possible tmps
        if var.cls then
            VARS = {}
        end
        VARS[var] = true
    end,

    Var = function (me)
        local var = me.var

        -- uses inside threads or methods
        -- ("or" is ok because threads/methods are mutually exlusive)
        local node = AST.par(me,'Thread') or AST.par(me,'Dcl_fun')
        if node then
            if me.var.blk.__depth < node.__depth then
                var.isTmp = false
                return              -- defined outside: isTmp=false
            else
                return              -- defined inside: isTmp=true
            end
        end

        -- all function vars are "tmp"
        if AST.iter'Dcl_fun'() then
            return
        end

        -- only normal vars can be tmp
        if var.pre~='var' or var.cls then
            var.isTmp = false
            return
        end

        --[[
        --  var int i;
        --  var T t with
        --      i = i + 1;  // "i" cannot be tmp (argument to static _constr)
        --  end;
        --]]
        if AST.par(me, 'Dcl_constr') then
            if AST.isParent(var.blk, me) then
                var.isTmp = false
                return
            end
        end

        local dcl = AST.iter'Dcl_var'()
        if dcl and dcl[1]==var.id then
            return                  -- my declaration is not an access
        end

        if me.__par.tag == 'SetBlock' then
            return                  -- set is performed on respective `returnÂ´
        end

        local v = VARS[var]

        local op = AST.iter'Op1_&&'()
        local isRef = op and (op.base == me)

        local AwaitInt = function ()
            local n = AST.iter'Await'()
            return n and n[1].tag~='Ext'
        end

        if AST.iter'Finally'() or   -- finally executes through "call"
           AwaitInt() or            -- await ptr:a (ptr is tested on awake)
           isRef or                 -- reference may escape
           var.tp.arr               -- array may escape: TODO conservative
                                    -- (arrays as parameters)
        then
            var.isTmp = false
            VARS[var] = nil
            return
        end

        -- Not tmp if defined in the same block of an org:
        --      var T t;
        --      var int ret = 1;
        -- becomes
        --      var int ret;
        --      start t
        --      ret = 1;
--- TODO: still required?
        for _,oth in pairs(var.blk.vars) do
            if oth.cls then
                v = false
            end
        end
---

        if v == true then
            if var.blk == CLS().blk_ifc then
                v = false
            else
                VARS[var] = me.ana.pre
                return                  -- first access
            end
        end

        if not (v and ANA.IS_EQUAL(v,me.ana.pre)) then
            var.isTmp = false       -- found a Par or Await in the path
            return
        end
    end,

    ['Op1_&'] = 'Op1_&&',
    ['Op1_&&'] = function (me)
        local op, e1 = unpack(me)
        if e1.fst.var and (not e1.fst.var.is_arg) then
            e1.fst.var.isTmp = false    -- assigned to a pointer
        end
    end,
    Set = function (me)
        local _, _, fr = unpack(me)
        if fr.tag=='Op1_&' and fr.fst.var and
            (not fr.fst.var.is_arg)
        then
            fr.fst.var.isTmp = false    -- assigned to a pointer
        end
    end,

    EmitNoTmp = 'EmitInt',
    EmitInt = function (me)
        VARS = {}   -- NO: run in different ceu_call
    end,
    EmitExt = function (me)
        local op, ext, param = unpack(me)
        local evt = ext.evt
        if evt.pre == 'input' then
            VARS = {}
        end
    end,

    Spawn_pre = function (me)
        VARS = {}   -- NO: start organism
    end,

    Loop_pre = function (me)
        if ((not me.has_yield) and (not AST.iter(AST.pred_async)())) or
            me.isAwaitUntil then
            return      -- OK: (tight loop outside Async) or (await ... until)
        end
        VARS = {}       -- NO: loop in between Dcl/Accs is dangerous
        --[[
            -- x is on the stack but may be written in two diff reactions
            -- a non-ceu code can reuse the stack in between
            input int E;
            var int x;
            loop do
                var int tmp = await E;
                if tmp == 0 then
                    break;
                end
                x = tmp;
            end
            return x;
        ]]
    end,
    Loop = function (me)
        local _,_,iter,body = unpack(me)
        if iter and (not ANA.IS_EQUAL(body.ana.pre,body.ana.pos)) then
            iter.var.isTmp = false
        end
    end,

    -- Pars,Finally,Async,Thread,Block
    Block_pre = function (me)
        for var, v in pairs(VARS) do
            if v ~= true then
                VARS[var] = nil     -- remove previously accessed vars
            end
        end
    end,
    Block = 'Block_pre',

    Dcl_cls = function (me)
        if not me.is_ifc then
            return
        end

        for _, cls in ipairs(ENV.clss) do
            if me.matches[cls] then
                -- all accessed interface vars in the interface
                -- are also acessed in the matching class (isTmp=false)
                for _, var in ipairs(me.blk_ifc.vars) do
                    if var.isTmp == false then
                        cls.blk_ifc.vars[var.id].isTmp = false
                    end
                end
            end
        end
    end,
}

AST.visit(F)

end

    
do
MEM = {
    tops_h = '',
    tops_c = '',
    tops_init = '',
    native_pre = '',
}

function SPC ()
    return string.rep(' ',AST.iter()().__depth*2)
end

function pred_sort (v1, v2)
    return (v1.len or TP.types.word.len) > (v2.len or TP.types.word.len)
end

function CUR (me, id)
    if id then
        return '(('..TP.toc(CLS().tp)..'*)_ceu_org)->'..id
    else
        return '(('..TP.toc(CLS().tp)..'*)_ceu_org)'
    end
end

function MEM.tp2dcl (pre, tp, id, _dcl_id)
    local dcl = ''

    local tp_id = TP.id(tp)
    local tp_c  = TP.toc(tp)
    local cls = ENV.clss[tp_id]
    local adt = ENV.adts[tp_id]
    local top = adt or cls

    local _adt = adt and ENV.top(tp, nil, pre)
    local _cls = cls and ENV.top(tp, nil, pre)

    if _dcl_id == tp_id then
        tp_c = 'struct '..tp_c  -- for types w/ pointers for themselves
    end

    if pre == 'var' then

-- TODO: OPT
        if cls and (not cls.is_ifc) and (_dcl_id ~= tp_id) then
            dcl = dcl..'struct ' -- due to recursive spawn
        end

        if TP.check(tp,'[]','-&&','-&') then
            local tp_elem = TP.pop( TP.pop(tp,'&'), '[]' )
            local cls = cls and TP.check(tp_elem,tp_id)
            if cls or TP.is_ext(tp,'_') then
                if TP.check(tp,'&&') or TP.check(tp,'&') then
                    local tp_c = TP.toc( TP.pop(tp) )
                    return dcl .. tp_c..' '..id
                else
                    local tp_c = TP.toc(tp_elem)
                    return dcl .. tp_c..' '..id..'['..tp.arr.cval..']'
                end
            else
                if TP.check(tp,'&&') or TP.check(tp,'&') then
                    return 'tceu_vector* '..id
                else
                    local max = (tp.arr.cval or 0)
                    local tp_c = TP.toc(tp_elem)
                    return dcl .. [[
CEU_VECTOR_DCL(]]..id..','..tp_c..','..max..[[)
]]
                end
            end
        elseif (not _adt) and TP.check(tp,TP.id(tp)) and ENV.adts[TP.id(tp)] then
            -- var List list;
            return dcl .. tp_c..'* '..id
        else
            return dcl .. tp_c..' '..id
        end

    elseif pre == 'pool' then

        -- ADT:
        -- tceu_pool_adts id = { root=?, pool=_id };
        -- CEU_POOL_DCL(_id);
        if adt then
            assert(not TP.check(tp,'&&','&&'), 'bug found')
            local ptr = (TP.check(tp,'&') and '*') or ''
            dcl = dcl .. [[
/*
 * REF:
 * tceu_pool_adts* x;  // root/pool always the same as the parent
 * PTR:
 * tceu_pool_adts x;   // pool: the same // root: may point to the middle
 */
tceu_pool_adts]]..ptr..' '..id..[[;
]]
        end

        -- static pool: "var T[N] ts"
        if (_adt or _cls) and type(tp.arr)=='table' then
            local ID = (adt and '_' or '') .. id  -- _id for ADT pools
if _cls then
    local tp_id_ = 'CEU_'..tp_id..(top.is_ifc and '_delayed' or '')
    return dcl .. [[
]]..tp_id_..[[* ]]..ID..[[_queue[ ]]..tp.arr.sval..[[ ];
]]..tp_id_..[[  ]]..ID..[[_mem  [ ]]..tp.arr.sval..[[ ];
tceu_pool_orgs ]]..id..[[;
]]
else
            if top.is_ifc then
                return dcl .. [[
CEU_POOL_DCL(]]..ID..',CEU_'..tp_id..'_delayed,'..tp.arr.sval..[[)
]]
                       -- TODO: bad (explicit CEU_)
            else
                return dcl .. [[
CEU_POOL_DCL(]]..ID..',CEU_'..tp_id..','..tp.arr.sval..[[)
]]
                       -- TODO: bad (explicit CEU_)
            end
end
        elseif (not adt) then   -- (top_pool or cls)
            -- ADT doesn't require this NULL pool field
            --  (already has root->pool=NULL)
            if TP.check(tp,'&&') or TP.check(tp,'&') then
                local ptr = ''
                for i=#tp.tt, 1, -1 do
                    local v = tp.tt[i]
                    if v=='&&' or v=='&' then
                        ptr = ptr..'*'
                    else
                        break
                    end
                end
                return dcl .. [[
tceu_pool_orgs]]..ptr..' '..id..[[;
]]
            else
                return dcl .. [[
tceu_pool_orgs ]]..id..[[;
]]
            end
        else
            return dcl
        end
    else
        error'bug found'
    end
end

F = {
    Host = function (me)
        local pre, code = unpack(me)
        -- unescape `##Â´ => `#Â´
        local src = string.gsub(code, '^%s*##',  '#')
              src = string.gsub(src,   '\n%s*##', '\n#')
        CLS().native[pre] = CLS().native[pre] .. [[

#line ]]..me.ln[2]..' "'..me.ln[1]..[["
]] .. src
    end,

    Dcl_adt_pre = function (me)
        local id, op = unpack(me)
        me.struct = 'typedef '
        me.auxs   = {}
        if op == 'union' then
            me.struct = me.struct..[[
struct CEU_]]..id..[[ {
    u8 tag;
    union {
]]
            if me.subs then
                --  data Y with ... end
                --  data X with
                --      ...
                --  or
                --      tag U with
                --          var Y* y;   // is_rec=true
                --      end
                --  end
                for id_sub in pairs(me.subs) do
                    me.struct = me.struct..[[
        CEU_]]..id_sub..' __'..id_sub..[[;
]]
                end
            end
            me.enum = { 'CEU_NONE'..me.n }    -- reserves 0 to catch more bugs
        end

        me.auxs[#me.auxs+1] = [[
void CEU_]]..id..'_free (void* pool, CEU_'..id..[[* me);
]]
    end,
    Dcl_adt = function (me)
        local id, op = unpack(me)
        if op == 'union' then
            me.struct = me.struct .. [[
    };
}
]]
            me.enum = 'enum {\n'..table.concat(me.enum,',\n')..'\n};\n'
        else
            me.struct = string.sub(me.struct, 1, -3)    -- remove leading ';'
        end

        local kill = [[
void CEU_]]..id..'_free (void* pool, CEU_'..id..[[* me) {
]]
        if op == 'union' then
            kill = kill .. [[
    switch (me->tag) {
]]
            for _, tag in ipairs(me.tags) do
                local id_tag = string.upper(id..'_'..tag)
                kill = kill .. [[
        case CEU_]]..id_tag..[[:
]]
                if me.is_rec and tag==me.tags[1] then
                    kill = kill .. [[
            /* base case */
]]
                else
                    kill = kill .. [[
            CEU_]]..id_tag..[[_free(pool, me);
]]
                end
                kill = kill .. [[
            break;
]]
            end
            kill = kill .. [[
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
]]
        end
        kill = kill .. [[
}
]]

        local pack = ''
        local xx = me.__adj_from_opt
        xx =  xx and TP.pop(xx, '&')
        xx =  xx and TP.pop(xx, '[]')

        if xx then-- and (TP.check(xx,'&&','?') or TP.check(xx,'&','?')) then
            local ID = string.upper(TP.opt2adt(xx))
            local tp = 'CEU_'..TP.opt2adt(xx)
            local some = TP.toc(me[4][2][1][1][2])
-- TODO: OPT
            local cls = ENV.clss[string.sub(some,5,-2)]
            if cls and (not cls.is_ifc) then
                some = 'struct '..some      -- due to recursive spawn
            end
            pack = [[
]]..tp..[[ CEU_]]..ID..[[_pack (]]..some..[[ v) {
    ]]..tp..[[ ret;
]]
            if (TP.check(xx,'&&','?') or TP.check(xx,'&','?')) then
                pack = pack .. [[
    if (v == NULL) {
        ret.tag = CEU_]]..ID..[[_NIL;
    } else
]]
            end
            pack = pack .. [[
    {
        ret.tag = CEU_]]..ID..[[_SOME;
        ret.SOME.v = v;
    }
    return ret;
}
#if 0
// TODO: now requires explicit conversions
]]..some..[[ CEU_]]..ID..[[_unpack (]]..tp..[[ me) {
    if (me.tag == CEU_]]..ID..[[_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif
]]
        end

        me.auxs[#me.auxs+1] = kill
        me.auxs[#me.auxs+1] = pack
        me.auxs   = table.concat(me.auxs,'\n')..'\n'
        me.struct = me.struct..' CEU_'..id..';'
        MEM.tops_h = MEM.tops_h..'\n'..(me.enum or '')..'\n'..
                                   me.struct..'\n'

        -- declare a static BASE instance
        if me.is_rec then
            MEM.tops_c = MEM.tops_c..[[
static CEU_]]..id..[[ CEU_]]..string.upper(id)..[[_BASE;
]]
            MEM.tops_init = MEM.tops_init .. [[
CEU_]]..string.upper(id)..[[_BASE.tag = CEU_]]..string.upper(id..'_'..me.tags[1])..[[;
]]
        end

        MEM.tops_c = MEM.tops_c..me.auxs..'\n'
    end,
    Dcl_adt_tag_pre = function (me)
        local top = AST.par(me, 'Dcl_adt')
        local id = unpack(top)
        local tag = unpack(me)
        local enum = 'CEU_'..string.upper(id)..'_'..tag
        top.enum[#top.enum+1] = enum
        -- _ceu_app is required because of OS/assert
        top.auxs[#top.auxs+1] = [[
CEU_]]..id..'* '..enum..'_assert (tceu_app* app, CEU_'..id..[[* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == ]]..enum..[[, "invalid tag", file, line);
    return me;
}
]]

        if top.is_rec and top.tags[1]==tag then
            return  -- base case, no free
        end

        local kill = [[
void ]]..enum..'_free (void* pool, CEU_'..id..[[* me) {
]]
        -- kill all my recursive fields before myself (don't emit ok_killed)
        for _,item in ipairs(top.tags[tag].tup) do
            local _, tp, _ = unpack(item)
            local id_top = id
            local ok = (TP.tostr(tp) == id)
            if (not ok) and top.subs then
                for id_adt in pairs(top.subs) do
                    if TP.tostr(tp) == id_adt then
                        id_top = id_adt
                        ok = true
                    end
                end
            end
            if ok then
                kill = kill .. [[
    CEU_]]..id_top..[[_free(pool, me->]]..tag..'.'..item.var_id..[[);
]]
            end
        end
        kill = kill .. [[
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}
]]
        top.auxs[#top.auxs+1] = kill
    end,

    Dcl_cls_pre = function (me)
        me.struct = [[
typedef struct CEU_]]..me.id..[[ {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ ]]..me.trails_n..[[ ];
]]
        me.native = { [true]='', [false]='' }
        me.funs = ''
    end,
    Dcl_cls_pos = function (me)
        local ifcs_dcls  = ''

        if me.is_ifc then
            me.struct = 'typedef void '..TP.toc(me.tp)..';\n'

            -- interface full declarations must be delayed to after their impls
            -- TODO: HACK_4: delayed declaration until use

            local struct = [[
typedef union CEU_]]..me.id..[[_delayed {
]]
            for v_cls, v_matches in pairs(me.matches) do
                if v_matches and (not v_cls.is_ifc) then
                    -- ifcs have no size
                    if v_cls.id ~= 'Main' then  -- TODO: doesn't seem enough
                        struct = struct..'\t'..TP.toc(v_cls.tp)..' '..v_cls.id..';\n'
                    end
                end
            end
            struct = struct .. [[
} CEU_]]..me.id..[[_delayed;
]]
            me.__env_last_match.__delayed =
                (me.__env_last_match.__delayed or '') .. struct .. '\n'

            for _, var in ipairs(me.blk_ifc.vars) do
                local tp_c = TP.toc(var.tp,{vector_base=true})
                ifcs_dcls = ifcs_dcls ..
                    tp_c..'* CEU_'..me.id..'__'..var.id..' (CEU_'..me.id..'*);\n'

                if var.pre == 'var' then
                    MEM.tops_c = MEM.tops_c..[[
]]..tp_c..'* CEU_'..me.id..'__'..var.id..' (CEU_'..me.id..[[* org) {
    return (]]..tp_c..[[*) (
        ((byte*)org) + _CEU_APP.ifcs_flds[((tceu_org*)org)->cls][
            ]]..ENV.ifcs.flds[var.ifc_id]..[[
        ]
    );
}
]]
                elseif var.pre == 'function' then
                    MEM.tops_c = MEM.tops_c..[[
]]..tp_c..'* CEU_'..me.id..'__'..var.id..' (CEU_'..me.id..[[* org) {
    return (]]..tp_c..[[*) (
        _CEU_APP.ifcs_funs[((tceu_org*)org)->cls][
            ]]..ENV.ifcs.funs[var.ifc_id]..[[
        ]
    );
}
]]
                end
            end
        else
            me.struct  = me.struct..'\n} '..TP.toc(me.tp)..';\n'
        end

        -- native/pre goes before everything
        MEM.native_pre = MEM.native_pre ..  me.native[true]

        if me.id ~= 'Main' then
            -- native goes after class declaration
            MEM.tops_h = MEM.tops_h .. me.native[false] .. '\n'
        end
        MEM.tops_h = MEM.tops_h .. me.struct .. '\n'

        -- TODO: HACK_4: delayed declaration until use
        MEM.tops_h = MEM.tops_h .. (me.__delayed or '') .. '\n'

        MEM.tops_h = MEM.tops_h .. me.funs .. '\n'
        MEM.tops_h = MEM.tops_h .. ifcs_dcls .. '\n'
--DBG('===', me.id, me.trails_n)
--DBG(me.struct)
--DBG('======================')
    end,

    Dcl_fun = function (me)
        local pre, _, ins, out, id, blk = unpack(me)
        local cls = CLS()

        -- input parameters (void* _ceu_go->org, int a, int b)
        local dcl = { 'tceu_app* _ceu_app', 'CEU_'..cls.id..'* __ceu_this' }
        for _, v in ipairs(ins) do
            local _, tp, id = unpack(v)
            dcl[#dcl+1] = MEM.tp2dcl('var', tp, (id or ''), nil, nil, nil)
        end
        dcl = table.concat(dcl,  ', ')

        local tp_out = MEM.tp2dcl('var', out, '', nil, nil, nil)
        if TP.check(out, cls.id) then
            tp_out = 'void'     -- constructor
        end

        me.id = 'CEU_'..cls.id..'_'..id
        me.proto = [[
]]..tp_out..' '..me.id..' ('..dcl..[[)
]]
        if OPTS.os and ENV.exts[id] and ENV.exts[id].pre=='output' then
            -- defined elsewhere
        else
            cls.funs = cls.funs..me.proto..';\n'
        end
    end,

    Stmts_pre = function (me)
        local cls = CLS()
        if cls then
            cls.struct = cls.struct..SPC()..'union {\n'
        end
    end,
    Stmts_pos = function (me)
        local cls = CLS()
        if cls then
            cls.struct = cls.struct..SPC()..'};\n'
        end
    end,

    Block_pos = function (me)
        local top = AST.par(me,'Dcl_adt') or CLS()
        local tag = ''
        if top.tag == 'Dcl_adt' then
            local n = AST.par(me, 'Dcl_adt_tag')
            if n then
                tag = unpack(n)
            end
        end
        top.struct = top.struct..SPC()..'} '..tag..';\n'
    end,
    Block_pre = function (me)
        local DCL = AST.par(me,'Dcl_adt') or CLS()

        DCL.struct = DCL.struct..SPC()..'struct { /* BLOCK ln='..me.ln[2]..' */\n'

        if DCL.tag == 'Dcl_cls' then
            if me.fins then
                for i, fin in ipairs(me.fins) do
                    fin.val = CUR(me, '__fin_'..me.n..'_'..i)
                    DCL.struct = DCL.struct .. SPC()
                                ..'u8 __fin_'..me.n..'_'..i..': 1;\n'
                end
            end
        end

        for _, var in ipairs(me.vars) do
            local len
            --if var.isTmp or var.pre=='event' then  --
            if var.isTmp then --
                len = 0
            elseif var.pre == 'event' then --
                len = 1   --
            elseif var.pre=='pool' and (not TP.check(var.tp,'&')) and (type(var.tp.arr)=='table') then
                len = 10    -- TODO: it should be big
            elseif var.cls or var.adt then
                len = 10    -- TODO: it should be big
                --len = (var.tp.arr or 1) * ?
            elseif TP.check(var.tp,'?') then
                len = 10
            elseif TP.check(var.tp,'[]') then
                len = 10    -- TODO: it should be big
--[[
                local _tp = TP.deptr(var.tp)
                len = var.tp.arr * (TP.deptr(_tp) and TP.types.pointer.len
                             or (ENV.c[_tp] and ENV.c[_tp].len
                                 or TP.types.word.len)) -- defaults to word
]]
            elseif (TP.check(var.tp,'&&') or TP.check(var.tp,'&')) then
                len = TP.types.pointer.len
            elseif (not var.adt) and TP.check(TP.id(var.tp)) and ENV.adts[TP.id(var.tp)] then
                -- var List l
                len = TP.types.pointer.len
            else
                len = ENV.c[TP.id(var.tp)].len
            end
            var.len = len
        end

        -- sort offsets in descending order to optimize alignment
        -- TODO: previous org metadata
        local sorted = { unpack(me.vars) }
        if me~=DCL.blk_ifc and DCL.tag~='Dcl_adt' then
            table.sort(sorted, pred_sort)   -- TCEU_X should respect lexical order
        end

        for _, var in ipairs(sorted) do
            local tp_c  = TP.toc(var.tp)
            local tp_id = TP.id(var.tp)

            if var.inTop then
                var.id_ = var.id
                    -- id's inside interfaces are kept (to be used from C)
            else
                var.id_ = var.id .. '_' .. var.n
                    -- otherwise use counter to avoid clash inside struct/union
            end

            if (var.pre=='var' and (not var.isTmp)) or var.pre=='pool' then
                -- avoid main "ret" if not assigned
                local go = true
                if var.id == '_ret' then
                    local setblock = AST.asr(me,'', 1,'Stmts', 2,'SetBlock')
                    go = setblock.has_escape
                end

                if go then
                    DCL.struct = DCL.struct .. SPC() .. '  ' ..
                                  MEM.tp2dcl(var.pre, var.tp, var.id_, DCL.id)
                                 ..  ';\n'
                end
            end
        end
    end,

    ParOr_pre = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'struct {\n'
    end,
    ParOr_pos = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'};\n'
    end,
    ParAnd_pre = 'ParOr_pre',
    ParAnd_pos = 'ParOr_pos',
    ParEver_pre = 'ParOr_pre',
    ParEver_pos = 'ParOr_pos',

    ParAnd = function (me)
        local cls = CLS()
        for i=1, #me do
            cls.struct = cls.struct..SPC()..'u8 __and_'..me.n..'_'..i..': 1;\n'
        end
    end,

    Await = function (me)
        local _, dt = unpack(me)
        if dt then
            local cls = CLS()
            cls.struct = cls.struct..SPC()..'s32 __wclk_'..me.n..';\n'
        end
    end,

    Thread_pre = 'ParOr_pre',
    Thread = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'CEU_THREADS_T __thread_id_'..me.n..';\n'
        cls.struct = cls.struct..SPC()..'s8*       __thread_st_'..me.n..';\n'
    end,
    Thread_pos = 'ParOr_pos',
}

AST.visit(F)

end

    
do
-- TODO:
-- remove V({tag='Var',...})
-- ficar so com rval e usar & qdo necessario


local _ceu2c = { ['&&']='&', ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

local F

-- val=[lval,rval]
-- evt
-- adt_top
-- adt_pool
-- no_cast
function V (me, ...)
    local CTX = ...
    if type(CTX) ~= 'table' then
        CTX = {}
        for i=1, select('#',...) do
            local ctx = select(i,...)
            if ctx then
                assert(type(ctx)=='string', 'bug found')
                if ctx=='lval' or ctx=='rval' then
                    CTX.val = ctx
                else
                    CTX[ctx] = ctx
                end
            end
        end
    end
    assert(CTX.val or CTX.evt)

    local f = assert(F[me.tag], 'bug found : V('..me.tag..')')
    while type(f) == 'string' do
        f = assert(F[f], 'bug found : V('..me.tag..')')
    end

    local VAL = f(me, CTX)

    return string.gsub(VAL, '^%(%&%(%*(.-)%)%)$', '(%1)')
            -- (&(*(...))) => (((...)))
end

local function ctx_copy (CTX)
    local ret = {}
    for k,v in pairs(CTX) do
        ret[k] = v
    end
    return ret
end

local function tpctx2op (tp, CTX)
    local tp_id = TP.id(tp)
    local adt = ENV.adts[tp_id]
    local adt_isrec = adt and adt.is_rec

    if CTX.val == 'lval' then
        if TP.check(tp,'&') then
            return ''
        else
            if TP.check(tp,'[]') and TP.is_ext(tp,'_') then
                return ''
            elseif adt_isrec then
                if TP.check(tp,tp_id) then
                    -- lll.CONS.tail
                    -- has type "List", but in C is actually already "List*"
                    return ''
                else
                    return '&'
                end
            else
                return '&'
            end
        end
    else  -- rval
        assert(CTX.val == 'rval', 'bug found')
        if TP.check(tp,'&') then
            if TP.check(tp,'[]','&') and TP.is_ext(tp,'_') then
                return ''
            else
                return '*'
            end
        else
            if adt_isrec and TP.check(tp,'[]','&&','-&') then
                return '&'
            else
                return ''
            end
        end
    end
end

F =
{
    __var = function (me, VAL, CTX)
        local cls = (me.org and me.org.cls) or CLS()
        local var = me.var or me

        local tp_id = TP.id(var.tp)
        local adt = ENV.adts[tp_id]
        local adt_isrec = adt and adt.is_rec

        if var.pre=='var' or var.pre=='pool' then

            local op = tpctx2op(var.tp, CTX)
            VAL = '('..op..VAL..')'

            -- handles adt_top, adt_root, adt_pool
            if var.pre=='pool' and adt and adt.is_rec then
                if CTX.adt_pool then
                    --VAL = '('..VAL..')'
                elseif CTX.adt_top then
                    -- VAL
                else -- adt_root
                    local is_ptr = TP.check(var.tp,'&&','-&')
                    local tp_id = 'CEU_'..TP.id(var.tp)
                    local CAST
                    if CTX.val == 'lval' then
                        if is_ptr then
                            CAST = '('..tp_id..'**)'
                            VAL  = '(& ((tceu_pool_adts*) '..VAL..')->root)'
                        else
                            CAST = '('..tp_id..' *)'
                            VAL  = '(  ((tceu_pool_adts*) '..VAL..')->root)'
                        end
                    else
                        if is_ptr then
                            CAST = '('..tp_id..' *)'
                            VAL  = '(  ((tceu_pool_adts*) '..VAL..')->root)'
                        else
                            error'bug found'
                        end
                    end
                    if not CTX.no_cast then
                        VAL = '('..CAST..VAL..')'
                    end
                end
            end

        elseif var.pre == 'function' then
            VAL = 'CEU_'..cls.id..'_'..var.id
        elseif var.pre == 'event' then
            assert(CTX.evt)
            return var.evt.idx
        elseif var.pre == 'output' then
            VAL = nil
        elseif var.pre == 'input' then
            VAL = nil
        else
            error 'not implemented'
        end

        return VAL
    end,

    Dcl_var = 'Var',
    Var = function (me, CTX)
        local var = me.var
        local tp_id = TP.id(var.tp)
        local adt = ENV.adts[tp_id]

        local VAL
        if adt and adt.is_rec and CTX.adt_pool then
            VAL = CUR(me, '_'..var.id_)
        elseif var.isTmp then
            VAL = '__ceu_'..var.id..'_'..var.n
        else
            VAL = CUR(me, var.id_)
        end

        local field = AST.par(me, 'Field')
        if not (field and field[3]==me) then
            VAL = F.__var(me, VAL, CTX)
        end

        return VAL
    end,

    Field = function (me, CTX)
        local gen = '((tceu_org*)'..V(me.org,'lval')..')'
        if me.org.cls and me.org.cls.is_ifc then
            if me.var.pre == 'var'
            or me.var.pre == 'pool' then
                local cast = TP.toc(me.var.tp,{vector_base=true})..'*'
                if me.var.pre=='var' and me.var.tp.arr then
                    cast = TP.toc(me.var.tp,{vector_base=true})
                    if (not TP.is_ext(me.var.tp,'_','@')) then
                        local cls = ENV.clss[TP.id(me.var.tp)] and
                                    TP.check(TP.pop(me.var.tp,'&'),TP.id(me.var.tp),'[]')
                        if not cls then
                            cast = 'tceu_vector*'
                            if TP.check(me.var.tp,'&') then
                                cast = cast..'*'
                            end
                        end
                    end
                elseif me.var.pre == 'pool' then
                    cast = 'tceu_pool_orgs*'
                end

                -- LVAL
                VAL = [[(
(]]..cast..[[) (
#line ]]..me.org.ln[2]..' "'..me.org.ln[1]..[["
    ((byte*)]]..gen..[[) + _CEU_APP.ifcs_flds[]]..gen..[[->cls][
        ]]..ENV.ifcs.flds[me.var.ifc_id]..[[
    ]
        )
#line ]]..me.org.ln[2]..' "'..me.org.ln[1]..[["
)]]
                -- RVAL
                if TP.check(me.var.tp,'[]') and TP.is_ext(me.var.tp,'_') then
                    -- LVAL==RVAL
                else
                    VAL = '(*'..VAL..')'
                end

                --end
                local op = tpctx2op(me.var.tp, CTX)
                VAL = '('..op..VAL..')'
            elseif me.var.pre == 'function' then
                VAL = [[(*(
(]]..TP.toc(me.var.tp)..[[*) (
    _CEU_APP.ifcs_funs[]]..gen..[[->cls][
        ]]..ENV.ifcs.funs[me.var.ifc_id]..[[
    ]
        )
))]]
            elseif me.var.pre == 'event' then
                assert(CTX.evt)
                return '(_CEU_APP.ifcs_evts['..gen..'->cls]['
                                ..ENV.ifcs.evts[me.var.ifc_id]
                           ..'])'
            else
                error 'not implemented'
            end
        else
            if me.c then
                VAL = me.c.id_
            else
                assert(me.var, 'bug found')
                VAL = '('..V(me.org,'rval')..'.'..me.var.id_..')'
                VAL = F.__var(me, VAL, CTX)
            end
        end
        return VAL
    end,

    ----------------------------------------------------------------------

    Adt_constr_one = function (me, CTX)
        return me.val   -- set by hand in code.lua
    end,

    ----------------------------------------------------------------------

    Global = function (me, CTX)
        if CTX.val == 'lval' then
            return '(&(_ceu_app->data))'
        else
            return '(_ceu_app->data)'
        end
    end,

    Outer = function (me, CTX)
        if CTX.val == 'lval' then
            return '(('..TP.toc(me.tp)..'*)_ceu_org)'
        else
            return '(*(('..TP.toc(me.tp)..'*)_ceu_org))'
        end
    end,

    This = function (me, CTX)
        local VAL
        if AST.iter'Dcl_constr'() then
            VAL = '__ceu_this'    -- set when calling constr
        else
            VAL = '_ceu_org'
        end
        if CTX.val == 'lval' then
            return '(('..TP.toc(me.tp)..'*)'..VAL..')'
        else
            return '(*(('..TP.toc(me.tp)..'*)'..VAL..'))'
        end
    end,

    ----------------------------------------------------------------------

    Op2_call = function (me, CTX)
        local _, f, exps = unpack(me)
        local ps = {}
        if f.var and f.var.fun then
            -- (tceu_app*, tceu_org*, ...)
            ps[#ps+1] = '_ceu_app'
            if f.org then
                ps[#ps+1] = V(f.org,'lval')   -- only native
            else
                ps[#ps+1] = CUR(me)
            end
            --ps[#ps] = '(tceu_org*)'..ps[#ps]
        else
            f.is_call = true
        end
        for i, exp in ipairs(exps) do
            ps[#ps+1] = V(exp, 'rval')

            -- for native function calls, convert the vector argument to its internal buffer
            if not (f.var and f.var.fun) then
                if TP.check(exp.tp,'[]','&&','-&') then
                    if ENV.clss[TP.id(exp.tp)] and
                      TP.check(exp.tp, TP.id(exp.tp),'[]','&&','-&')
                    then
                        error'bug found'
                    elseif not TP.is_ext(exp.tp,'_') then
                        -- f(&&vec);
                        local cast = TP.toc(TP.pop(TP.pop(exp.tp,'&'),'&&'),{vector_base=true})
                        if TP.check(exp.tp,'char','[]','&&','-&') then
                            ps[#ps] = 'ceu_vector_tochar('..ps[#ps]..')'
                        else
                            ps[#ps] = '(('..cast..')'..ps[#ps]..'->mem)'
                        end
                    end
                end
            end
        end

        local op = ''
        if f.var and f.var.fun then
            op = tpctx2op (f.var.fun.out, CTX)
        end
        if op == '' then
            if f.c and f.c.mod=='@plain' then
                -- struct constructor: _Rect(x,y,dx,dy)
                return [[

#ifdef __cplusplus
    ]]..V(f,CTX)..'('..table.concat(ps,',')..[[)
#else
    {]]..table.concat(ps,',')..[[}
#endif
]]
            else
                -- avoid paranthesis because of macro expansions
                return V(f,CTX)..'('..table.concat(ps,',')..')'
            end
        else
            return '('..op..V(f,CTX)..'('..table.concat(ps,',')..'))'
        end
    end,

    Op2_idx = function (me, CTX)
        local _, arr, idx = unpack(me)
        local VAL

        local cls = ENV.clss[TP.id(me.tp)]

        if cls and TP.check(me.tp,TP.id(me.tp))
        or TP.is_ext(arr.tp,'_','@')
        then
            VAL = V(arr,'rval')..'['..V(idx,'rval')..']'
            if CTX.val == 'lval' then
                VAL = '(&'..VAL..')'
            end
        else
            if CTX.val == 'lval' then
                VAL = '(('..TP.toc(me.tp)..'*)ceu_vector_geti_ex('..V(arr,'lval')..','..V(idx,'rval')..',__FILE__,__LINE__))'
            else
                VAL = '(*(('..TP.toc(me.tp)..'*)ceu_vector_geti_ex('..V(arr,'lval')..','..V(idx,'rval')..',__FILE__,__LINE__)))'
            end
        end

        return VAL
    end,

    Op2_any = function (me, CTX)
        local op, e1, e2 = unpack(me)
        return '('..V(e1,CTX)..ceu2c(op)..V(e2,CTX)..')'
    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me, CTX)
        local op, e1 = unpack(me)
        return '('..ceu2c(op)..V(e1,CTX)..')'
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',
    ['Op1_+']   = 'Op1_any',
    ['Op1_not'] = 'Op1_any',

    ['Op1_*'] = function (me, CTX)
        local op, e1 = unpack(me)
        op = (CTX.val=='lval' and '') or ceu2c(op)
        CTX = ctx_copy(CTX)
        CTX.val = 'rval'
        local ret = '('..op..V(e1,CTX)..')'
        return ret
    end,
    ['Op1_&'] = function (me, CTX)
        local op, e1 = unpack(me)
        CTX = ctx_copy(CTX)
        CTX.val = 'lval'
        local ret = V(e1, CTX)
        if e1.var and e1.var.pre=='pool' then
            if ENV.clss[TP.id(e1.var.tp)] then
                -- ret
            else
                ret = '((tceu_pool_adts*)'..ret..')'
            end
        end
        return ret
    end,
    ['Op1_&&'] = function (me, CTX)
        local op, e1 = unpack(me)
        CTX = ctx_copy(CTX)

-- TODO: just use the first case?
        --if CTX.val == 'lval' then
            --return '(&'..V(e1, CTX)..')'
        --else
            CTX.val = 'lval'
            return V(e1, CTX)
        --end
    end,
    ['Op1_?'] = function (me, CTX)
        local op, e1 = unpack(me)
        local ID = string.upper(TP.opt2adt(e1.tp))
        return '('..V(e1,CTX)..'.tag != CEU_'..ID..'_NIL)'
    end,

    ['Op1_!'] = function (me, CTX)
        local _, e1 = unpack(me)
        local var = e1.var or e1
        local ID = string.upper(TP.opt2adt(var.tp))

        local op = tpctx2op(TP.pop(var.tp,'?'), CTX)
        return '('..op..'(CEU_'..ID..'_SOME_assert(_ceu_app, '
                  ..V(e1,'lval')..',__FILE__,__LINE__)->SOME.v))'
    end,

    ['Op1_$'] = function (me, CTX)
        local op, e1 = unpack(me)
        return '(ceu_vector_getlen('..V(e1,'lval')..'))'
    end,
    ['Op1_$$'] = function (me, CTX)
        local op, e1 = unpack(me)
        return '(ceu_vector_getmax('..V(e1,'lval')..'))'
    end,

    ['Op2_.'] = function (me, CTX)
        local op, e1, id = unpack(me)
        local VAL
        if me.__env_tag then
            local op_fld = '.' -- TODO: REMOVE
            local tag
            -- [union.TAG].field is 'void'
            if TP.tostr(e1.tp) ~= 'void' then
                tag = ('CEU_'..string.upper(TP.id(e1.tp))..'_'..id)
                local adt = ENV.adts[TP.id(e1.tp)]
                if adt.is_rec then
                    op_fld  = '->'
                end
            end

            if me.__env_tag == 'test' then
                VAL  = '('..V(e1,'lval')..'->tag == '..tag..') /* XXXX */'
            elseif me.__env_tag == 'assert' then
                VAL  = '('..tag..'_assert(_ceu_app, '..V(e1,'lval')..', __FILE__, __LINE__)->'..id..')'
            elseif me.__env_tag == 'field' then
                VAL  = '('..V(e1,'rval')..op_fld..id..')'
            end
        else
            VAL  = '('..V(e1,'rval')..'.'..id..')'
        end
        local op = tpctx2op(me.tp,CTX)
        VAL = '('..op..VAL..')'
        return VAL
    end,

    Op1_cast = function (me, CTX)
        local tp, exp = unpack(me)
        local VAL = V(exp, CTX)

        if tp.tag == 'Type' then
            local cls = (TP.check(tp,'&&','-&') and ENV.clss[TP.id(tp)])
            if cls then
                if cls.is_ifc then
                    -- TODO: out of bounds acc
                    VAL = '(('..VAL..' == NULL) ? NULL : '..
                            '((_CEU_APP.ifcs_clss[((tceu_org*)'..VAL..')->cls]'
                                ..'['..cls.n..']) ?'..VAL..' : NULL)'..
                          ')'
                else
                    VAL = '(('..VAL..' == NULL) ? NULL : '..
                            '((((tceu_org*)'..VAL..')->cls == '..cls.n..') ? '
                            ..VAL..' : NULL)'..
                          ')'
                end
            elseif TP.check(tp,'char','&&') and
                   TP.check(exp.tp,'char','[]','&&','-&')
            then
                -- (char&&)&&str  =>  str.mem
                return '((char*)'..VAL..'->mem)'
            end
            return '(('..TP.toc(tp)..')'..VAL..')'
        else -- @annotation
            return VAL
        end
    end,

    ----------------------------------------------------------------------

    WCLOCKK = function (me, CTX)
        assert(CTX.val == 'rval', 'bug found')
        return '((s32)'..me.us..')'
    end,

    WCLOCKE = function (me, CTX)
        assert(CTX.val == 'rval', 'bug found')
        local exp, unit = unpack(me)
        return '((s32)'.. V(exp,CTX) .. ')*' .. SVAL.t2n[unit]
    end,

    RawExp = function (me, CTX)
        --assert(CTX.val == 'rval', 'bug found')
        return (unpack(me))
    end,

    Type = function (me, CTX)
        assert(CTX.val == 'rval', 'bug found')
        return TP.toc(me)
    end,

    Nat = function (me, CTX)
        --assert(CTX.val == 'rval', 'bug found')
        local VAL = string.sub(me[1], 2)
        if CTX.val=='lval' and (not me.is_call) then
            VAL = '(&'..VAL..')'
        end
        return VAL
    end,
    SIZEOF = function (me, CTX)
        assert(CTX.val == 'rval', 'bug found')
        local tp = unpack(me)
        return 'sizeof('..V(tp,CTX)..')'
    end,
    STRING = function (me, CTX)
        --assert(CTX.val == 'rval', 'bug found')
        return me[1]
    end,
    NUMBER = function (me, CTX)
        assert(CTX.val == 'rval', 'bug found')
        return me[1]
    end,
    NULL = function (me, CTX)
        --assert(CTX.val == 'rval', 'bug found')
        return 'NULL'
    end,
    ANY = function (me)
        local v = unpack(me)
        if TP.isNumeric(v) then
            return '0'
        else
            return 'NULL'
        end
    end,
}

end

    
do
CODE = {
    has_goto  = false,   -- avoids "unused label"
    pres      = '',
    constrs   = '',
    threads   = '',
    isrs      = '',
    functions = '',
    stubs     = '',     -- maps input functions to ceu_app_call switch cases
}

-- Assert that all input functions have bodies.
local INPUT_FUNCTIONS = {
    -- F1 = false,  -- input function w/o body
    -- F2 = true,   -- input functino w/  body
}

function CONC_ALL (me, t)
    t = t or me
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            CONC(me, sub)
        end
    end
end

function CONC (me, sub, tab)
    sub = sub or me[1]
    tab = string.rep(' ', tab or 0)
    me.code = me.code .. string.gsub(sub.code, '(.-)\n', tab..'%1\n')
end

function CASE (me, lbl)
    LINE(me, 'case '..lbl.id..':;', 0)
end

function DEBUG_TRAILS (me, lbl)
    LINE(me, [[
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
]])
end

function LINE (me, line, spc)
    spc = spc or 4
    spc = string.rep(' ', spc)
    me.code = me.code .. [[

#line ]]..me.ln[2]..' "'..me.ln[1]..[["
]] .. spc..line
end

function LABEL_NO (me)
    local no = '_CEU_NO_'..me.n..'_'
    LINE(me, [[
]]..no..[[:
if (0) { goto ]]..no..[[; /* avoids "not used" warning */ }
]])
    return no
end

function HALT (me, t)
    if not t then
        LINE(me, 'return;')
        return
    end

    LINE(me, [[
_ceu_trl->evt = ]]..t.evt..[[;
_ceu_trl->lbl = ]]..t.lbl..[[;
_ceu_trl->seqno = ]]..(t.isEvery and '_ceu_app->seqno-1' or '_ceu_app->seqno')..[[;
]])

    if t.evto then
        LINE(me, [[
#ifdef CEU_ORGS
_ceu_trl->evto  = ]]..t.evto..[[;
#endif
]])
    end

    if t.org_or_adt then
        LINE(me, [[
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = ]]..t.is_org..[[;
#endif
#endif
_ceu_trl->org_or_adt = ]]..t.org_or_adt..[[;
]])
    end

    if t.evt == 'CEU_IN__ASYNC' then
        LINE(me, [[
#ifdef ceu_out_async
ceu_out_async(_ceu_app);
#endif
    _ceu_app->pendingAsyncs = 1;
]])
    end

    LINE(me, [[
return;

case ]]..t.lbl..[[:;
]])

    if t.no and PROPS.has_pses then
        local function __pause_or_dclcls (me)
            return me.tag=='Pause' or me.tag=='Dcl_cls'
        end
        for pse in AST.iter(__pause_or_dclcls) do
            if pse.tag == 'Dcl_cls' then
                break
            end
            COMM(me, 'PAUSE: '..pse.dcl.var.id)
            LINE(me, [[
if (]]..V(pse.dcl,'rval')..[[) {
    goto ]]..t.no..[[;
}
]])
        end
    end
end

function GOTO (me, lbl)
    CODE.has_goto = true
    LINE(me, [[
_ceu_lbl = ]]..lbl..[[;
goto _CEU_GOTO_;
]])
end

function COMM (me, comm)
    LINE(me, '/* '..comm..' */', 0)
end

local _iter = function (n)
    if n.tag == 'Dcl_cls' then
        return true
    end
    if n.tag == 'Block' and n.needs_clr then
        return true
    end
    if n.tag == 'SetBlock' and n.needs_clr then
        return true
    end
    if n.tag == 'Loop' and n.needs_clr then
        return true
    end
    n = n.__par
    if n and (n.tag == 'ParOr') then
        return true     -- par branch
    end
end

-- TODO: check if all calls are needed
--          (e.g., cls outermost block should not!)
function CLEAR (me)

    COMM(me, 'CLEAR: '..me.tag..' ('..me.ln[2]..')')

    if ANA and me.ana.pos[false] then
        return
    end
    if not me.needs_clr then
        return
    end

    -- check if top will clear during same reaction
    if (not me.has_orgs) and (not me.needs_clr_fin) then
        if ANA then   -- fin must execute before any stmt
            local top = AST.iter(_iter)()
            if top and top.needs_clr
                and ANA.IS_EQUAL(top.ana.pos, me.ana.pos)
            then
-- TODO: emit/kill in between the two breaks this
-- TODO: check on concat if previous is clear, and override it with outer
                --return  -- top will clear
            end
        end
    end

    LINE(me, [[
{
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  ]]..me.trails[1]..[[,
                  ]]..(me.trails[2]+1)..[[);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        ]]..me.trails[1]..','..me.trails[2]..[[);
#endif
}
]])

    if me.has_orgs then
        -- TODO: only if contains orgs of awaited classes
        LINE(me, [[
#ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, ]]..me.trails[1]..','..me.trails[2]..[[ };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif
]])
    end
end

F = {
    Node_pre = function (me)
        me.code =  me.code or '/* NODE: '..me.tag..' '..me.n..' */\n'
    end,

    Do         = CONC_ALL,
    Finally    = CONC_ALL,

    Dcl_constr = function (me)
        CONC_ALL(me)
        CODE.constrs = CODE.constrs .. [[
static void _ceu_constr_]]..me.n..[[ (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
]] .. me.code .. [[
}
]]
    end,

    Stmts = function (me)
        LINE(me, '{')   -- allows C declarations for Spawn
        CONC_ALL(me)
        LINE(me, '}')
    end,

    Root = function (me)
        for _, cls in ipairs(ENV.clss_cls) do
            me.code = me.code .. cls.code_cls
        end

        -- assert that all input functions have bodies
        for evt, v in pairs(INPUT_FUNCTIONS) do
            ASR(v, evt.ln, 'missing function body')
        end
    end,

    BlockI = CONC_ALL,
    BlockI_pos = function (me)
        -- Interface constants are initialized from outside
        -- (another _ceu_go_org), need to use __ceu_org instead.
        me.code_ifc = string.gsub(me.code, '_ceu_org', '__ceu_this')
        me.code = ''
    end,

    Dcl_fun = function (me)
        local pre, _, ins, out, id, blk = unpack(me)
        if blk then
            if me.var.fun.isExt then
                local ps = {}
                assert(ins.tup, 'bug found')
                for i, _ in ipairs(ins) do
                    ps[#ps+1] = '(('..TP.toc(ins)..'*)((void*)param))->_'..i
                end
                ps = (#ps>0 and ',' or '')..table.concat(ps, ',')

                CODE.functions = CODE.functions .. [[
#define ceu_in_call_]]..id..[[(app,org,param) ]]..me.id..[[(app,org ]]..ps..[[)
]]

                local ret_value, ret_void
                if TP.toc(out) == 'void' then
                    ret_value = '('
                    ret_void  = 'return NULL;'
                else
                    ret_value = 'return ((void*)'
                    ret_void  = ''
                end

                CODE.stubs = CODE.stubs .. [[
case CEU_IN_]]..id..[[:
#line ]]..me.ln[2]..' "'..me.ln[1]..[["
    ]]..ret_value..me.id..'(_ceu_app, _ceu_app->data '..ps..[[));
]]..ret_void..'\n'
            end

            -- functions and threads receive __ceu_org as parameter
            local code = string.gsub(blk.code, '_ceu_org', '__ceu_this')
            CODE.functions = CODE.functions ..
                me.proto..'{'..code..'}'..'\n'
        end

        -- assert that all input functions have bodies
        local evt = ENV.exts[id]
        if me.var.fun.isExt and evt and evt.pre=='input' then
            INPUT_FUNCTIONS[evt] = INPUT_FUNCTIONS[evt] or blk or false
        end
    end,
    Return = function (me)
        local exp = unpack(me)
        LINE(me, 'return '..(exp and V(exp,'rval') or '')..';')
    end,

    Dcl_cls_pos = function (me)
        me.code_cls = me.code
        me.code     = ''        -- do not inline in enclosing class
    end,
    Dcl_cls = function (me)
        if me.is_ifc then
            CONC_ALL(me)
            return
        end
        if me.has_pre then
            CODE.pres = CODE.pres .. [[
static void _ceu_pre_]]..me.n..[[ (tceu_app* _ceu_app, tceu_org* __ceu_this) {
]] .. me.blk_ifc[1][1].code_ifc .. [[
}
]]
        end

        CASE(me, me.lbl)

        CONC_ALL(me)

        if ANA and me.ana.pos[false] then
            return      -- never reachable
        end

        -- stop
        if me == MAIN then
            LINE(me, [[
#if defined(CEU_RET) || defined(CEU_OS)
_ceu_app->isAlive = 0;
#endif
]])
        else
            LINE(me, [[
ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif
]])
        end
        HALT(me)

        -- TODO-RESEARCH-2:
    end,

    -- TODO: C function?
    _ORG = function (me, t)
        COMM(me, 'start org: '..t.id)

        --[[
class T with
    <PRE>           -- 1    org: me.lbls_pre[i].id
    var int v = 0;
do
    <BODY>          -- 3    org: me.lbls_body[i].id
end

<...>               -- 0    parent:

var T t with
    <CONSTR>        -- 2    org: no lbl (cannot call anything)
end;

<CONT>              -- 4    parent:
]]

        -- ceu_out_org, _ceu_constr_
        local org = t.arr and '((tceu_org*) &'..t.val..'['..t.val_i..']'..')'
                           or '((tceu_org*) &'..t.val..')'
        -- each org has its own trail on enclosing block
        if t.arr then
            LINE(me, [[
for (]]..t.val_i..[[=0; ]]..t.val_i..'<'..t.arr.sval..';'..t.val_i..[[++)
{
]])     end
        LINE(me, [[
    /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ]]..org..','..t.cls.trails_n..','..t.cls.lbl.id..[[,
                     ]]..t.cls.n..[[,
                     ]]..t.isDyn..[[,
                     ]]..t.parent_org..','..t.parent_trl..[[);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */
]])

        --  traverse <...> with
        --      var int x = y;      // executes in _pre, before the constructor
        --  do
        if me.__adj_is_traverse_root then
            LINE(me, [[
    ((]]..TP.toc(t.cls.tp)..'*)'..org..[[)->_out = 
        (__typeof__(((]]..TP.toc(t.cls.tp)..'*)'..org..[[)->_out)) _ceu_org;
]])
        elseif me.__adj_is_traverse_rec then
            LINE(me, [[
    ((]]..TP.toc(t.cls.tp)..'*)'..org..[[)->_out =
        ((]]..TP.toc(t.cls.tp)..[[*)_ceu_org)->_out;
]])
        end

        if t.cls.has_pre then
            LINE(me, [[
    _ceu_pre_]]..t.cls.n..[[(_ceu_app, ]]..org..[[);
]])
        end
        if t.constr then
            LINE(me, [[
    _ceu_constr_]]..t.constr.n..[[(_ceu_app, ]]..org..[[, _ceu_org);
]])
        end

        LINE(me, [[
{
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, ]]..me.trails[1]..[[, ]]..me.trails[2]..[[, 1 };
    ceu_app_go(_ceu_app,NULL,
               ]]..org..[[, &]]..org..[[->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ]]..org..[[, &]]..org..[[->trls[0],
               NULL);
#endif
]])
        if t.set then
                LINE(me, [[
    if (!]]..org..[[->isAlive) {
        ]]..V(t.set,'rval')..' = '..string.upper(TP.toc(t.set.tp))..[[_pack(NULL);
    }
]])
        end
        LINE(me, [[
}
]])
        if t.arr then
            LINE(me, [[
}
]])
        end
    end,

    Dcl_var = function (me)
        local _,_,_,constr = unpack(me)
        local var = me.var
-- TODO
me.tp = var.tp
        if var.cls then
            F._ORG(me, {
                id     = var.id,
                isDyn  = 0,
                cls    = var.cls,
                val    = V(me,'rval'),
                constr = constr,
                arr    = var.tp.arr,
                val_i  = TP.check(var.tp,'[]') and V({tag='Var',tp=var.tp,var=var.constructor_iterator},'rval'),
                parent_org = '_ceu_org',
                parent_trl = var.trl_orgs[1],
            })

        -- TODO: similar code in Block_pre for !BlockI
        elseif AST.par(me,'BlockI') and TP.check(var.tp,'?') then
            if not var.isTmp then   -- ignore unused var
                -- has be part of cls_pre to execute before possible binding in constructor
                -- initialize to nil
                local ID = string.upper(TP.opt2adt(var.tp))
                LINE(me, [[
    ]]..V({tag='Var',tp=var.tp,var=var},'rval')..[[.tag = CEU_]]..ID..[[_NIL;
    ]])
            end
        end
    end,

    Adt_constr_root = function (me)
        local dyn, one = unpack(me)

        LINE(me, '{')

        local set = assert(AST.par(me,'Set'), 'bug found')
        local _,_,_,to = unpack(set)

        if not dyn then
            CONC(me, one)
            F.__set(me, one, to)
        else
            local set = assert(AST.par(me,'Set'), 'bug found')
            F.__set_adt_mut_conc_fr(me, set, one)
        end

        LINE(me, '}')
    end,

    ExpList = CONC_ALL,
    Adt_constr_one = function (me)
        local adt, params = unpack(me)
        local id, tag = unpack(adt)
        adt = assert(ENV.adts[id])

        local root = AST.par(me, 'Adt_constr_root')

        -- CODE-1: declaration, allocation
        -- CODE-2: all children
        -- CODE-3: assignment
        --          { requires all children }

        me.val = '__ceu_adt_'..me.n

        -- CODE-1
        if not adt.is_rec then
            -- CEU_T t;
            LINE(me, [[
CEU_]]..id..' '..me.val..[[;
]])
        else
            -- CEU_T* t;
            LINE(me, [[
CEU_]]..id..'* '..me.val..[[;
]])

            -- base case
            if adt.is_rec and tag==adt.tags[1] then
                LINE(me,
me.val..' = &CEU_'..string.upper(id)..[[_BASE;
]])

            -- other cases
            else
                local tp = 'CEU_'..id

                -- extract pool from set
                --      to.x.y = new z;
                -- i.e.,
                --      to.root.pool
                local set = assert( AST.par(me,'Set'), 'bug found' )
                local _,_,_,to = unpack(set)
                local pool = ADT.find_pool(to)
                pool = '('..V(pool,'lval','adt_top')..'->pool)'

                LINE(me, [[
#if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (]]..pool..[[ == NULL) {
    ]]..me.val..[[ = (]]..tp..[[*) ceu_out_realloc(NULL, sizeof(]]..tp..[[));
} else {
    ]]..me.val..[[ = (]]..tp..[[*) ceu_pool_alloc((tceu_pool*)]]..pool..[[);
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    ]]..me.val..[[ = (]]..tp..[[*) ceu_out_realloc(NULL, sizeof(]]..tp..[[));
#elif defined(CEU_ADTS_NEWS_POOL)
    ]]..me.val..[[ = (]]..tp..[[*) ceu_pool_alloc((tceu_pool*)]]..pool..[[);
#endif
]])

                -- fallback to base case if fails
                LINE(me, [[
if (]]..me.val..[[ == NULL) {
    ]]..me.val..[[ = &CEU_]]..string.upper(id)..[[_BASE;
} else  /* rely on {,} that follows */
]])
            end
        end

        LINE(me, '{')   -- will ignore if allocation fails

        -- CODE-2
        CONC(me, params)

        -- CODE-3
        local op = (adt.is_rec and '->' or '.')
        local blk,_
        if tag then
            -- t->tag = TAG;
            if not (adt.is_rec and tag==adt.tags[1]) then
                -- not required for base case
                LINE(me, me.val..op..'tag = CEU_'..string.upper(id)..'_'..tag..';')
            end
            blk = ENV.adts[id].tags[tag].blk
            tag = tag..'.'
        else
            _,_,blk = unpack(ENV.adts[id])
            tag = ''
        end
        for i, p in ipairs(params) do
            local field = blk.vars[i]
            local amp = ''--(TP.check(field.tp,'&') and '&') or ''
            LINE(me, me.val..op..tag..field.id..' = '..amp..V(p,'rval')..';')
        end

        LINE(me, '}')   -- will ignore if allocation fails
    end,

    Kill = function (me)
        local org, exp = unpack(me)
        if exp then
            LINE(me, [[
((tceu_org*)]]..V(org,'lval')..')->ret = '..V(exp,'rval')..[[;
]])
        end

        local org_cast = '((tceu_org*)'..V(org,'lval')..')'
        LINE(me, [[
{
    tceu_stk stk_ = { _ceu_stk, _ceu_org, ]]..me.trails[1]..[[, ]]..me.trails[2]..[[, 1 };
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt, &stk_,
                  ]]..org_cast..[[, 0, ]]..org_cast..[[->n);

    ceu_sys_org_free(_ceu_app,]]..org_cast..[[);

#ifdef CEU_ORGS_AWAIT
    /* signal ok_killed */
    {
        tceu_kill ps = { ]]..org_cast..','..org_cast..'->ret, 0, (tceu_ntrl)('..org_cast..[[->n-1)  };
        tceu_evt evt_;
                 evt_.id = CEU_IN__ok_killed;
                 evt_.param = &ps;
        ceu_sys_go_ex(_ceu_app, &evt_, &stk_,
                      _ceu_app->data, 0, _ceu_app->data->n);
    }
    if (!stk_.is_alive) {
        return;
    }
#endif
}
]])
    end,

    Spawn = function (me)
        local id, pool, constr = unpack(me)
        local ID = '__ceu_new_'..me.n
        local set = AST.par(me, 'Set')

        LINE(me, [[
/*{*/
    tceu_org* ]]..ID..[[;
]])
        if pool and (type(pool.var.tp.arr)=='table') then
            -- static
            LINE(me, [[
    ]]..ID..[[ = (tceu_org*) ceu_pool_alloc(&]]..V(pool,'rval')..[[.pool);
]])
        elseif TP.check(pool.var.tp,'&&') or TP.check(pool.var.tp,'&') then
            -- pointer don't know if is dynamic or static
            LINE(me, [[
#if !defined(CEU_ORGS_NEWS_MALLOC)
    ]]..ID..[[ = (tceu_org*) ceu_pool_alloc(&]]..V(pool,'rval')..[[.pool);
#elif !defined(CEU_ORGS_NEWS_POOL)
    ]]..ID..[[ = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_]]..id..[[));
#else
    if (]]..V(pool,'rval')..[[.pool.queue == NULL) {
        ]]..ID..[[ = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_]]..id..[[));
    } else {
        ]]..ID..[[ = (tceu_org*) ceu_pool_alloc(&]]..V(pool,'rval')..[[.pool);
    }
#endif
]])
        else
            -- dynamic
            LINE(me, [[
    ]]..ID..[[ = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_]]..id..[[));
]])
        end

        if set then
            local set_to = set[4]
            LINE(me, V(set_to,'rval')..' = '..
                '('..string.upper(TP.toc(set_to.tp))..'_pack('..
                    '((CEU_'..id..'*)__ceu_new_'..me.n..')));')
        end

        LINE(me, [[
    if (]]..ID..[[ != NULL) {
]])

        --if pool and (type(pool.var.tp.arr)=='table') or
           --PROPS.has_orgs_news_pool or OPTS.os then
            LINE(me, [[
#ifdef CEU_ORGS_NEWS_POOL
        ]]..ID..[[->pool = &]]..V(pool,'rval')..[[;
#endif
]])
        --end

        local org = '_ceu_org'
        if pool and pool.org then
            org = '((tceu_org*)&'..V(pool.org,'rval')..')'
        end

        F._ORG(me, {
            id     = 'dyn',
            isDyn  = 1,
            cls    = me.cls,
            val    = '(*((CEU_'..id..'*)'..ID..'))',
            constr = constr,
            arr    = false,
            parent_org = V(pool,'rval')..'.parent_org',
            parent_trl = V(pool,'rval')..'.parent_trl',
            set    = set and set[4]
        })
        LINE(me, [[
    }
/*}*/
]])
    end,

    Block_pre = function (me)
        local cls = CLS()
        if (not cls) or cls.is_ifc then
            return
        end

        if me.fins then
            LINE(me, [[
/*  FINALIZE */
_ceu_org->trls[ ]]..me.trl_fins[1]..[[ ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ ]]..me.trl_fins[1]..[[ ].lbl = ]]..me.lbl_fin.id..[[;
]])
            for _, fin in ipairs(me.fins) do
                LINE(me, fin.val..' = 0;')
            end
        end

        -- declare tmps
        -- initialize pools
        -- initialize ADTs base cases
        -- initialize Optional types to NIL
        LINE(me, '{')       -- close in Block_pos
        for _, var in ipairs(me.vars) do
            if var.isTmp then
                local ID = '__ceu_'..var.id..'_'..var.n
                if var.id == '_ret' then
                    LINE(me,'#ifdef CEU_RET\n')     -- avoids "unused" warning
                end
                LINE(me, MEM.tp2dcl(var.pre, var.tp,ID,nil)..';\n')
                if var.id == '_ret' then
                    LINE(me,'#endif\n')             -- avoids "unused" warning
                end
                if var.is_arg then
                    -- function parameter
                    -- __ceu_a = a
                    LINE(me, ID..' = '..var.id..';')
                end
            end

            if var.pre == 'var' then
                local tp_id = TP.id(var.tp)

                -- OPTION TYPE
                if TP.check(var.tp,'?') then
                    -- TODO: similar code in Dcl_var for BlockI
                    if me~=cls.blk_ifc or cls.blk_ifc==cls.blk_body  then
                        -- initialize to nil
                        -- has to execute before org initialization in Dcl_var
                        local ID = string.upper(TP.opt2adt(var.tp))
                        LINE(me, [[
]]..V({tag='Var',tp=var.tp,var=var},'rval')..[[.tag = CEU_]]..ID..[[_NIL;
]])
                    end

                -- VECTOR
                elseif TP.check(var.tp,'[]') and (not (var.cls or TP.is_ext(var.tp,'_'))) then
                    local tp_elem = TP.pop( TP.pop(var.tp,'&'), '[]' )
                    local max = (var.tp.arr.cval or 0)
                    local ID = (var.isTmp and '__ceu_'..var.id..'_'..var.n) or
                               CUR(me,var.id_)

                    local blki = AST.par(var.dcl,'BlockI') or me -- init inside _ceu_pre
                    F.Node_pre(blki)
                    LINE(blki, [[
ceu_vector_init(]]..'&'..ID..','..max..',sizeof('..TP.toc(tp_elem)..[[),
                (byte*)]]..ID..[[_mem);
]])
                    if var.tp.arr == '[]' then
                        LINE(me, [[
/*  FINALIZE VECTOR */
_ceu_org->trls[ ]]..var.trl_vector[1]..[[ ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ ]]..var.trl_vector[1]..[[ ].lbl = ]]..(var.lbl_fin_free).id..[[;
]])
                    end
                end

                -- OPTION TO ORG or ORG[]
                if ENV.clss[tp_id] and TP.check(var.tp,tp_id,'&&','?','-[]') then
                    -- TODO: repeated with Block_pos
                    LINE(me, [[
/*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ ]]..var.trl_optorg[1]..[[ ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ ]]..var.trl_optorg[1]..[[ ].lbl = ]]..(var.lbl_optorg_reset).id..[[;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_org->trls[ ]]..var.trl_optorg[1]..[[ ].is_org = 1;
#endif
#endif
_ceu_org->trls[ ]]..var.trl_optorg[1]..[[ ].org_or_adt = NULL;
]])
                end

            elseif var.pre=='pool' and (var.cls or var.adt) then
                -- real pool (not reference or pointer)
                local cls = var.cls
                local adt = var.adt
                local top = cls or adt
                local is_dyn = (var.tp.arr=='[]')

                local tp_id = TP.id(var.tp)
                if top or tp_id=='_TOP_POOL' then
                    local id = (adt and '_' or '') .. var.id_

                    if (not is_dyn) then
                        local tp_id_ = 'CEU_'..tp_id..(top.is_ifc and '_delayed' or '')
                        local pool
                        if cls then
                            pool = CUR(me,id)..'.pool'
                            local trl = assert(var.trl_orgs,'bug found')[1]
                            LINE(me, [[
]]..CUR(me,id)..[[.parent_org = _ceu_org;
]]..CUR(me,id)..[[.parent_trl = ]]..trl..[[;
]])
                        else
                            pool = CUR(me,id)
                        end
                        LINE(me, [[
ceu_pool_init(&]]..pool..','..var.tp.arr.sval..',sizeof('..tp_id_..[[),
              (byte**)&]]..CUR(me,id)..'_queue, (byte*)&'..CUR(me,id)..[[_mem);
]])
                    elseif cls or tp_id=='_TOP_POOL' then
    local trl = assert(var.trl_orgs,'bug found')[1]
                        LINE(me, [[
(]]..CUR(me,id)..[[).parent_org = _ceu_org;
(]]..CUR(me,id)..[[).parent_trl = ]]..trl..[[;
#ifdef CEU_ORGS_NEWS_POOL
(]]..CUR(me,id)..[[).pool.queue = NULL;            /* dynamic pool */
#endif
]])
                    end
                end

                -- real pool
                if adt and adt.is_rec then
                    -- create base case NIL and assign to "*l"
                    local tag = unpack( AST.asr(adt,'Dcl_adt', 3,'Dcl_adt_tag') )
                    local tp = 'CEU_'..adt.id

                    -- base case: use preallocated static variable
                    assert(adt.is_rec and tag==adt.tags[1], 'bug found')

                    local VAL_all  = V({tag='Var',tp=var.tp,var=var}, 'lval','adt_top')
                    local VAL_pool = V({tag='Var',tp=var.tp,var=var}, 'lval','adt_pool')
                    if (not is_dyn) then
                        LINE(me, [[
#ifdef CEU_ADTS_NEWS_POOL
]]..VAL_all..[[->pool = ]]..VAL_pool..[[;
#endif
]])
                    else
                        LINE(me, [[
#ifdef CEU_ADTS_NEWS_POOL
]]..VAL_all..[[->pool = NULL;
#endif
]])
                    end
                    LINE(me, [[
]]..VAL_all..[[->root = &CEU_]]..string.upper(adt.id)..[[_BASE;

/*  FINALIZE ADT */
_ceu_org->trls[ ]]..var.trl_adt[1]..[[ ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ ]]..var.trl_adt[1]..[[ ].lbl = ]]..var.lbl_fin_kill_free.id..[[;
]])
                end
            end

            -- initialize trails for ORG_STATS_I & ORG_POOL_I
            -- "first" avoids repetition for STATS in sequence
            -- TODO: join w/ ceu_out_org (removing start from the latter?)
            if var.trl_orgs and var.trl_orgs_first then
                LINE(me, [[
#ifdef CEU_ORGS
_ceu_org->trls[ ]]..var.trl_orgs[1]..[[ ].evt = CEU_IN__ORG;
_ceu_org->trls[ ]]..var.trl_orgs[1]..[[ ].org = NULL;
#endif
]])
            end
        end
    end,

    Block_pos = function (me)
        local stmts = unpack(me)
        local cls = CLS()
        if (not cls) or cls.is_ifc then
            return
        end

        if stmts.trails[1] ~= me.trails[1] then
            LINE(me, [[
_ceu_trl = &_ceu_org->trls[ ]]..stmts.trails[1]..[[ ];
]])
        end

        CONC(me, stmts)
        CLEAR(me)
        LINE(me, [[
if (0) {
]])

        if me.fins then
            CASE(me, me.lbl_fin)
            for i, fin in ipairs(me.fins) do
                LINE(me, [[
if (]]..fin.val..[[) {
    ]] .. fin.code .. [[
}
]])
            end
            HALT(me)
        end

        for _, var in ipairs(me.vars) do
            local is_arr = (TP.check(var.tp,'[]')           and
                           (var.pre == 'var')               and
                           (not TP.is_ext(var.tp,'_','@'))) and
                           (not var.cls)
            local is_dyn = (var.tp.arr=='[]')

            local tp_id = TP.id(var.tp)
            if ENV.clss[tp_id] and TP.check(var.tp,tp_id,'&&','?','-[]') then
                assert(var.pre ~= 'pool')
-- TODO: review both cases (vec vs no-vec)
-- possible BUG: pointer is tested after free
                CASE(me, var.lbl_optorg_reset)
                local tp_opt = TP.pop(var.tp,'[]')
                local ID = string.upper(TP.opt2adt(tp_opt))

                if TP.check(var.tp,'[]') then
                    local val = V({tag='Var',tp=var.tp,var=var}, 'lval')
                    LINE(me, [[
{
    int __ceu_i;
    for (__ceu_i=0; __ceu_i<ceu_vector_getlen(]]..val..[[); __ceu_i++) {
        ]]..TP.toc(tp_opt)..[[* __ceu_one = (]]..TP.toc(tp_opt)..[[*)
                                            ceu_vector_geti(]]..val..[[, __ceu_i);
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( (__ceu_one->tag != CEU_]]..ID..[[_NIL) &&
             (ceu_org_is_cleared((tceu_org*)__ceu_one->SOME.v,
                                 (tceu_org*)__ceu_casted->org_or_adt,
                                 __ceu_casted->t1,
                                 __ceu_casted->t2)) )
        {
            __ceu_one->tag = CEU_]]..ID..[[_NIL;
/*
            ]]..TP.toc(tp_opt)..[[ __ceu_new = ]]..string.upper(TP.toc(tp_opt))..[[_pack(NULL);
            ceu_vector_seti(]]..val..[[,__ceu_i, (byte*)&__ceu_new);
*/
        }
    }
}
]])

                else
                    local val = V({tag='Var',tp=var.tp,var=var}, 'rval')
                    LINE(me, [[
    {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( (]]..val..[[.tag != CEU_]]..ID..[[_NIL) &&
             (ceu_org_is_cleared((tceu_org*)]]..val..[[.SOME.v,
                                 (tceu_org*)__ceu_casted->org_or_adt,
                                 __ceu_casted->t1,
                                 __ceu_casted->t2)) )
        {
            ]]..val..' = '..string.upper(TP.toc(var.tp))..[[_pack(NULL);
        }
    }
]])
                end

                -- TODO: repeated with Block_pre
                LINE(me, [[
/*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ ]]..var.trl_optorg[1]..[[ ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ ]]..var.trl_optorg[1]..[[ ].lbl = ]]..(var.lbl_optorg_reset).id..[[;
]])
                HALT(me)
            end

            if is_arr and is_dyn then
                CASE(me, var.lbl_fin_free)
                LINE(me, [[
ceu_vector_setlen(]]..V({tag='Var',tp=var.tp,var=var},'lval')..[[, 0);
]])
                HALT(me)

            -- release ADT pool items
            elseif var.adt and var.adt.is_rec then
                local id, op = unpack(var.adt)
                CASE(me, var.lbl_fin_kill_free)

                local VAL_root = V({tag='Var',tp=var.tp,var=var}, 'lval')
                local VAL_all  = V({tag='Var',tp=var.tp,var=var}, 'lval','adt_top')
                if PROPS.has_adts_await[var.adt.id] then
                    LINE(me, [[
#if 0
"kill" only while in scope
CEU_]]..id..[[_kill(_ceu_app, ]]..VAL_root..[[);
#endif
]])
                end
                if is_dyn then
                    local pool
                    if PROPS.has_adts_news_pool then
                        pool = VAL_all..'->pool'
                    else
                        pool = 'NULL'
                    end
                    LINE(me, [[
CEU_]]..id..[[_free(]]..pool..[[, ]]..VAL_root..[[);
]])
                else
-- TODO: required???
--[=[
                    local pool = '('..VAL_all..'->pool)'
                    LINE(me, [[
CEU_]]..id..[[_free_static(_ceu_app, ]]..VAL_root..','..pool..[[);
]])
]=]
                end
                HALT(me)
            end
        end

        LINE(me, [[
    }   /* opened in "if (0)" */
}       /* opened in Block_pre */
]])
    end,

    Pause = CONC_ALL,
    -- TODO: meaningful name
    PauseX = function (me)
        local psed = unpack(me)
        LINE(me, [[
ceu_pause(&_ceu_org->trls[ ]]..me.blk.trails[1]..[[ ],
          &_ceu_org->trls[ ]]..me.blk.trails[2]..[[ ],
        ]]..psed..[[);
]])
    end,

    -- TODO: more tests
    Op2_call_pre = function (me)
        local _, f, exps, fin = unpack(me)
        if fin and fin.active then
            LINE(AST.iter'Stmts'(), fin.val..' = 1;')
        end
    end,
    Finalize = function (me)
        -- enable finalize
        local set,fin = unpack(me)
        if fin.active then
            LINE(me, fin.val..' = 1;')
        end
        if set then
            CONC(me, set)
        end
    end,

    __set_adt_mut_conc_fr = function (me, SET, fr)
        local _,set,_,to = unpack(SET)
        local to_tp_id = TP.id(to.tp)

        local pool = ADT.find_pool(to)
        if PROPS.has_adts_news_pool then
            pool = '('..V(pool,'lval','adt_top')..'->pool)'
        else
            pool = 'NULL'
        end

        LINE(me, [[
{
    void* __ceu_old = ]]..V(to,'lval')..[[;    /* will kill/free old */
]])

        -- HACK: _ceu_org overwritten by _kill
        if PROPS.has_adts_await[to_tp_id] then
            LINE(me,[[
#ifdef CEU_ADTS_NEWS_POOL
    tceu_org* __ceu_stk_org = _ceu_org;
#endif
]])
        end

        if set ~= 'adt-constr' then
            -- remove "fr" from tree (set parent link to NIL)
            LINE(me, [[
    void* __ceu_new = ]]..V(fr,'lval')..[[;
    ]]..V(fr,'lval')..[[ = &CEU_]]..string.upper(TP.id(fr.tp))..[[_BASE;
    ]]..V(to,'lval','no_cast')..[[ = __ceu_new;
]])
        end

        -- TODO: Unfortunately, allocation needs to happen before "free".
        -- We need to "free" before the "kill" because the latter might abort
        -- something and never return to accomplish the allocation and
        -- mutation.

        CONC(me, fr)                    -- 1. allocation
        if set == 'adt-constr' then     -- 2. mutation
            LINE(me, [[
]]..V(to,'lval','no_cast')..' = '..V(fr,'lval')..[[;
]])
        end

        LINE(me, [[                     /* 3. free */
    CEU_]]..to_tp_id..[[_free(]]..pool..[[, __ceu_old);
]])

        LINE(me, [[

#ifdef CEU_ADTS_AWAIT_]]..to_tp_id..[[

    /* OK_KILLED (after free) */        /* 4. kill */
{
    tceu_stk stk_ = { _ceu_stk, _ceu_org, ]]..me.trails[1]..[[, ]]..me.trails[2]..[[, 1 };
    tceu_evt evt;
             evt.id = CEU_IN__ok_killed;
             evt.param = &__ceu_old;
    ceu_sys_go_ex(_ceu_app, &evt, &stk_,
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
                 );
    if (!stk_.is_alive) {
        return;
    }
}
#endif
]])
        LINE(me, [[
}
]])
    end,

    __set = function (me, fr, to)
        local is_byref = (fr.tag=='Op1_&')

        if AST.par(me, 'BlockI') then
            assert(to.tag == 'Var', 'bug found')
            if to.var.isTmp == true then
                return  -- not accessed anywhere, so I'll skip it
            end
        end

        -- optional types
        if TP.check(to.tp,'?') then
            if TP.check(fr.tp,'?') then
                LINE(me, V(to,'rval')..' = '..V(fr,'rval')..';')
            else
                local to_tp_id = TP.id(to.tp)
                if TP.check(to.tp,'&','?') and fr.fst.tag=='Op2_call' then
                    -- var _t&? = _f(...);
                    -- var T*? = spawn <...>;
                    WRN(fr.fst.__fin_opt_tp, me, 'missing `finalizeÂ´')
                    local ID
                    if fr.fst.__fin_opt_tp then
-- precisa desse caso?
                        ID = string.upper(TP.opt2adt(fr.fst.__fin_opt_tp))
                    else
-- esse nao esta mais correto?
                        ID = string.upper(TP.opt2adt(to.tp))
                    end
                    local fr_val = '(CEU_'..ID..'_pack('..V(fr,'rval')..'))'
                    LINE(me, V(to,'rval')..' = '..fr_val..';')
                elseif ENV.clss[to_tp_id] and 
                       TP.check(to.tp,to_tp_id,'&&','?','-[]')
                then
                    -- var T&&? p = &&t;
                    LINE(me, [[
if ( ]]..V(fr,'rval')..[[!=NULL &&
     ((tceu_org*)]]..V(fr,'rval')..[[)->isAlive )
{
]]..V(to,'rval')..' = '..string.upper(TP.toc(to.tp))..[[_pack(]]..V(fr,'rval')..[[);
} else {
]]..V(to,'rval')..' = '..string.upper(TP.toc(to.tp))..[[_pack(NULL);
}
]])
                else
                    local ID = string.upper(TP.opt2adt(to.tp))
                    LINE(me, V(to,'rval')..'.tag = CEU_'..ID..'_SOME;')
                    LINE(me, V(to,'rval')..'.SOME.v = '..V(fr,'rval')..';')
                end
            end
        else
            -- normal types
            local l_or_r = (is_byref and TP.check(to.tp,'&') and 'lval')
                                or 'rval'
            LINE(me, V(to,l_or_r)..' = '..V(fr,'rval')..';')
                                            -- & makes 'lval' on this side
        end

        if to.tag=='Var' and to.var.id=='_ret' then
            if CLS().id == 'Main' then
                LINE(me, [[
#ifdef CEU_RET
    _ceu_app->ret = ]]..V(to,'rval')..[[;
#endif
]])
            else
                LINE(me, [[
#ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = ]]..V(to,'rval')..[[;
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
]])
            end
        end
    end,

    Set = function (me)
        local _, set, fr, to = unpack(me)
        COMM(me, 'SET: '..tostring(to[1]))    -- Var or C

        local _, f = unpack(fr)     -- in case of constructor call _tp(...)

        if set == 'exp' then
            CONC(me, fr)                -- TODO: remove?

            -- vec[x] = ...
            local _, vec, _ = unpack(to)
            if to.tag=='Op2_idx' and
               TP.check(vec.tp,'[]','-&') and (not TP.is_ext(vec.tp,'_','@'))
            then
                AST.asr(to, 'Op2_idx')
                local _, vec, idx = unpack(to)
                LINE(me, [[
{
    ]]..TP.toc(fr.tp)..' __ceu_p = '..V(fr,'rval')..[[;
#line ]]..me.ln[2]..' "'..me.ln[1]..[["
    ceu_out_assert_msg( ceu_vector_seti(]]..V(vec,'lval')..','..V(idx,'rval')..[[, (byte*)&__ceu_p), "access out of bounds");
}
]])

            -- $vec = ...
            elseif to.tag == 'Op1_$' then
                -- $vec = ...
                local _,vec = unpack(to)
                LINE(me, [[
ceu_out_assert_msg( ceu_vector_setlen(]]..V(vec,'lval')..','..V(fr,'rval')..[[), "invalid attribution : vector size can only shrink" );
]])

            -- _tp(...)
            elseif fr.tag=='Op2_call' and f.c and f.c.mod=='@plain' then
                LINE(me, [[
{
    ]]..TP.toc(to.tp)..[[ __ceu_v_]]..me.n..' = '..V(fr,'rval')..[[;
    ]]..V(to,'rval')..[[ = __ceu_v_]]..me.n..[[;
}
]])

            elseif fr.tag == 'Vector_constr' then
                local first = true
                for i, e in ipairs(fr) do
                    if e.tag == 'Vector_tup' then
                        if #e > 0 then
                            e = AST.asr(e,'', 1,'ExpList')
                            for j, ee in ipairs(e) do
                                if first then
                                    first = false
                                    LINE(me, [[
    ceu_vector_setlen(]]..V(to,'lval')..[[, 0);
    ]])
                                end
                                LINE(me, [[
    {
    ]]..TP.toc(TP.pop(TP.pop(to.tp,'&'),'[]'))..[[ __ceu_p;
    ]])
                                F.__set(me, ee, {tag='RawExp', tp=TP.pop(to.tp,'[]'), '__ceu_p'})
                                LINE(me, [[
    #line ]]..fr.ln[2]..' "'..fr.ln[1]..[["
    ceu_out_assert_msg( ceu_vector_push(]]..V(to,'lval')..[[, (byte*)&__ceu_p), "access out of bounds");
    }
    ]])
                            end
                        end
                    else
                        if TP.check(e.tp,'char','&&','-&') then
                            if first then
                                LINE(me, [[
    ceu_vector_setlen(]]..V(to,'lval')..[[, 0);
    ]])
                            end
                            LINE(me, [[
    #line ]]..e.ln[2]..' "'..e.ln[1]..[["
    ceu_out_assert_msg( ceu_vector_concat_buffer(]]..V(to,'lval')..','..V(e,'rval')..[[, strlen(]]..V(e,'rval')..[[)), "access out of bounds" );
    ]])
                        else
                            assert(TP.check(e.tp,'[]','-&'), 'bug found')
                            if first then
                                LINE(me, [[
    if (]]..V(to,'lval')..' != '..V(e,'lval')..[[) {
        ceu_vector_setlen(]]..V(to,'lval')..[[, 0);
    ]])
                            end
                            LINE(me, [[
    #line ]]..e.ln[2]..' "'..e.ln[1]..[["
    ceu_out_assert_msg( ceu_vector_concat(]]..V(to,'lval')..','..V(e,'lval')..[[), "access out of bounds" );
    ]])
                            if first then
                                LINE(me, [[
    }
    ]])
                            end
                        end
                        first = false
                    end
                end

            -- all other
            else
                F.__set(me, fr, to)
            end

        elseif set == 'adt-ref-pool' then
            CONC(me, fr)                -- TODO: remove?

            --[[
            -- PTR:
            --      l = list:TAG.field;
            -- becomes
            --      l.pool = list.pool
            --      l.root = list:TAG.field
            -- REF:
            --      l = list;
            -- becomes
            --      l = &list
            --]]

            if TP.check(to.var.tp,'&') then
                    LINE(me, [[
]]..V(to,'lval','adt_top')..' = '..V(fr,'lval','adt_top')..[[;
]])
                else
                    local pool = ADT.find_pool(fr)
                    local pool_op = TP.check(pool.tp,'&&','-&') and '->' or '.'
                    LINE(me, [[
#ifdef CEU_ADTS_NEWS_POOL
]]..V(to,'lval','adt_top')..'->pool = '..V(pool,'rval','adt_top')..pool_op..[[pool;
#endif
]]..V(to,'lval','adt_top')..'->root = '..V(fr,'rval')..[[;
]])
                end
        elseif set == 'adt-ref-var' then
            LINE(me, [[
]]..V(to,'rval')..' = '..V(fr,'rval')..[[;
]])

        elseif set == 'adt-mut' then
            F.__set_adt_mut_conc_fr(me, me, fr)

        else
            CONC(me, fr)
        end
    end,

    SetBlock_pos = function (me)
        local blk,_ = unpack(me)
        CONC(me, blk)
        HALT(me)        -- must escape with `escapeÂ´
        if me.has_escape then
            CASE(me, me.lbl_out)
            CLEAR(me)
        end
    end,
    Escape = function (me)
        GOTO(me, AST.iter'SetBlock'().lbl_out.id)
    end,

    _Par = function (me)
        -- Ever/Or/And spawn subs
        COMM(me, me.tag..': spawn subs')
        LINE(me, [[
{
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, ]]..me.trails[1]..[[, ]]..me.trails[2]..[[, 1 };
#endif
]])

        for i, sub in ipairs(me) do
            if i < #me then
                LINE(me, [[
    _ceu_org->trls[ ]]..sub.trails[1]..[[ ].lbl = ]]..me.lbls_in[i].id..[[;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ ]]..sub.trails[1]..[[ ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
]])
            else
                -- execute the last directly (no need to call)
                -- the code for each me[i] should be generated backwards
                LINE(me, [[
    _ceu_trl = &_ceu_org->trls[ ]]..sub.trails[1]..[[ ];
]])
            end
        end

        LINE(me, [[
}
]])
    end,

    ParEver = function (me)
        F._Par(me)
        for i=#me, 1, -1 do
            local sub = me[i]
            if i < #me then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)

            -- only if trail terminates
            if not sub.ana.pos[false] then
                HALT(me)
            end
        end
    end,

    ParOr_pos = function (me)
        F._Par(me)

        for i=#me, 1, -1 do
            local sub = me[i]
            if i < #me then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)

            if not (ANA and sub.ana.pos[false]) then
                COMM(me, 'PAROR JOIN')
                GOTO(me, me.lbl_out.id)
            end
        end
        if not (ANA and me.ana.pos[false]) then
            CASE(me, me.lbl_out)
            CLEAR(me)
        end
    end,

    ParAnd = function (me)
        -- close AND gates
        COMM(me, 'close ParAnd gates')

        local val = CUR(me, '__and_'..me.n)

        for i=1, #me do
            LINE(me, val..'_'..i..' = 0;')
        end

        F._Par(me)

        for i=#me, 1, -1 do
            local sub = me[i]
            if i < #me then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)
            LINE(me, val..'_'..i..' = 1;')
            GOTO(me, me.lbl_tst.id)
        end

        -- AFTER code :: test gates
        CASE(me, me.lbl_tst)
        for i, sub in ipairs(me) do
            LINE(me, [[
if (!]]..val..'_'..i..[[) {
]])
            HALT(me)
            LINE(me, [[
}
]])
        end
    end,

    If = function (me)
        local c, t, f = unpack(me)
        -- TODO: If cond assert(c==ptr or int)

        LINE(me, [[
if (]]..V(c,'rval')..[[) {
]]    ..t.code..[[
} else {
]]    ..f.code..[[
}
]])
    end,

    Loop_pos = function (me)
        local max,iter,to,body = unpack(me)

        local ini, nxt = {}, {}
        local cnd = ''

        if me.i_var then
            ini[#ini+1] = V(me.i_var,'rval')..' = 0'
            nxt[#nxt+1] = V(me.i_var,'rval')..'++'
        end

        if iter then
            if me.iter_tp == 'event' then
                -- nothing to do

            elseif me.iter_tp == 'number' then
                cnd = V(me.i_var,'rval')..' < '..V(iter,'rval')

            elseif me.iter_tp == 'org' then
                -- INI
                local var = iter.lst.var
                local tp_c = TP.toc(iter.tp,{vector_base=true})
                ini[#ini+1] =
V(to,'rval')..' = ('..tp_c..[[)
                    (]]..V(iter,'lval')..[[->parent_org->trls[
                        ]]..V(iter,'lval')..[[->parent_trl
                    ].org)]]

                -- CND
                cnd = '('..V(to,'rval')..' != NULL)'

                -- NXT
                nxt[#nxt+1] =
V(to,'rval')..' = ('..tp_c..[[)
                    ((tceu_org*)]]..V(to,'rval')..[[)->nxt
]]
            else
                error'not implemented'
            end
        end

        ini = table.concat(ini, ', ')
        nxt = table.concat(nxt, ', ')

        -- ensures that cval is constant
        if max then
            LINE(me, 'int __'..me.n..'['..max.cval..'/'..max.cval..'-1] = {};')
        end

        LINE(me, [[
for (]]..ini..';'..cnd..';'..nxt..[[) {
]])

        if max then
            LINE(me, [[
    ceu_out_assert_msg_ex(]]..V(me.i_var,'rval')..' < '..V(max,'rval')..[[, "loop overflow", __FILE__, __LINE__);
]])
        end

        CONC(me,body)
        local async = AST.iter'Async'()
        if async then
            LINE(me, [[
#ifdef ceu_out_pending
    if (ceu_out_pending())
#endif
    {
]])
            HALT(me, {
                evt = 'CEU_IN__ASYNC',
                lbl = me.lbl_asy.id,
            })
            LINE(me, [[
    }
]])
        end

        LINE(me, [[
}
]])
        if me.has_break and ( not (AST.iter(AST.pred_async)()
                                or AST.iter'Dcl_fun'()) )
        then
            CLEAR(me)
        end
    end,

    Break = function (me)
        LINE(me, 'break;')
    end,

    CallStmt = function (me)
        local call = unpack(me)
        LINE(me, V(call,'rval')..';')
    end,

    __emit_ps = function (me)
        local _, e, ps = unpack(me)
        local val = '__ceu_ps_'..me.n
        if ps and #ps>0 then
            local PS = {}
            local tp_c = TP.toc((e.var or e).evt.ins)
            local vector_offset = 0
            for i, p in ipairs(ps) do
                PS[#PS+1] = V(p,'rval')
                if TP.check(p.tp,'[]','&&') then
                    vector_offset = 'offsetof('..tp_c..', _'..i..')'
                end
            end
            LINE(me, [[
]]..tp_c..' '..val..[[;
{
    ]]..tp_c..' '..val..[[_ =
        {
]])
            if OPTS.tuple_vector then
                LINE(me, [[

#ifdef CEU_VECTOR
            ]]..vector_offset..[[,
#endif
]])
            end
            LINE(me, [[
            ]]..table.concat(PS,',')..[[
]])
            if OPTS.tuple_vector then
                LINE(me, [[

#ifdef CEU_VECTOR
            , {}
#endif
]])
            end
            LINE(me, [[
        };
]])
            if OPTS.tuple_vector then
                LINE(me, [[

#ifdef CEU_VECTOR
        ceu_out_assert(]]..vector_offset..[[ < 256);
#endif
]])
            end
            LINE(me, [[
    ]]..val..' = '..val..[[_;
}
]])
                --  tp __ceu_ps_X;
                --  {
                --      tp __ceu_ps_X_ = { ... }    // separate dcl/set because of C++
                --      __ceu_ps_X = __ceu_ps_X_;
                --  }
            val = '(&'..val..')'
        end
        return val
    end,

    EmitExt = function (me)
        local op, e, ps = unpack(me)

        local DIR, dir, ptr
        if e.evt.pre == 'input' then
            DIR = 'IN'
            dir = 'in'
            if op == 'call' then
                ptr = '(CEU_Main*)_ceu_app->data'
            else
                ptr = '_ceu_app'
                -- input emit yields, save the stack
                LINE(me, [[
{
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, ]]..me.trails[1]..[[, ]]..me.trails[2]..[[, 1 };
#endif
]])

            end
        else
            assert(e.evt.pre == 'output')
            DIR = 'OUT'
            dir = 'out'
            ptr = '_ceu_app'
        end

        local t1 = { }
        if e.evt.pre=='input' and op=='call' then
            t1[#t1+1] = '_ceu_app'  -- to access `appÂ´
            t1[#t1+1] = ptr         -- to access `thisÂ´
        end

        local t2 = { ptr, 'CEU_'..DIR..'_'..e.evt.id }

        -- block for __emit_ps
        LINE(me, [[
    {
]])

        if ps and #ps>0 and e[1]~='_WCLOCK' then
            local val = F.__emit_ps(me)
            t1[#t1+1] = val
            if op ~= 'call' then
                t2[#t2+1] = 'sizeof('..TP.toc(e.evt.ins)..')'
            end
            t2[#t2+1] = '(void*)'..val
        else
            if dir=='in' then
                t1[#t1+1] = 'NULL'
            end
            if op ~= 'call' then
                t2[#t2+1] = '0'
            end
            t2[#t2+1] = 'NULL'
        end
        t2 = table.concat(t2, ', ')
        t1 = table.concat(t1, ', ')

        local ret_cast = ''
        if OPTS.os and op=='call' then
            -- when the call crosses the process,
            -- the return val must be casted back
            -- TODO: only works for plain values
            if AST.par(me, 'Set') then
                if TP.toc(e.evt.out) == 'int' then
                    ret_cast = '(int)'
                else
                    ret_cast = '(void*)'
                end
            end
        end

        local op = (op=='emit' and 'emit') or 'call'

        local VAL = '\n'..[[
#if defined(ceu_]]..dir..'_'..op..'_'..e.evt.id..[[)
    ceu_]]..dir..'_'..op..'_'..e.evt.id..'('..t1..[[)

#elif defined(ceu_]]..dir..'_'..op..[[)
    (]]..ret_cast..[[ceu_]]..dir..'_'..op..'('..t2..[[))

#else
    #error ceu_]]..dir..'_'..op..[[_* is not defined
#endif
]]

        if not (op=='emit' and e.evt.pre=='input') then
            local set = AST.par(me, 'Set')
            if set then
                local set_to = set[4]
                LINE(me, V(set_to,'rval')..' = '..VAL..';')
            else
                LINE(me, VAL..';')
            end

            -- block for __emit_ps
            LINE(me, [[
    }
]])
            return
        end

        -------------------------------------------------------------------------------
        -- emit INPUT
        -------------------------------------------------------------------------------

        local no = LABEL_NO(me)

        if e[1] == '_WCLOCK' then
            local suf = (ps[1].tm and '_') or ''
            LINE(me, [[
#ifdef CEU_WCLOCKS
{
    u32 __ceu_tmp_]]..me.n..' = '..V(ps[1],'rval')..[[;
    ceu_sys_go_stk(_ceu_app, CEU_IN__WCLOCK]]..suf..[[, &__ceu_tmp_]]..me.n..[[,
#ifdef CEU_STACK_CLEAR
                   &stk_
#else
                   NULL
#endif
                  );
    while (
#if defined(CEU_RET) || defined(CEU_OS)
           _ceu_app->isAlive &&
#endif
           _ceu_app->wclk_min_set]]..suf..[[<=0) {
#ifdef CEU_STACK_CLEAR
        if (!stk_.is_alive) {
            return;
        }
#endif
        s32 __ceu_dt = 0;
        ceu_sys_go_stk(_ceu_app, CEU_IN__WCLOCK]]..suf..[[, &__ceu_dt,
#ifdef CEU_STACK_CLEAR
                       &stk_
#else
                       NULL
#endif
                      );
    }
}
#endif
]])
        else
            LINE(me, VAL..';')
            LINE(me, [[
#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
]])
        end

        LINE(me, [[
    }   /* block for __emit_ps */
}       /* block for stk_ */
]])

        LINE(me, [[
#if defined(CEU_RET) || defined(CEU_OS)
if (!_ceu_app->isAlive) {
    return;     /* HALT(me) */
}
#endif
]])

        if AST.par(me, 'Async') then
            HALT(me, {
                no   = no,
                evt  = 'CEU_IN__ASYNC',
                lbl  = me.lbl_cnt.id,
            })
        end
    end,

    EmitInt = function (me)
        local _, int, ps = unpack(me)

        LINE(me, [[
{
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, ]]..me.trails[1]..[[, ]]..me.trails[2]..[[, 1 };
#endif
]])

        local val = F.__emit_ps(me)

        -- [ ... | me=stk | ... | oth=stk ]
        LINE(me, [[
    /* trigger the event */
    tceu_evt evt;
    evt.id = ]]..V(int,'evt')..[[;
#ifdef CEU_ORGS
#line ]]..int.ln[2]..' "'..int.ln[1]..[["
    evt.org = (tceu_org*) ]]..((int.org and V(int.org,'lval')) or '_ceu_org')..[[;
#endif
]])
        if ps and #ps>0 then
            LINE(me, [[
    evt.param = ]]..val..[[;
]])
        end
        LINE(me, [[
    ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}
]])
    end,

    AwaitN = function (me)
        HALT(me)
    end,

    __AwaitInt = function (me)
        local e = unpack(me)
        local org = (e.org and V(e.org,'lval')) or '_ceu_org'
        assert(AST.par(me,'Dcl_cls'), 'bug found')
        local no = LABEL_NO(me)
        HALT(me, {
            no   = no,
            evt  = V(e,'evt'),
            lbl  = me.lbl.id,
            evto = org,
            isEvery = me.isEvery or par_pause,
        })
        DEBUG_TRAILS(me)
    end,

    __AwaitExt = function (me)
        local e, dt, _, org = unpack(me)
        local suf = (dt and dt.tm and '_') or ''  -- timemachine "WCLOCK_"
        assert(AST.par(me,'Dcl_cls'), 'bug found')

        local val = CUR(me, '__wclk_'..me.n)

        if dt then
            LINE(me, [[
ceu_out_wclock]]..suf..[[(_ceu_app, (s32)]]..V(dt,'rval')..[[, &]]..val..[[, NULL);
]])
        end

        local no = LABEL_NO(me)

        local is_org, org_or_adt
        if e[1] == '_ok_killed' then
            local _,_,v = unpack(e)
            is_org = (ENV.clss[TP.id(v.tp)] and 1 or 0)
            org_or_adt = '(void*)'..V(v,'lval')
        end

        HALT(me, {
            no  = no,
            evt = 'CEU_IN_'..e.evt.id..suf,
            lbl = me.lbl.id,
            is_org = is_org,
            org_or_adt = org_or_adt,
        })

        if dt then
            LINE(me, [[
    /* subtract time and check if I have to awake */
    {
        s32** __ceu_casted = (s32**)_ceu_evt->param;
        if (!ceu_out_wclock]]..suf..[[(_ceu_app, *(*__ceu_casted), NULL, &]]..val..[[) ) {
            goto ]]..no..[[;
        }
    }
]])
        end

        DEBUG_TRAILS(me)
    end,

    Await = function (me)
        local e, dt = unpack(me)
        if e.tag == 'Ext' then
            F.__AwaitExt(me)
        else
            F.__AwaitInt(me)
        end

        local set = AST.par(me, 'Set')
        if set then
            local set_to = set[4]
            for i, v in ipairs(set_to) do
                local tp
                local val
                if dt then
                    local suf = (dt.tm and '_') or ''
                    val = '(_ceu_app->wclk_late'..suf..')'
                elseif e.tag=='Ext' then
                    if e[1] == '_ok_killed' then
                        if TP.tostr(set_to.tp)=='(void&&)' then
                            -- ADT
                            tp = 'tceu_org**'
                            val = '(*(__ceu_casted))'
                        else
                            -- ORG
                            tp = 'tceu_kill*'
                            val = '((__ceu_casted)->ret)'
                        end
                    else
                        tp = TP.toc(me.tp)..'*'
                        val = '((*(__ceu_casted))->_'..i..')'
                        if TP.check(v.tp,'?') then
                            local ID = string.upper(TP.toc(v.tp))
                            val = ID..'_pack('..val..')'
                            --local ID = string.upper(TP.toc(e.evt.ins.tup[i]))
                            --val = 'CEU_OPTION_'..ID..'_pack('..val..')'
                        end
                    end
                else
                    tp = TP.toc(me.tp)
                    val = '((__ceu_casted)->_'..i..')'
                end
                LINE(me, [[
{
]])
                if tp then
                    LINE(me, [[
    ]]..tp..[[ __ceu_casted = (]]..tp..[[) _ceu_evt->param;
]])
                end

                -- payload, only assign if not a request error
                if e.__adj_is_request and i==3 then
                    LINE(me, [[
    if ((*__ceu_casted)->_2 == 0)
]])
                end
                LINE(me, [[
    {
        ]]..V(v,'rval')..' = '..val..[[;
    }
}
]])
            end
        end
    end,

    Async = function (me)
        local vars,blk = unpack(me)
        HALT(me, {
            evt = 'CEU_IN__ASYNC',
            lbl = me.lbl.id,
        })
        CONC(me, blk)
    end,

    Thread = function (me)
        local vars,blk = unpack(me)

        -- TODO: transform to Set in the AST?
        if vars then
            for i=1, #vars, 2 do
                local isRef, n = vars[i], vars[i+1]
                if not isRef then
                    LINE(me, V(n.new,'rval')..' = '..V(n.var,'rval')..';')
                        -- copy async parameters
                end
            end
        end

        -- spawn thread
        LINE(me, [[
/* TODO: test it! */
]]..me.thread_st..[[  = ceu_out_realloc(NULL, sizeof(s8));
*]]..me.thread_st..[[ = 0;  /* ini */
{
    tceu_threads_p p = { _ceu_app, _ceu_org, ]]..me.thread_st..[[ };
    int ret =
        CEU_THREADS_CREATE(&]]..me.thread_id..[[, _ceu_thread_]]..me.n..[[, &p);
    if (ret == 0)
    {
        int v = CEU_THREADS_DETACH(]]..me.thread_id..[[);
        ceu_out_assert_msg(v == 0, "bug found");
        _ceu_app->threads_n++;

        /* wait for "p" to be copied inside the thread */
        CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);

        while (1) {
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
            int ok = (*(p.st) >= 1);   /* cpy ok? */
            if (ok)
                break;
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
        }

        /* proceed with sync execution (already locked) */
        *(p.st) = 2;    /* lck: now thread may also execute */
]])

        local no = LABEL_NO(me)
        HALT(me, {
            no  = no,
            evt = 'CEU_IN__THREAD',
            lbl = me.lbl.id,
        })
        LINE(me, [[
        {
            CEU_THREADS_T** __ceu_casted = (CEU_THREADS_T**)_ceu_evt->param;
            if (*(*(__ceu_casted)) != ]]..me.thread_id..[[) {
                goto ]]..no..[[; /* another thread is terminating: await again */
            }
        }
    }
}
]])
        DEBUG_TRAILS(me)

        local set = AST.par(me, 'Set')
        if set then
            local set_to = set[4]
            LINE(me, V(set_to,'rval')..' = (*('..me.thread_st..') > 0);')
        end

        -- thread function
        CODE.threads = CODE.threads .. [[
static void* _ceu_thread_]]..me.n..[[ (void* __ceu_p)
{
    /* start thread */

    /* copy param */
    tceu_threads_p _ceu_p = *((tceu_threads_p*) __ceu_p);
    tceu_app* _ceu_app = _ceu_p.app;
    tceu_org* _ceu_org = _ceu_p.org;

    /* now safe for sync to proceed */
    CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
    *(_ceu_p.st) = 1;
    CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);

    /* ensures that sync reaquires the mutex and terminates
     * the current reaction before I proceed
     * otherwise I could lock below and reenter sync
     */
    while (1) {
        CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
        int ok = (*(_ceu_p.st) >= 2);   /* lck ok? */
        CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
        if (ok) {
            break;
        }
    }

    /* body */
    ]]..blk.code..[[

    /* goto from "sync" and already terminated */
    ]]..me.lbl_out.id..[[:

    /* terminate thread */
    {
        CEU_THREADS_T __ceu_thread = CEU_THREADS_SELF();
        void* evtp = &__ceu_thread;
        /*pthread_testcancel();*/
        CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
    /* only if sync is not active */
        if (*(_ceu_p.st) < 3) {             /* 3=end */
            *(_ceu_p.st) = 3;
            ceu_out_go(_ceu_app, CEU_IN__THREAD, evtp);   /* keep locked */
                /* HACK_2:
                 *  A thread never terminates the program because we include an
                 *  <async do end> after it to enforce terminating from the
                 *  main program.
                 */
        } else {
            ceu_out_realloc(_ceu_p.st, 0);  /* fin finished, I free */
            _ceu_app->threads_n--;
        }
        CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
    }

    /* more correct would be two signals:
     * (1) above, when I finish
     * (2) finalizer, when sync finishes
     * now the program may hang if I never reach here
    CEU_THREADS_COND_SIGNAL(&_ceu_app->threads_cond);
     */
    return NULL;
}
]]
    end,

    Isr = function (me)
        local _,f,_,blk = unpack(me)

        local code = string.gsub(blk.code, '_ceu_org', '((tceu_org*)CEU_APP.data)')
        code = string.gsub(code, '_ceu_app', '(&CEU_APP)')

        CODE.isrs = CODE.isrs .. [[
void ]]..f..[[ (void)
{
    tceu_stk* _ceu_stk = NULL;
    ]]..code..[[
}
]]
    end,


    RawStmt = function (me)
        if me.thread then
            me.thread.thread_st = CUR(me, '__thread_st_'..me.thread.n)
            me.thread.thread_id = CUR(me, '__thread_id_'..me.thread.n)
                -- TODO: ugly, should move to "Thread" node

            me[1] = [[
if (*]]..me.thread.thread_st..[[ < 3) {     /* 3=end */
    *]]..me.thread.thread_st..[[ = 3;
    ceu_out_assert_msg( pthread_cancel(]]..me.thread.thread_id..[[) == 0 , "bug found")
} else {
    ceu_out_realloc(]]..me.thread.thread_st..[[, 0); /* thr finished, I free */
    _ceu_app->threads_n--;
}
]]
        end

        LINE(me, me[1])
    end,

    Lua = function (me)
        local nargs = #me.params

        local set_to
        local nrets
        local set = AST.par(me, 'Set')
        if set then
            set_to = set[4]
            nrets = 1
        else
            nrets = 0
        end

        local lua = string.format('%q', me.lua)
        lua = string.gsub(lua, '\n', 'n') -- undo format for \n
        LINE(me, [[
{
    int err;
    ceu_luaL_loadstring(err,_ceu_app->lua, ]]..lua..[[);
    if (! err) {
]])

        for _, p in ipairs(me.params) do
            ASR(TP.id(p.tp)~='@', me, 'unknown type')
            if TP.isNumeric(p.tp) then
                LINE(me, [[
        ceu_lua_pushnumber(_ceu_app->lua,]]..V(p,'rval')..[[);
]])
            elseif TP.check(p.tp,'char','[]','-&') then
                LINE(me, [[
        ceu_lua_pushstring(_ceu_app->lua,(char*)]]..V(p,'lval')..[[->mem);
]])
            elseif TP.check(p.tp,'char','&&','-&') then
                LINE(me, [[
        ceu_lua_pushstring(_ceu_app->lua,]]..V(p,'rval')..[[);
]])
            elseif TP.check(p.tp,'&&','-&') then
                LINE(me, [[
        ceu_lua_pushlightuserdata(_ceu_app->lua,]]..V(p,'rval')..[[);
]])
            else
                error 'not implemented'
            end
        end

        LINE(me, [[
        ceu_lua_pcall(err, _ceu_app->lua, ]]..nargs..','..nrets..[[, 0);
        if (! err) {
]])
        if set then
            if TP.isNumeric(set_to.tp) or set_to.tp=='bool' then
                LINE(me, [[
            int is;
            int ret;
            ceu_lua_isnumber(is, _ceu_app->lua,-1);
            if (is) {
                ceu_lua_tonumber(ret, _ceu_app->lua,-1);
            } else {
                ceu_lua_isboolean(is, _ceu_app->lua,-1);
                if (is) {
                    ceu_lua_toboolean(ret, _ceu_app->lua,-1);
                } else {
                    ceu_lua_pushstring(_ceu_app->lua, "not implemented [1]");
                    err = 1;
                }
            }
            ]]..V(set_to,'rval')..[[ = ret;
            ceu_lua_pop(_ceu_app->lua, 1);
]])
            elseif TP.check(set_to.tp,'char','[]','-&') then
                LINE(me, [[
            int is;
            ceu_lua_isstring(is, _ceu_app->lua,-1);
            if (is) {
                const char* ret;
                int len;
                ceu_lua_objlen(len, _ceu_app->lua, -1);
                ceu_lua_tostring(ret, _ceu_app->lua, -1);
#line ]]..me.ln[2]..' "'..me.ln[1]..[["
                ceu_out_assert_msg( ceu_vector_concat_buffer(]]..V(set_to,'lval')..[[, ret, len), "access out of bounds" );
            } else {
                ceu_lua_pushstring(_ceu_app->lua, "not implemented [2]");
                err = 1;
            }
            ceu_lua_pop(_ceu_app->lua, 1);
]])
            elseif TP.check(set_to.tp,'&&','-&') then
                LINE(me, [[
            void* ret;
            int is;
            ceu_lua_islightuserdata(is, _ceu_app->lua,-1);
            if (is) {
                ceu_lua_touserdata(ret,_ceu_app->lua,-1);
            } else {
                ceu_lua_pushstring(_ceu_app->lua, "not implemented [3]");
                err = 1;
            }
            ]]..V(set_to,'rval')..[[ = ret;
            ceu_lua_pop(_ceu_app->lua, 1);
]])
            else
                error 'not implemented'
            end
        end

        LINE(me, [[
            if (! err) {
                goto _CEU_LUA_OK_]]..me.n..[[;
            }
        }
    }
/* ERROR */
    ceu_lua_error(_ceu_app->lua); /* TODO */

/* OK */
_CEU_LUA_OK_]]..me.n..[[:;
}
]])
    end,

    Atomic = function (me)
        local thread = AST.par(me, 'Thread')
        if thread then
            LINE(me, [[
CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
if (*(_ceu_p.st) == 3) {        /* 3=end */
    CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
    goto ]]..thread.lbl_out.id..[[;   /* exit if ended from "sync" */
} else {                        /* othrewise, execute block */
]])
            CONC(me)
            LINE(me, [[
    CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
}
]])
        else
            LINE(me, 'ceu_out_isr_off();')
            CONC(me)
            LINE(me, 'ceu_out_isr_on();')
        end
    end,
}

AST.visit(F)

end

    --AST.dump(AST.root)
end

local function SUB (str, from, to)
    assert(to, from)
    local i,e = string.find(str, from, 1, true)
    if i then
        return SUB(string.sub(str,1,i-1) .. to .. string.sub(str,e+1),
                   from, to)
    else
        return str
    end
end

local HH, CC

-- TEMPLATE.H
do
    HH = FILES.template_h
    HH = SUB(HH, '#include "ceu_os.h"',      FILES.ceu_os_h)
    HH = SUB(HH, '#include "ceu_threads.h"', FILES.ceu_threads_h)


    local tps = { [0]='void', [1]='8', [2]='16', [4]='32' }
    HH = SUB(HH, '=== TCEU_NLBL ===',   's'..tps[TP.types.tceu_nlbl.len])
    HH = SUB(HH, '=== TCEU_NCLS ===',   's'..tps[TP.types.tceu_ncls.len])
    HH = SUB(HH, '=== CEU_NTRAILS ===', MAIN.trails_n)
    HH = SUB(HH, '=== TOPS_H ===',      MEM.tops_h)

    if not OPTS.os then
        -- TODO: ceu_pool_* => ceu_sys_pool_*
        FILES.ceu_pool_h = SUB(FILES.ceu_pool_h, '#include "ceu_os.h"',
                                                 FILES.ceu_os_h)
        HH = SUB(HH, '#include "ceu_pool.h"', FILES.ceu_pool_h)

        -- TODO: ceu_vector_* => ceu_sys_vector_*
        FILES.ceu_vector_h = SUB(FILES.ceu_vector_h, '#include "ceu_os.h"',
                                                     FILES.ceu_os_h)
        HH = SUB(HH, '#include "ceu_vector.h"', FILES.ceu_vector_h)
    end

    -- DEFINES
    do
        local str = ''
        local t = {
            -- props.lua
            has_exts    = 'CEU_EXTS',
            has_wclocks = 'CEU_WCLOCKS',
            has_ints    = 'CEU_INTS',
            has_asyncs  = 'CEU_ASYNCS',
            has_threads = 'CEU_THREADS',
            has_isrs    = 'CEU_ISRS',
            has_orgs    = 'CEU_ORGS',
            has_orgs_news        = 'CEU_ORGS_NEWS',
            has_orgs_news_pool   = 'CEU_ORGS_NEWS_POOL',
            has_orgs_news_malloc = 'CEU_ORGS_NEWS_MALLOC',
            has_adts_news        = 'CEU_ADTS_NEWS',
            has_adts_news_pool   = 'CEU_ADTS_NEWS_POOL',
            has_adts_news_malloc = 'CEU_ADTS_NEWS_MALLOC',
            has_ifcs    = 'CEU_IFCS',
            has_clear   = 'CEU_CLEAR',
            has_stack_clear = 'CEU_STACK_CLEAR',
            has_pses    = 'CEU_PSES',
            has_ret     = 'CEU_RET',
            has_lua     = 'CEU_LUA',
            has_orgs_await = 'CEU_ORGS_AWAIT',

            has_vector        = 'CEU_VECTOR',
            has_vector_pool   = 'CEU_VECTOR_POOL',
            has_vector_malloc = 'CEU_VECTOR_MALLOC',

            -- code.lua
            has_goto    = 'CEU_GOTO',
        }
        for k, s in pairs(t) do
            if PROPS[k] or CODE[k] then
                str = str .. '#define ' .. s .. '\n'
            end
        end

        if next(PROPS.has_adts_await) then
            str = str .. '#define CEU_ADTS_AWAIT\n'
        end
        for id in pairs(PROPS.has_adts_await) do
            str = str .. '#define CEU_ADTS_AWAIT_' .. id .. '\n'
        end

        if ANA.no_nested_termination then
            str = str .. '#define CEU_ANA_NO_NESTED_TERMINATION\n'
        end

        -- TODO: goto OPTS
        --str = str .. '#define CEU_DEBUG_TRAILS\n'
        --str = str .. '#define CEU_NOLINES\n'

        if OPTS.os then
            str = str .. [[
#ifndef CEU_OS_APP
#define CEU_OS_APP
#endif
]]
            if OPTS.os_luaifc then
                str = str .. [[
#ifndef CEU_OS_LUAIFC
#define CEU_OS_LUAIFC
#endif
]]
            end
        end

        if OPTS.timemachine then
            str = str .. [[
#ifndef CEU_TIMEMACHINE
#define CEU_TIMEMACHINE
#endif
]]
        end

        if OPTS.reentrant then
            str = str .. [[
#ifndef CEU_REENTRANT
#define CEU_REENTRANT
#endif
]]
        end

        if OPTS.run_tests then
            str = str .. '#define CEU_RUNTESTS\n'
        end

        local h = OPTS.out_h
        if OPTS.out_h == '-' then
            h = '_STDIN_H'
        end

        HH = SUB(HH, '=== DEFS_H ===',
                     string.upper(string.gsub(h,'%.','_')))
        HH = SUB(HH, '=== DEFINES ===', str)
    end

    -- ISRS
    do
        local str = ''
        for id in pairs(ENV.isrs) do
            str = str..'#define CEU_ISR_'..id..'\n'
        end
        HH = SUB(HH, '=== ISRS ===', str)
    end

    -- EVENTS
    do
        -- inputs: [max_evt+1...) (including _FIN,_WCLOCK,_ASYNC)
        --          cannot overlap w/ internal events
        local str = ''
        local t = {}
        local ins  = 0
        local outs = 0

        -- TODO
        str = str..'#define CEU_IN__NONE 0\n'

        HH = SUB(HH, '=== NATIVE_PRE ===', (OPTS.c_calls and '') or MEM.native_pre)

        for i, evt in ipairs(ENV.exts) do
            if evt.pre == 'input' then
                ins = ins + 1
                evt.n = (256-ins)
                local s = '#define CEU_IN_'..evt.id..' '..evt.n
                if OPTS.verbose and i > 9 then
                    DBG('', s)
                end
                if not (evt.os and OPTS.os) then
                    str = str..s..'\n'
                end
            else
                outs = outs + 1
                evt.n = outs
                local s = '#define CEU_OUT_'..evt.id..' '..evt.n
                if OPTS.verbose then
                    DBG('', s)
                end
                if not (evt.os and OPTS.os) then
                    str = str..s..'\n'
                end
            end
            assert(evt.pre=='input' or evt.pre=='output')
            ASR(ins+outs < 255, me, 'too many events')
        end

        if not OPTS.os then
            str = str..'#define CEU_IN_higher CEU_IN__INIT\n'   -- _INIT = HIGHER EXTERNAL
            str = str..'#define CEU_IN_lower '..(256-ins)..'\n'
        end

        --str = str..'#define CEU_IN_n  '..ins..'\n'
        str = str..'#define CEU_OUT_n '..outs..'\n'

        HH = SUB(HH, '=== EVENTS ===', str)
    end

    -- FUNCTIONS called
    do
        local str = ''
        for id in pairs(ENV.calls) do
            if id ~= '$anon' then
                str = str..'#define CEU_FUN'..id..'\n'
            end
        end
        HH = SUB(HH, '=== FUNCTIONS ===', str)
    end

    -- TUPLES
    do
        local str = ''
        for _,T in pairs(TP.types) do
            if T.tup and #T.tup>0 then
                str = str .. [[
typedef struct {
]]
                if OPTS.tuple_vector then
                    str = str .. [[

#ifdef CEU_VECTOR     /* TODO: check for each tuple */
    u8 vector_offset; /* >0 if this->_N is a vector */
#endif
]]
                end
                for i, t in ipairs(T.tup) do
                    local tmp = TP.toc(t)
                    local tp_id = TP.id(t)
                    if ENV.clss[tp_id] then
                        -- T* => void*
                        -- T** => void**
                        tmp = 'void'..string.match(tmp,'(%*+)')
                    end
                    str = str..'\t'..tmp..' _'..i..';\n'
                end
                if OPTS.tuple_vector then
                    str = str .. [[

#ifdef CEU_VECTOR
    char mem[0];
#endif
]]
                end
                str = str .. [[
} ]]..TP.toc(T)..[[;
]]
            end
        end
        HH = SUB(HH, '=== TUPLES ===', str)
    end
end

-- TEMPLATE.C
do
    CC = FILES.template_c

    CC = SUB(CC, '=== FILENAME ===', OPTS.input)
    --CC = SUB(CC, '^#line.-\n', '')

    CC = SUB(CC, '=== LABELS_ENUM ===', LBLS.code_enum)

    CC = SUB(CC, '=== TOPS_INIT ===',  MEM.tops_init)

    CC = SUB(CC, '=== CONSTRS_C ===',   CODE.constrs)
    CC = SUB(CC, '=== PRES_C ===',      CODE.pres)
    CC = SUB(CC, '=== THREADS_C ===',   CODE.threads)
    CC = SUB(CC, '=== ISRS_C ===',      CODE.isrs)
    CC = SUB(CC, '=== FUNCTIONS_C ===', CODE.functions)
    CC = SUB(CC, '=== STUBS ===',       CODE.stubs)
    CC = SUB(CC, '=== CODE ===',        AST.root.code)
    CC = SUB(CC, '=== NATIVE ===', (OPTS.c_calls and '') or MAIN.native[false])
    CC = SUB(CC, '=== TOPS_C ===',      MEM.tops_c)

    -- IFACES
    if PROPS.has_ifcs then
        local CLSS = {}
        local FLDS = {}
        local EVTS = {}
        local FUNS = {}
        local TRLS = {}
        for _, cls in ipairs(ENV.clss_cls) do
            local clss = {}
            local flds = {}
            local evts = {}
            local funs = {}
            local trls = {}
            for i=1, #ENV.ifcs.flds do
                flds[i] = 0
            end
            for i=1, #ENV.ifcs.evts do
                evts[i] = 0
            end
            for i=1, #ENV.ifcs.funs do
                funs[i] = 'NULL'
            end
            for _, var in ipairs(cls.blk_ifc.vars) do
                if var.pre == 'event' then
                    local i = ENV.ifcs.evts[var.ifc_id]
                    if i then
                        evts[i+1] = var.evt.idx
                    end
                elseif var.pre=='var' or var.pre=='pool' then
                    local i = ENV.ifcs.flds[var.ifc_id]
                    if i then
                        if var.isTmp then
                            flds[i+1] = '0' -- never acessed
                        else
                            flds[i+1] = 'offsetof(CEU_'..cls.id..','..(var.id_ or var.id)..')'
                        end
                    end
                elseif var.pre=='function' then
                    local i = ENV.ifcs.funs[var.ifc_id]
                    if i then
                        funs[i+1] = '(void*)CEU_'..cls.id..'_'..var.id
                    end
                else
                    error 'not implemented'
                end
            end

            -- IFCS_CLSS
            for _,ifc in ipairs(ENV.clss_ifc) do
                clss[#clss+1] = cls.matches[ifc] and 1 or 0
            end

            CLSS[#CLSS+1] = '\t\t{'..table.concat(clss,',')..'}'
            FLDS[#FLDS+1] = '\t\t{'..table.concat(flds,',')..'}'
            EVTS[#EVTS+1] = '\t\t{'..table.concat(evts,',')..'}'
            FUNS[#FUNS+1] = '\t\t{'..table.concat(funs,',')..'}'
            TRLS[#TRLS+1] = '\t\t{'..table.concat(trls,',')..'}'
        end
        CC = SUB(CC, '=== CEU_NCLS ===',     #ENV.clss_cls)
        CC = SUB(CC, '=== IFCS_NIFCS ===',   #ENV.clss_ifc)
        CC = SUB(CC, '=== IFCS_NFLDS ===',   #ENV.ifcs.flds)
        CC = SUB(CC, '=== IFCS_NEVTS ===',   #ENV.ifcs.evts)
        CC = SUB(CC, '=== IFCS_NFUNS ===',   #ENV.ifcs.funs)
        CC = SUB(CC, '=== IFCS_CLSS ===',    table.concat(CLSS,',\n'))
        CC = SUB(CC, '=== IFCS_FLDS ===',    table.concat(FLDS,',\n'))
        CC = SUB(CC, '=== IFCS_EVTS ===',    table.concat(EVTS,',\n'))
        CC = SUB(CC, '=== IFCS_FUNS ===',    table.concat(FUNS,',\n'))
        CC = SUB(CC, '=== IFCS_TRLS ===',    table.concat(TRLS,',\n'))
    end

    if not OPTS.os then
        FILES.ceu_os_c = SUB(FILES.ceu_os_c, '#include "ceu_os.h"',
                                             FILES.ceu_os_h)
        CC = SUB(CC, '#include "ceu_types.h"', FILES.ceu_types_h)
        CC = SUB(CC, '#include "ceu_os.h"',
                     FILES.ceu_os_h..'\n'..FILES.ceu_os_c)

        -- TODO: ceu_pool_* => ceu_sys_pool_*
        FILES.ceu_pool_h = SUB(FILES.ceu_pool_h, '#include "ceu_os.h"',
                                                 FILES.ceu_os_h)
        FILES.ceu_pool_c = SUB(FILES.ceu_pool_c, '#include "ceu_pool.h"', '')
        CC = SUB(CC, '#include "ceu_pool.h"',
                             FILES.ceu_pool_h..'\n'..FILES.ceu_pool_c)

        -- TODO: ceu_vector_* => ceu_sys_vector_*
        FILES.ceu_vector_h = SUB(FILES.ceu_vector_h, '#include "ceu_os.h"',
                                                     FILES.ceu_os_h)
        FILES.ceu_vector_c = SUB(FILES.ceu_vector_c, '#include "ceu_vector.h"', '')
        CC = SUB(CC, '#include "ceu_vector.h"',
                             FILES.ceu_vector_h..'\n'..FILES.ceu_vector_c)
    end

    if OPTS.out_s ~= 'CEU_SIZE' then
        CC = SUB(CC, 'CEU_SIZE', OPTS.out_s)
    end
    if OPTS.out_f ~= 'ceu_app_init' then
        CC = SUB(CC, 'ceu_app_init', OPTS.out_f)
    end

    -- app lua interface
    if OPTS.os_luaifc then
        local ifc = ''
        for i, evt in ipairs(ENV.exts) do
            if string.sub(evt.id,1,1) ~= '_' then
                ifc = ifc ..[[
[ ']]..evt.id..[[' ] = {
    ln  = { ']]..evt.ln[1].."', "..evt.ln[2]..[[ },
    pre = ']]..evt.pre..[[',
    n   = ]]..evt.n..[[,
},
]]
            end
        end
        ifc = 'return {\n'..ifc..'}'
        CC = SUB(CC, '=== APP_LUAIFC ===', string.format("%q",ifc))
    end
end

if OPTS.verbose then
    local T = {
        --mem  = AST.root.mem.max,
        evts = ENV.max_evt+#ENV.exts,
        lbls = #LBLS.list,

        trls = AST.root.trails_n,

        exts      = PROPS.has_exts,
        wclocks   = PROPS.has_wclocks,
        ints      = PROPS.has_ints,
        asyncs    = PROPS.has_asyncs,
        orgs      = PROPS.has_orgs,
        orgs_news = PROPS.has_orgs_news,
        ifcs      = PROPS.has_ifcs,
        ret       = PROPS.has_ret,
    }
    local t = {}
    for k, v in pairs(T) do
        if v == true then
            t[#t+1] = k
        elseif v then
            t[#t+1] = k..'='..v
        end
    end
    table.sort(t)
    DBG('[ '..table.concat(t,' | ')..' ]')
end

-- OUTPUT

if OPTS.out_h and OPTS.out_h~='-' then
    local f = assert(io.open(OPTS.out_h,'w'))
    f:write(HH)
    f:close()
end
CC = SUB(CC, '=== OUT_H ===', HH)

local out
if OPTS.out_c == '-' then
    out = io.stdout
else
    out = assert(io.open(OPTS.out_c,'w'))
end
out:write([[
/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
]] .. CC)
out:close()
